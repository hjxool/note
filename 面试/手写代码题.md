## JS数组去重

### 使用set

- `set`是JS内建对象，只允许存储唯一值

  - `set`只能用`for of`遍历，是一个可迭代对象

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  let t2 = [...new Set(t)] // [1, 2, 3, 4]
  ```

### 使用filter

- 用`indexOf`找首个目标元素索引位置与当前元素索引位置是否相同决定是否返回该元素

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  let t2 = t.filter((ele, index) => t.indexOf(ele) === index)
  ```

### 使用reduce

- `reduce`能用在所有归并一个结果的执行逻辑上

  - 需要用数组的`includes`方法

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  // 初始值为[]空数组
  let t2 = t.reduce((pre,cur) => {
      // 判断当前元素在结果数组中是否存在
      if(!pre.includes(cur)) {
          // 不存在 则填入数组
          pre.push(cur)
      }
      // 记得要把结果数组返回 作为下一轮循环的pre参数
      return pre
  }, [])
  ```

## 将数字每千分位用逗号隔开

- 使用`toLocaleString`

  ```js
  let num = 1234567.89;  
  let string = num.toLocaleString()
  console.log(string);  // 输出 可能 是 "1,234,567.89"
  // 如果想不受本地化设置影响 可以传入参数
  let string2 = num.toLocaleString('en-US')
  ```

## 手写防抖/节流

### 防抖

- 指事件触发后，N秒内只能执行==一次==，N秒内再次触发则重新计算执行时间

- 适用于==延迟触发==的场景

  ```js
  function delounce(func, delay) {
      let timer = null
      // 这里不要用箭头函数 为了保存它自身被调用时的this
      return function (...params) {
          // 注意接收参数
          clearTimeout(timer)
          // 触发后 delay后执行一次
          timer = setTimeout(() => {
              // 为保证func内的this指向 要用call方法
              func.apply(this, params)
          }, delay)
      }
  }
  ```

### 节流

- ==连续触发==，但N秒内只执行一次

- 适用于==控制频率==的场景

  ```js
  function throttle(func, delay) {
      let timer = false
      return function (...params) {
          if(!timer){
              // 触发后 立即执行 但是delay内不能再次执行
              func.apply(this, params)
              // 执行后一段时间内就不能再触发 将标识置为true
              timer = true
              // 并设置定时器 一段时间后再将标识置为false
              setTimeout(() => {
                  timer = false
              }, delay)
          }
      }
  }
  ```

### Vue中使用防抖/节流

- 因为绑定事件的方法必须是防抖/节流返回的函数，因此要用赋值的写法，先执行防抖节流函数将其返回值赋给响应式变量

  ```js
  new Vue({
      el: '#root',
      data: {
  		fn3: null, // 先声明变量
      },
      created(){
          // 将返回函数作为fn3值
          this.fn3 = this.fn1(this.fn2, 2000)
      },
      methods: {
          fn1(func, delay) {
              let timer = false
              return (...params) => {
                  if (!timer) {
                      func.apply(this, params)
                      timer = true
                      setTimeout(() => {
                          timer = false
                      }, delay)
                  }
              }
          },
          fn2() {
              console.log(111)
          },
          fn3: this.fn1(this.fn2, 1000), // 这种不行 因为此时还没有fn1 fn2
          fn3(){
              // 这种不行 必须是fn3本身是fn1返回值
              return this.fn1(this.fn2, 2000)
          }
      }
  })
  ```


## 手写Promise

- 简单来说`new Promise`传入的函数会==立即(同步)执行==，而形参的`resolve reject`是==异步==执行

  - `then`的工作就是往链式的==前一个==`promise对象`身上用==闭包==记录自己的回调函数、`resolve reject`，等自己的方法执行时，用==闭包保存==的`resolve/reject`==修改自身状态==

  ```js
  function Promise(callback){
      // 每个Promise对象都有的以下属性
      this.status = 'pending'
      this.value = null
      this.fulfilledCallback = [] // 成功回调
      this.rejectedCallback = [] // 失败回调
      const resolve = (value) => {
          setTimeout(() => { // resolve/reject是异步
              if(this.status !== 'pending'){
                  return
              }
              // 改变状态、赋值 并执行绑定在自身的下一级promise对象回调方法
              this.status = 'fulfilled'
              this.value = value
              for(let fn of this.fulfilledCallback){
                  fn()
              }
          })
      }
      const reject = (err) => {
          setTimeout(() => {
              if(this.status !== 'pending'){
                  return
              }
              this.status = 'rejected'
              this.value = err
              for(let fn of this.rejectedCallback){
                  fn()
              }
          })
      }
      // 每一步执行都要用try catch包裹
      try{
          callback(resolve, reject) // 创建promise对象的回调函数是立即执行
      } catch(err){
          reject(err)
      }
  }
  Promise.prototype.then = function (onFulfilled, onReject){
      // 在创建promise对象前 先处理未传入回调的情况
      if(typeof onFulfilled !== 'function'){
          onFulfilled = (value) => { return value }
      }
      if(typeof onReject !== 'function'){
          onReject = (err) => { throw err }
      }
      // 创建promise对象 传入特定回调函数逻辑
      return new Promise((resolve, reject) => {
          // 公共逻辑部分
          let common = (fn) => {
              setTimeout(() => {
                  try {
                      let result = fn(this.value)
                      if(result instanceof Promise){
                          result.then(value => {
                              resolve(value)
                          }, err => {
                              reject(err)
                          })
                      } else {
                          resolve(result)
                      }
                  } catch(err){
                      reject(err)
                  }
              })
          }
          // 注意 读取的是上一级promise对象属性
          if(this.status === 'fulfilled'){
              common(onFulfilled)
          } else if(this.status === 'rejected'){
              common(onReject)
          } else if(this.status === 'pending'){
              // 给上一级promise对象绑定当前promise对象回调
              this.fulfilledCallback.push(() => {
                  common(onFulfilled)
              })
              this.rejectedCallback.push(() => {
                  common(onReject)
              })
          }
      })
  }
  Promise.prototype.catch = function (callback) {
      // catch还是复用then 只不过catch传入的单个回调作为then的失败回调
      return this.then(null, callback)
  }
  Promise.all = function (promise_list) {
      // 还是返回promise对象
      return Promise((resolve, reject) => {
          // 处理传入参数不符合条件的情况
          if(!Array.isArray(promise_list)){
              throw '必须传入数组'
          }
          for(let val of promise_list){
              if(val instanceof Promise){
                  throw '必须传入promise对象'
              }
          }
          // 计数统计promise完成数量
          let count = 0
          let total = promise_list.length
          // 因为返回的值是成功后的数组 所以用数组记录结果
          let result = []
          // 这里要用for let i的形式遍历
          // 因为循环内部是异步 需要用索引记录在结果数组中第几位
          for(let i = 0; i < total; i++){
              // 通过then取值
              promise_list[i].then(value => {
                  count++ // 计数增加
                  result[i] = value // 对应位置填结果值
                  // 如果计数结束 将结果数组作为Promise.all返回值
                  if(count === total){
                      resolve(result)
                  }
              }, err => {
                  // 有一个promise对象执行失败 Promise.all返回报错信息
                  reject(err)
              })
          }
      })
  }
  ```

## 手写深拷贝

- 使用`JSON`API进行深拷贝，会有几个问题，无法拷贝属性值为`undefined`、`Date`对象、函数、正则

  ```js
  // 用哈希表记录遍历过的对象
  function deepClone(source, hash = new Map()){
      if(typeof source !== 'object'){
          // 基本数据类型 直接返回
          return source
      }
      // 如果是日期或正则对象则直接返回一个新对象
      if(source instanceof Date){
          return new Date(source)
      }
      if(source instanceof RegExp){
          return new RegExp(source)
      }
      if(hash.has(source)){
          // 哈希表中已经有同引用的对象 直接返回记录值 防止循环引用
          return hash.get(source)
      }
      // 准备一个容器装深拷贝结果
      let clone = Array.isArray(source)? [] : {}
      // 将当前对象存入哈希表 防止循环引用
      hash.set(source, clone)
      // 遍历 将元素/属性取出
      for(let key in source){
          // 判断是否是自身的属性 因为for in会取到原型链的属性
          if(source.hasOwnProperty(key)){
              // 递归拷贝每一个属性
              clone[key] = deepClone(source[key], hash)
          }
      }
      // 返回深拷贝后的结果
      return clone
  }
  ```


## 手写new操作符

```js
function myNew(constructor, ...params) {
    // 1、创建空对象
    let obj = new Object()
    // 2、将这个空对象原型指向构造函数原型
    obj.__proto__ = constructor.prototype
    // 3、以这个新对象作为构造函数的this执行
    let result = constructor.apply(obj, params)
    // 4、判断传入的构造函数是否返回了一个对象
    // 如果构造函数返回了一个对象 则以这个返回值为结果 其身上不一定有构造函数中的属性方法
    // 如果没有返回一个对象 则返回obj作为结果 obj经过构造函数 已经为其身上添加了属性方法
    return typeof result === 'object'? result : obj
}
```

## 函数柯里化

- 柯里化简单来说就是==返回值为函数==，并且应用==闭包、递归==将外层变量存下来进行传递

  - 注：`函数.length`是获得==函数的形参数量==

- 柯里化的几个题目，都是`fn(1)(3)(1,4)`这种形式

  1. 将一个函数柯里化

     ```js
     function target(a, b, c) {
         return a + b + c
     }
     function curry(fn) {
         if(typeof fn !== 'function') {
             throw '必须传入函数'
         }
         // 必须要用命名函数 因为要递归
         return function curried(...params) {
             // 递归就一定要有出口 比如本题递归出口就是参数数量
             if(params.length >= fn.length){
                 // 如果 累计 传入参数数量 大于等于 fn形参数 则传入fn返回结果
                 // 注意 改变fn的this指向
                 return fn.apply(this, params)
             } else {
                 // 传入参数数量不足 则返回一个新的函数 用来接收后续参数
                 // 主要是为了在未执行fn返回最终结果前 缓存 传入参数 然后在递归出口执行最终结果
                 return function (...params2) {
                     // 用了rest参数params是数组 将其合并params2新传入参数
                     // curried执行结果分 新函数 或 fn返回值
                     return curried.apply(this, params.concat(params2))
                 }
             }
         }
     }
     let fn = curry(target)
     console.log(fn(1, 2)(3)) // 6
     console.log(fn(1, 2)(3, 4)) // 6
     ```
     
  2. 实现`sum(1)(2)(3, 4)`
  
     ```js
     // 注意这里一定要用rest参数将其改编成数组 方便后面缓存参数
     function sum(...params) {
         // 这里不能直接返回函数 因为要以toString为递归出口
         function curried(...params2) {
             // 用外层params数组做闭包 缓存参数
             params.push(...params2)
             // 返回自身函数
             return curried
         }
         // 设置递归出口 被console.log输出时执行 覆写toString方法
         curried.toString = () => {
             // 取出缓存的参数 进行运算
             return params.reduce((pre, cur) => {
                 return pre + cur
             }, 0)
         }
         // 返回声明的函数
         return curried
     }
     console.log(sum(1, 2)(3)(4)) // 10
     
     // 另一种实现方式 递归出口为传入一个空函数 sum(1)(2)()
     function sum(...params) {
         function curried(...params2) {
             if(params2.length) {
                 // 参数不为空 则缓存参数
                 params.push(...params2)
                 return curried
             } else {
                 // 递归出口 参数为空 进行运算
                 return params.reduce((pre, cur) => {
                     return pre + cur
                 }, 0)
             }
         }
         return curried
     }
     console.log(sum(1)(2)(3, 4)()) // 10
     ```
     

## 实现AJAX请求

```js
function request(url, method = 'get', data = null) {
    // 链式调用 所以返回promise对象
    return new Promise((resolve, reject) => {
        // 创建http请求
        let xhr = new XMLHttpRequest()
        xhr.open(method, url, true)
        // post请求要设置请求头
        if(method === 'post') {
            xhr.setRequestHeader('Content-Type', 'application/json')
        }
        // 请求回来后执行的逻辑
        xhr.onload = function () {
            if(this.status === 200) {
                // 能请求到接口 请求状态就是200
                resolve(this.reponseText)
            } else {
                // 接口不存在 返回错误信息
                reject(throw this.statusText)
            }
        }
        // 网络错误
        xhr.onerror = function () {
            reject(throw '网络异常')
        }
        // 如果请求要传数据
        if(data) {
            xhr.send(data)
        } else {
            xhr.send()
        }
    })
}
```

## 交换a b值 不用临时变量

- 使用加减法(仅限数字)

  ```js
  let a = 5
  let b = 10
  a = a + b // a 15 b 10
  b = a - b // a 15 b 5
  a = a - b // a 10 b 5
  ```

- 解构赋值

  ```js
  let a = 'aa'
  let b = 'b'
  [a, b] = [b, a] // a 'b' b 'aa'
  ```

## 数组元素求和

- `for`循环

  ```js
  function sum(arr){
      let r = 0
      for(let i = 0; i < arr.length; i++){
          r += arr[i]
      }
      return r
  }
  ```

- 使用`array.reduce`

  ```js
  function sum(arr){
      return arr.reduce((pre, cur) => pre + cur, 0)
  }
  ```

## 数组扁平化

- 使用递归和`array.concat`

  - 因为`concat`可以接收数组作为参数，并将其展开，相当于一次降维

  ```js
  function fn(arr){
      let r = []
      // 遍历传入的数组元素 看是否又是数组
      for(let val of arr) {
          if(Array.isArray(val)){
              // 元素是数组 则递归 将其返回的结果作为concat参数进行降维
              r = r.concat(fn(val))
          } else {
              // 不是数组则添加到结果数组
              r.push(val)
          }
      }
      return r
  }
  ```

- 使用递归、`reduce`、扩展运算符

  ```js
  function fn(arr){
      return arr.reduce((pre, cur) => {
          // 不论元素是不是数组 都将pre结果数组展开 并与当前元素合并成新数组返回
          if(Array.isArray(cur)){
              // 元素是数组 则递归 并将其返回的结果展开 与pre合并成新数组
              return [...pre, ...fn(cur)]
          } else {
              return [...pre, cur]
          }
      }, [])
  }
  ```

- 使用迭代、扩展运算符、`concat`、`some`

  - `concat`可以传入数组和单独的元素，并且会将数组展开
  
  ```js
  function fn(arr){
      while(arr.some(e => Array.isArray(e))) {
          // 元素中有数组 则将整个数组展开 作为concat参数
          arr = [].concat(...arr)
      }
      return arr
  }
  ```
  
- 使用`flat`(了解即可)

  - `flat(参数)`参数为要展开的层数

  ```js
  let t = [1, [2, [3, [4]], 5]]
  console.log(t.flat(Infinity)) // [1, 2, 3, 4, 5]
  ```

## 类数组转化为数组

- 如具有数字索引、`length`属性的对象，转化为真正的数组

- 使用`Array.prototype.slice.call()`

  - 利用`Array`原型身上的`slice`生成数组，但是因为非数组没有`slice`方法，所以要用`call`将`slice`调用者改为目标

  ```js
  let t = {0: 'a', 1: 'b', 2: 'c', length: 3}
  Array.prototype.slice.call(t) // ['a', 'b', 'c']
  ```

- 使用扩展运算符

  ```js
  let t = {0: 'a', 1: 'b', 2: 'c', length: 3}
  let t2 = [...t]
  console.log(t2) // ['a', 'b', 'c']
  ```

- 使用`Array.from`

  - 用于从一个类似数组或可迭代的对象创建一个新的数组实例

  ```js
  let t = {0: 'a', 1: 'b', 2: 'c', length: 3}
  let t2 = Array.from(t)
  console.log(t2) // ['a', 'b', 'c']
  ```

## 将js对象转化为树形结构

- 注意和树节点过滤的区别，过滤只取当前节点符合或存在子节点符合才将当前节点填入当前层结果数组，而本题是将所有属于父节点的子节点填入当前层结果数组

  ```js
  const items = [  
    { id: 1, name: 'Item 1', parentId: null },  
    { id: 2, name: 'Item 1.1', parentId: 1 },  
    { id: 3, name: 'Item 1.2', parentId: 1 },  
    { id: 4, name: 'Item 2', parentId: null },  
    { id: 5, name: 'Item 2.1', parentId: 4 }
  ]
  // 顶层节点的父节点默认值 null
  function fn(list, parentId = null) {
      let r = []
      for(let val of list) {
          if(val.parentId == parentId) {
              // 继续递归找其子节点
              let child = fn(list, val.id)
              // 如果有子节点 则修改当前节点属性
              if(child.length) {
                  val.child = child
              }
              // 只有属于父级id的子节点才填入当前层级的结果数组
              r.push(val)
          }
      }
      // 递归出口 只有属于当前parentId的节点才会进入下次递归
      // 到叶子节点后 只会再往下递归一次 然后因为找不到子节点 返回空数组 并出栈到上一层继续执行
      return r
  }
  let r = fn(itmes)
  [
      {  
      id: 1,  
      name: 'Item 1',  
      parentId: null,  
      child: [  
        { id: 2, name: 'Item 1.1', parentId: 1 },  
        { id: 3, name: 'Item 1.2', parentId: 1 }  
      ]  
    },  
    {  
      id: 4,  
      name: 'Item 2',  
      parentId: null,  
      child: [  
        { id: 5, name: 'Item 2.1', parentId: 4 }  
      ]  
    }
  ]
  ```

## 图片异步加载

```js
function load(url) {
    return new Promise((resolve, reject) => {
        // 创建图片对象
        let img = new Image()
        // 设置加载失败和成功的回调
        img.onload = () => {
            resolve(img) // 用resolve返回img对象
        }
        img.onerror = (err) => {
            reject(err)
        }
        // 赋值到src属性 开始加载图片
        img.src = url
    })
}
load('xxx').then(img => {
    // 将返回的img对象绑定到元素节点
}).catch(err => console.log(err))
```

## 实现发布-订阅模式

- 事件驱动中很常见，如DOM事件

  ```js
  class PubSub {
      constructor() {
          this.subscribes = {} // 收集订阅的事件
      }
      // 添加订阅
      addSub(eventName, callback) {
          if(!this.subscribes[eventName]) {
              // 如果没有对应事件 创建
              this.subscribes[eventName] = []
          }
          // 将订阅传入的回调函数存起来
          this.subscribes[eventName].push(callback)
      }
      // 取消订阅
      removeSub(eventName, callback) {
          // 存在对应事件才执行
          if(this.subscribes[eventName]) {
              // filter过滤出来不等于传入回调的方法 
              this.subscribes = this.subscribes.filter(fn => fn !== callback)
          }
      }
      // 触发订阅事件
      publish(eventName, data) {
          if(this.subscribes[eventName]) {
              this.subscribes.forEach(fn => fn(data))
          }
      }
  }
  // 使用示例
  let p = new PubSub()
  // 订阅
  function fn() {}
  p.addSub('aaa', fn)
  // 发布事件
  p.publish('aaa')
  // 取消订阅
  p.removeSub('aaa', fn)
  ```

## 实现双向数据绑定

- 结合发布-订阅模式、观察者模式

  ```js
  // vue
  class Vue {
      constructor(options) {
          // vue2是将目标对象改造成代理
          this.$data = options.data
          observerOld(this.$data)
          // vue3则是返回新对象
          this.$data = observerNew(options.data)
          // 创建vue实例时初次渲染 以及 解析模板
          compile(options.el, this)
      }
  }
  // Vue2用defineProperty
  function observerOld(obj) {
      if (typeof obj !== 'object') {
          // 不是对象不继续执行
          return;
      } else {
          // 每读取一层 创建一个发布-订阅实例闭包
       	let dep = new Dep()
          // 遍历对象属性
          for(let key in obj) {
              // 关键点 设置局部变量形成闭包 而不是直接读取修改 避免死循环
              let value = obj[key]
              // 递归 子属性继续数据劫持
              observerOld(value)
              // 当前对象进行代理配置 不会生成新对象
              Object.defineProperty(obj, key, {
                  // 默认不可修改和遍历 需设置为true
                  enumerable: true,
                  configurable: true,
                  // 设置getter setter
                  get() {
                      // 关键点 此时正是创建watcher实例 读取属性触发get
                      // 全局变量存着正在创建的watcher实例
                      if(Dep.temp) {
                          // 将其存入发布-订阅数组中 这样watcher实例就不会被释放
                          dep.addSub(Dep.temp)
                      }
                      // 返回闭包value
                      return value
                  },
                  set(newValue) {
                      // 修改闭包值
                      value = newValue
                      // 新值有可能是对象 而defineProperty是对属性进行监听
                      // 所以继续数据代理 否则后续在读取当前属性对象下的属性时无法触发拦截
                      observerOld(newValue)
                      // 值发生变化 发布-订阅通知watcher实例 触发更新dom的回调方法
                      dep.notify()
                  }
              })
          }
      }
  }
  // Vue3使用proxy
  // 注意 必须要创建哈希表存proxy对象
  // 否则 多层级对象修改属性时 在读取目标属性父级时
  // 会因为触发getter创建一个新的proxy对象
  // 而此时Dep.temp为null 导致丢失watcher实例
  // 因此要记录proxy对象 只有查不到时才创建新的
  function observerNew(obj, map = new Map()) {
      if (typeof obj !== 'object') {
          // 不是对象则返回原值
          return obj;
      } else {
          // 查询map中是否有存对应proxy对象
          let old_proxy = map.get(obj)
          if (old_proxy) {
              // 查到了直接返回记录值 不执行后续
              return old_proxy
          }
          let dep = new Dep() // 同observerOld
          // 与defineProperty不同的是 proxy代理会返回一个新对象 所以不需要用value闭包
          // Vue3 数据劫持是惰性的 因为Proxy的特性
          // 它不需要一开始就遍历对象的属性然后对每个属性进行劫持 而是以一个对象为整体
          // 当访问到该属性时再去进行劫持
          // 而defineProperty是对对象属性进行代理 只有读取对应属性才触发拦截
          let new_proxy = new Proxy(obj, {
              // target 被代理的对象 key 当前读取的属性名
              get(target, key) {
                  if (Dep.temp) {
                      // 同observerOld
                      dep.addSub(Dep.temp)
                  }
                  // 对子属性数据代理 将返回的proxy对象作为当前proxy对象属性值
                  return observerNew(target[key], map)
              },
              set(target, key, value) {
                  target[key] = value // 修改值
                  // 注意 这里和defineProperty的区别
                  // 因为proxy是在get中返回一个新proxy对象作为属性值
                  // 所以不需要在set时对新赋值的子属性进行代理
                  // 由dep通知watcher触发更新
                  dep.notify()
                  // proxy中内置了对数组修改的拦截 无需像Vue2重写数组方法
                  // 但是需要对正确修改的操作return ture
                  return true
              }
          })
          // 根据obj索引地址 作为key 记录新创建的proxy对象
          map.set(obj, new_proxy)
          // 再返回该proxy对象
          return new_proxy
      }
  }
  // 解析 替换DOM节点文本内容 生成虚拟dom树
  function compile(dom, vm) {
      // 在vue实例上添加$el属性 保存真实dom根节点
      vm.$el = document.querySelector(dom)
      // 创建空虚拟dom容器
      let fragment = document.createDocumentFragment()
      // 遍历根节点 将所有真实子dom添加到虚拟dom片段中
      let child = vm.$el.firstChild
      while(child) {
          // 注意 同一个dom只能存在于一处
          // 即如果被添加到虚拟dom中 真实dom树中该节点就会消失
          fragment.appendChild(child)
          // 从真实dom树中移除该节点后 vm.$el.firstChild就会移向下一个节点
          // 注 换行 空格也是文本节点 所以也会被添加到虚拟dom中
          child = vm.$el.firstChild
      }
      // dom节点解析替换内容方法
      function fragmentCompile(node) {
          // 以下只有 {{}}插值语法 v-model 解析替换节点内容的示例
          if(node.nodeType === 3) {
              // 解析插值
              // {}是特殊符号需要\转义 插值语法中可能有空格也要进行匹配
              // 用()包裹要替换匹配的字符 exec方法就能提取出()部分的内容
              let reg = /\{\{\s*(\S+)\s*\}\}/ // 过滤 换行 空格 节点
              let result = reg.exec(node.nodeValue) // 值为null 或 数组
              if(result) {
                  // 用闭包保存插值字符串 如{{xx}}
                  // 便于后面watcher回调函数替换节点内容
                  let str = node.nodeValue
                  // result数组中第一个元素是 完整匹配结果
                  // 往后是按顺序用()包裹的子匹配结果 所以取第2个元素
                  let key = result[1] // 'xx'
                  let keyList = path_list(key) // ['xx']
                  // 读取在data配置项中存的属性值
                  let value = keyList.reduce((pre, cur) => pre[cur], vm.$data)
                  // 首次渲染 将数据根据正则匹配 替换原dom内容
                  node.nodeValue = str.replace(reg, value) // <div>12</div>
                  // 关键点 创建watcher实例时 会触发$data中数据拦截
                  // 将当前watcher实例添加到闭包dep中 存在内存中不被释放
                  new Watcher(vm, keyList, newvalue => {
                      // 关联属性 值 发生变化 触发该回调方法
                      node.nodeValue = str.replace(reg, newvalue)
                  })
              }
          } else if(node.nodeType === 1 && node.nodeName === 'INPUT') {
              // input标签节点类型为1 节点名为INPUT
              // 遍历节点属性 找是否有v-model字段
              for(let val of node.attributes) {
                  if(val.nodeName === 'v-model') {
                      // 获取v-model后绑定的属性字段
                      // 不用正则 可以看出不同指令/语法解析逻辑是有区别的
                      let keyList = path_list(val.nodeValue)
                      let value = keyList.reduce((pre, cur) => pre[cur], vm.$data)
                      // 注意 这里修改input节点的value属性 而不是nodeValue
                      val.value = value
                      // 创建watcher实例 传入后续更新回调方法
                      new Watcher(vm, keyList, newvalue => {
                          node.value = newvalue
                      })
                      // 注意 直到上面new watcher为止 都是model到view的逻辑
                      // 接下来设置 view到model逻辑
                      // 要修改内存中属性值 需要找到父级对象索引
                      let parentKey = keyList.slice(0, keyList.length - 1)
                      let parent = parentKey.reduce((pre, cur) => pre[cur], vm.$data)
                      let childKey = keyList[keyList.length - 1]
                      // 添加input事件监听
                      // 这就是为什么说v-model是语法糖 还是要手动添加oninput事件
                      node.addEventListener('input', event => {
                          parent[childKey] = event.target.value
                      })
                      break
                  }
              }
          }
          // 递归 解析子节点
          for(let val of node.childNodes) {
              fragmentCompile(val)
          }
      }
      // 从根节点开始解析虚拟dom
      fragmentCompile(fragment)
      // 将编辑好的虚拟dom插入真实dom
      vm.$el.appendChild(fragment)
  }
  // 将取值路径字符串转换为数组
  function path_list(str) {
      // 先将字符串中[号换成 .
      let t = str.replace(/\[/g, '.')
      // 再将]号去掉
      let t2 = t.replace(/\]/g, '')
      // 最后以.进行分割 返回数组
      return t2.split('.')
  }
  // 观察者
  class Watcher {
      // 接收参数 vue实例 读取属性的key 如'a.b' 更新dom的回调方法
      constructor(vm, keyList, callback) {
          this.vm = vm
          this.keyList = keyList
          this.callback = callback
          // value属性用于对比新旧值 避免重复更新
          this.value = this.get()
      }
      // 只在创建实例时 调用一次
      get() {
          // 先将 当前watcher实例 添加到全局变量 临时存一下
          Dep.temp = this
          // 再读取vue实例身上的属性 触发属性getter 将watcher实例存到发布-订阅实例中
          let value = this.keyList.reduce((pre, cur) => pre[cur], this.vm.$data)
          // 读取完 就将全局变量释放
          Dep.temp = null
          return value
      }
      // 触发更新DOM方法
      update() {
          let newValue = this.keyList.reduce((pre, cur) => pre[cur], this.vm.$data)
          if(this.value !== newValue) {
              // 触发时 值发生变化才执行
              this.value = newValue // 更新value属性
              this.callback(newValue)
          }
      }
  }
  // 发布-订阅
  class Dep {
      constructor() {
          // 注意 这里是数组不是对象 因为由闭包触发更新 不需要知道是哪个事件
          this.subs = []
      }
      // 添加订阅
      addSub(watchObj) {
          // 将传入的观察者实例存起来
          this.subs.push(watchObj)
      }
      // 通知更新
      notify() {
          this.subs.forEach(obj => obj.update())
      }
  }
  ```
  

## 实现简单路由

- 用`hash`实现方式

  - `html`部分

  ```html
  <nav>  
      <a href="#/">Home</a> |  
      <a href="#/page1">About</a> |  
      <a href="#/page2">Contact</a>  
  </nav>  
    
  <div id="content"></div>
  ```

  - `js`部分

  ```js
  let route = {
      // 路由本质就是函数中实例化组件对象来替换目标dom节点内容
      // 其实函数名就是路径
      '/': function () {
          document.getElementById('content').textContent = 'Home Page'
      },
      '/page1': function () {
          document.getElementById('content').textContent = 'Page1'
      },
      '/page2': function () {
          document.getElementById('content').textContent = 'Page2'
      },
  }
  function init() {
      // 通过hash或history截取地址栏路径变化
      let hash = window.location.hash.substring(1)
      if (route[hash]) {
          // 匹配对应函数执行
          route[hash]()
      } else {
          route['/']()
      }
  }
  init()
  // 通过事件监听获取hash变化
  window.addEventListener('hashchange', function () {
      init()
  })
  ```

## 实现斐波那契数列

- 规则：每个数都是前两个数之和，都是正整数

  - `n`表示数列中第`n`个数
  - 递归实现
    - 直接，但是效率低，因为每个新数，都会重新计算之前的数

  ```js
  function fn(n) {
      if(n <= 1) {
          // 递归出口
          return n
      } else {
          // 从-1 -2开始一直递归到n<=1再出栈 最后返回相加值
          return fn(n-1) + fn(n-2)
      }
  }
  ```

  - 迭代实现

  ```js
  function fn(n) {
      if(n <= 1) {
          return n
      }
      let last // 指向新值
      let pre1 = 1 // 指向前1个值
      let pre2 = 0 // 指向前2个值
      for(let i = 2; i <= n; i++) {
          last = pre1 + pre2 // 先计算新值
          pre2 = pre1 // pre2移动到pre1
          pre1 = last // pre1移动到last
      }
      return
  }
  // 哈希表
  function fn(n) {
      // 数组形式的哈希表 第n个即数组长度为n+1
      let arr = new Array(n + 1).fill(0) // 默认填充0
      // 前两个数赋值
      arr[0] = 0
      arr[1] = 1
      for(let i = 2; i <= n; i++) {
          arr[i] = arr[i-1] + arr[i-2]
      }
      return arr[n]
  }
  ```


## 字符串出现的不重复最长长度

```js
// 思路
// 因为是无序字符 所以需要哈希表记录字符
// 用滑动窗口方法 以即将加入的下一个字符判断哈希表内是否出现重复
// 以此为条件 循环缩短窗口 直到窗口内哈希表不存在重复
// 再吸收字符 并判断结果值是否需要更新

function fn(source) {
    let max = 0 // 找最大值初始值就为0
    // 哈希表 记录滑动窗口内字符种类
    let map = new Set() // 因为不需要计数 用set就够了
    let start = 0 // 滑动窗口起始位置
    for (let end = 0; end < source.length; end++) {
        // 因为字符串不是按顺序排列 因此遇到重复的字符
        // 滑动窗口缩短不止一次 因此要用循环直到窗口内没有重复字符
        while (map.has(source[end])) {
            // 即将加入的字符在map中重复 则移动起始位置 缩短窗口
            // 因为要移动起始位置 因此原起始位置字符就要从map中移除
            map.delete(source[start])
            start++ // 移动起始位置
        }
        map.add(source[end]) // 将不重复的新字符添加到map
        if (max < end - start + 1) {
            // 当前窗口长度更长 更新max结果
            max = end - start + 1
        }
    }
    return max
}

// 验证
let str = "abcabcbb"
console.log('最长为' + fn(str)) // 3
```

## 使用setTimeout实现setInterval

- 用递归

  ```js
  function fn(callback, delay) {
      setTimeout(() => {
          fn(callback, delay)
          callback()
      }, delay)
  }
  fn(() => {
      console.log(111)
  }, 2000)
  ```

## 两数之和

- 见`算法.md`的`哈希表-数字之和-两数之和`
- 总结
  - 两数之和用到了哈希表记录另一半
  - 其实两数之和是将一个原数组分两次取用，先遍历一遍存到哈希表中，再遍历一遍用`target - num`匹配记录值，可以看作是两个数组中取值，所以`四数之和II`中从四个数组取值用的是和两数之和一个思路


## 三数之和

- 见`算法.md`的`哈希表-数字之和-三数之和`
- 总结
  - 三数之和没有用哈希表，是在第一层循环固定一个数后，第二层循环挑动另外两个数来组合三数之和
  - 用的是`if`判断来进行去重
  - 三数之和与四数之和都是从一个数组中取值，所以用同一个思路

## 找到字符串中第一个不重复字符的下标

```js
// 思路
// 先遍历字符串 用哈希表统计字符个数
// 再次遍历字符串 每遍历一个字符到哈希表中找对应个数
// 找到第一个个数为1的 返回其下标
function fn(str) {
    let map = {}
    for (let i = 0; i < str.length; i++) {
        let key = str[i]
        map[key] = (map[key] || 0) + 1
    }
    for (let i = 0; i < str.length; i++) {
        if(map[str[i]] === 1){
            return i
        }
    }
    return -1
}

// 验证
let str = 'abcabcbb'
console.log('第一个不重复字符下标：' + fn(str)) // -1
```

## 找到字符串所有排列组合

```js
// 思路
// 利用递归压栈出栈的顺序 每找到一个不重复字符
// 就递归找下一个可加入的字符 然后递归出栈到上一层 继续执行上一层的循环

function fn(str, arr = [], result = []) {
    // 递归出口 arr收集满了就添加到结果数组 返回上一层继续进行循环
    if (arr.length === str.length) {
        // 注意 这里要把arr转换成字符串
        // 否则arr作为闭包在整个过程中使用 最后都会清空
        result.push(arr.join(''))
        return
    }
    // 遍历str 寻找每个可加入arr的字符
    for (let i = 0; i < str.length; i++) {
        // 跳过重复字符
        if (arr.includes(str[i])) {
            continue
        }
        arr.push(str[i])
        // 填入字符 并继续递归遍历整个str 找可能的结果
        fn(str, arr, result)
        // 递归结束 出栈回来 则弹出当前arr.push进去的str[i]
        // 然后继续循环 找可能的字符
        arr.pop()
    }
    // 每一层递归结束 都向上返回result 直至最外层
    return result
}

// 验证
console.log('abc排列组合结果:' + fn('abc')) // abc,acb,bac,bca,cab,cba
```

## 冒泡排序

```js
// 思路
// 用两层循环 外层控制冒泡终点位置
// 因为每次冒泡完都会将最大/小值放到末尾 不用参与排序 因此排除在外
// 里层循环控制单趟排序 相邻元素两两对比交换

function fn(list) {
    let len = list.length
    // 注意 是<len-1 而不是<len 因为是当前元素和后一位对比 因此只取到末尾元素的前一个
    for (let j = 0; j < len - 1; j++) {
        for (let k = 0; k < len - 1 - j; k++) {
            if (list[k] > list[k + 1]) {
                [list[k], list[k + 1]] = [list[k + 1], list[k]]
            }
        }
    }
}

// 验证
let list = [34, 8, 64, 51, 32, 21]
fn(list)
console.log('冒泡排序：' + list) // 8,21,32,34,51,64
```

## 选择排序

```js
// 思路
// 形似冒泡排序 由两层循环组成
// 外层用来固定里层遍历的起始点 并且交换元素位置
// 里层找最小/大元素

function fn(list) {
    // 移动的是起始位置 所以循环终止条件都是数组末尾
    for (let j = 0; j < list.length; j++) {
        // 先设起始位置为最小值
        let minIndex = j
        for (let k = j + 1; k < list.length; k++) {
            if (list[minIndex] > list[k]) {
                // 找到更小的 更新索引
                minIndex = k
            }
        }
        // 里层循环遍历完 找到移动起始点到数组末尾的最小值 交换
        [list[j], list[minIndex]] = [list[minIndex], list[j]]
    }
}

// 验证
let list = [64, 25, 12, 22, 11]
fn(list)
console.log('选择排序：' + list) // [11,12,22,25,64]
```

## 快速排序

```js
// 思路
// 类似1~100累加的递归思路
// 将每层递归传入的数组切一半 小的放左边 大的放右边
// 直到递归传入的数组元素个数小于2 再一层一层向上返回
// 每层递归都将返回的数组降维 合并到当前层的数组
// 最后得到排序结果

function fn(list) {
    // 递归出口
    if (list.length < 2) {
        // 小于等于1 直接返回 因为已经是有序的
        return list
    }
    let mid = Math.floor(list.length / 2) // 中间位置
    let left = [] // 左数组
    let right = [] // 右数组
    for (let val of list) {
        // 注意 遍历时会取到中间值 必须要跳过 否则会死循环
        // 因为每次把中间值去掉 递归下去的数组才能越来越小
        if (val === list[mid]) {
            continue
        }
        if (val <= list[mid]) {
            left.push(val)
        } else {
            right.push(val)
        }
    }
    // 递归左右数组 将其结果合并成新数组
    return [...fn(left), list[mid], ...fn(right)]
}

// 验证
let list = [3, 6, 8, 10, 1, 2, 1]
console.log('快速排序：' + fn(list)) // [1,2,3,6,8,10]
```

## 插入排序

```js
// 思路
// 外层循环记录当前值 里层循环以当前值前一位开始
// 从后往前遍历 遇到比当前值大的 就往后移一位
// 直到前面的已经排好序 比当前值小 又因为大的往后移了
// 中间就出现空缺 就将当前值插到此处

function fn(list) {
    // 从第二个元素开始遍历 默认前面的已排序
    for (let j = 1; j < list.length; j++) {
        let current = list[j] // 记录当前值
        let pre = j - 1 // 前一个元素索引
        //  将当前元素与已排序部分的元素比较 找到合适的位置插入
        while (pre >= 0 && list[pre] > current) {
            list[pre + 1] = list[pre] // pre位置的值往后移
            pre-- // 往前移
        }
        // 此时小于current的没动 大于current的都往后移了一位
        // 中间空了 将current插到此处
        // 注意 此时pre因为最后pre-- 在目标位置前一位
        list[pre + 1] = current
    }
}

// 验证
let list = [4, 3, 2, 10, 12, 1, 5, 6]
fn(list)
console.log('插入排序：' + list) // [1,2,3,4,5,6,10,12]
```

## 树的深度优先搜索

- 见`算法.md`下`二叉树的递归遍历`

  ```js
  function fn(node, result = []) {
      if(node === null){
          // 递归出口
          return
      }
      result.push(node.value) // 中节点
      // 左右节点递归改为遍历子节点递归
      for(let val of node.children || []) {
          fn(val, result)
      }
      return result
  }
  ```

## 树的广度优先搜索

- 见`算法.md`下`二叉树的层序遍历`

  - 与深度搜索的区别在于，不用递归，要用队列

  ```js
  function fn(node, result = []) {
      let queue = []
      queue.push(node)
      // 用一个动态长度队列 一层一层取
      while (queue.length) {
          let size = queue.length
          let layer = [] // 记录每层节点值
          while (size--) {
              let n = queue.shift()
              layer.push(n.value)
              // 判断左右节点是否存在 改为 子节点是否存在 遍历入队列
              for (let val of n.children || []) {
                  queue.push(val)
              }
          }
          result.push(layer)
      }
      return result
  }
  ```

## 树节点过滤

- 后代节点符合条件，保留父节点

  ```js
  function fn(nodes, keyword) {
      function find(node) { // 找当前节点是否符合方法
          return node.label.indexOf(keyword) !== -1
      }
      let result = [] // 记录符合 条件 的节点
      if (!nodes || !nodes.length) {
          return result
      }
      for (let node of nodes) {
          // 先递归
          let child = fn(node.children, keyword)
          // 条件 子节点不为空 或 当前节点符合
          if (child.length || find(node)) {
              node.children = child // 不然到这改了children就丢失子节点了
              result.push(node)
          }
      }
      return result
  }
  ```

- 只保留符合的节点，不保留父节点

  ```js
  function fn(nodes, keyword) {
      function find(node) {
          return node.label.indexOf(keyword) !== -1
      }
      let result = []
      if (!nodes || !nodes.length) {
          return result
      }
      for (let node of nodes) {
          let child = fn(node.children, keyword)
          // 区别在这 不判断child是否为空 只看当前节点是否符合
          // 从而决定如何处理child
          if (find(node)) {
              // 符合 则保留层级结构
              node.children = child
              result.push(node)
          } else {
              // 不符合 则不管当前节点而是将其子节点展开 提升到当前层级
              result.concat(child)
          }
      }
      return result
  }
  ```


## 判断数组是否符合二叉查找树前序遍历

```js
// 思路
// 二叉查找树：特点是所有左节点比父节点的值小 所有右节点比父节点的值大
// 既然是以二叉树结构遍历检查数组 因此以递归的思路每次将当前片段的数组截成两段
// 并在递归时记录下一段左子树的最大值 右子树的最小值
// 以此作为判断是否符合二叉查找树的依据 并以片段的起始位置大于结束位置作为递归出口
// 注 js中 逻辑运算符 为短路运算 如&&是找false 只要找到第一个运算结果为false的就停下
// 并返回其结果(本题是false) 如果没找到false 则返回最后一个表达式运算结果(本题是true)

function fn(arr) {
    // 递归检查子树是否满足前序遍历特性
    function 判断(arr, start, end, min, max) {
        // 每次递归都会向后移动start
        // 当start > end 说明一边的子树已经遍历完 且中间未返回false
        if (start > end) return true; // 递归出口
        // 因为是前序遍历 中左右 当前片段起始位置的元素为中间(根)节点
        let root = arr[start];
        // 关键点 因为每次递归 左子树的最大值会缩小
        // 右子树的最小值会增大 所以如果子树还没start > end的情况下
        // 左子树中间节点大于它的右子节点 或 右子树中间节点小于它的左子节点
        // 说明数组不符合二叉查找树
        if (root < min || root > max) return false; // 递归出口
        // 记录右子树起始位置索引
        // 注意 不一定是右子树最小值
        let right_start;
        // 遍历的起始位置 从中间节点后一位开始
        for (right_start = start + 1; right_start <= end; right_start++) {
            // 找到 第一个大于 子树中间节点的索引位置
            // 作为右子树起始点
            if (arr[right_start] > root) break;
        }
        // 分别递归左右子树 有一个返回false 整个return结果为false
        // 注意 从这递归时 就将数组断开成左右子树范围 分别去递归遍历
        return 判断(arr, start + 1, right_start - 1, min, root - 1) &&
            判断(arr, right_start, end, root + 1, max);
    }
    // Number.是限制数组内数字在可计算范围
    return 判断(arr, 0, arr.length - 1, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
}

// 验证
const 正确例子 = [8, 5, 1, 7, 10, 12];
const 错误例子 = [8, 5, 10, 1, 7, 12];
console.log(fn(正确例子)); // true  
console.log(fn(错误例子)); // false
```

## 买卖股票问题

- 数组中每个元素表示当天的股票价格，求利润最大值

  ```js
  // 思路
  // 本题求累计利润最大值 那依据的就是之前的利润值
  // 注意 当天未持股时利润 = 前一天持股时手头金额 + 今天卖出股票的钱 - 手续费
  // 当天持股时剩余利润 = 前一天未持股时手头金额 - 今天股价
  // 最后取两者中最大值
  
  function fn(prices, fee) {
      // 创建数组哈希表 记录每天 持股时利润hold 和 未持股时利润cash
      let map = new Array(prices.length).fill({ cash: 0, hold: 0 })
      // 先初始化第一天 第一天默认买入股票
      // 所以cash为0 而因为买入股票 hold为负
      map[0].hold = map[0].cash - prices[0]
      // 从第二天开始观察是否卖出
      for (let i = 1; i < prices.length; i++) {
          // 第i天cash 对比 前一天cash 和 假如今天卖出股票累计利润cash
          map[i].cash = Math.max(map[i - 1].cash, map[i - 1].hold + prices[i] - fee)
          // 第i天hold 对比 前一天hold 和 假如今天买入股票剩余利润
          map[i].hold = Math.max(map[i - 1].hold, map[i - 1].cash - prices[i])
      }
      // 对比 持股时累计利润 和 未持股时累计利润
      return Math.max(map[prices.length - 1].cash, map[prices.length - 1].hold)
  }
  
  // 验证
  const prices = [1, 3, 2, 8, 4, 9]
  const fee = 2
  console.log(fn(prices, fee)) // 8
  ```


## 滑动窗口最大值

- 见`算法.md`下`滑动窗口最大值`