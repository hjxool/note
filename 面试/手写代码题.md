## JS数组去重

### 使用set

- `set`是JS内建对象，只允许存储唯一值

  - `set`只能用`for of`遍历，是一个可迭代对象

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  let t2 = [...new Set(t)] // [1, 2, 3, 4]
  ```

### 使用filter

- 用`indexOf`找首个目标元素索引位置与当前元素索引位置是否相同决定是否返回该元素

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  let t2 = t.filter((ele, index) => t.indexOf(ele) === index)
  ```

### 使用reduce

- `reduce`能用在所有归并一个结果的执行逻辑上

  - 需要用数组的`includes`方法

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  // 初始值为[]空数组
  let t2 = t.reduce((pre,cur) => {
      // 判断当前元素在结果数组中是否存在
      if(!pre.includes(cur)) {
          // 不存在 则填入数组
          pre.push(cur)
      }
      // 记得要把结果数组返回 作为下一轮循环的pre参数
      return pre
  }, [])
  ```

## 将数字每千分位用逗号隔开

- 使用`toLocaleString`

  ```js
  let num = 1234567.89;  
  let string = num.toLocaleString()
  console.log(string);  // 输出 可能 是 "1,234,567.89"
  // 如果想不受本地化设置影响 可以传入参数
  let string2 = num.toLocaleString('en-US')
  ```

- 手写实现

  ```js
  function fn(num) {
      let str = num.toString() // 将数字转换成字符串
      let arr = str.split('.')
      // 判断是否有小数
      let 小数 = ''
      if (arr[1]) {
          小数 = `.${arr[1]}`
      }
      // 计算整数位余数
      let 余数 = arr[0].length % 3
      if (余数) {
          // 余数不为0 说明开头不足三位数 需要特殊处理
          let 开头 = arr[0].slice(0, 余数)
          // 注意 match中正则加不加 g区别很大
          // 加g 得到的是['123', '456']
          // 不加g 得到的是[0:'123', input:..., groups:...]
          let 三个数一组 = arr[0].slice(余数).match(/\d{3}/g)
          return `${开头},${三个数一组.join(',')}${小数}`
      } else {
          let 三个数一组 = arr[0].match(/\d{3}/g)
          return `${三个数一组.join(',')}${小数}`
      }
  }
  
  // 验证
  let num = 12123.33
  console.log(fn(num)) // '12,123.33'
  ```

## 手写防抖/节流

### 防抖

- 指事件触发后，N秒内只能执行==一次==，N秒内再次触发则重新计算执行时间

- 适用于==延迟触发==的场景

  ```js
  function delounce(func, delay) {
      let timer = null
      // 这里不要用箭头函数 为了保存它自身被调用时的this
      return function (...params) {
          // 注意接收参数
          clearTimeout(timer)
          // 触发后 delay后执行一次
          timer = setTimeout(() => {
              // 为保证func内的this指向 要用call方法
              func.apply(this, params)
          }, delay)
      }
  }
  ```

### 节流

- ==连续触发==，但N秒内只执行一次

- 适用于==控制频率==的场景

  ```js
  function throttle(func, delay) {
      let timer = false
      return function (...params) {
          if(!timer){
              // 触发后 立即执行 但是delay内不能再次执行
              func.apply(this, params)
              // 执行后一段时间内就不能再触发 将标识置为true
              timer = true
              // 并设置定时器 一段时间后再将标识置为false
              setTimeout(() => {
                  timer = false
              }, delay)
          }
      }
  }
  ```

### Vue中使用防抖/节流

- 因为绑定事件的方法必须是防抖/节流返回的函数，因此要用赋值的写法，先执行防抖节流函数将其返回值赋给响应式变量

  ```js
  new Vue({
      el: '#root',
      data: {
  		fn3: null, // 先声明变量
      },
      created(){
          // 将返回函数作为fn3值
          this.fn3 = this.fn1(this.fn2, 2000)
      },
      methods: {
          fn1(func, delay) {
              let timer = false
              return (...params) => {
                  if (!timer) {
                      func.apply(this, params)
                      timer = true
                      setTimeout(() => {
                          timer = false
                      }, delay)
                  }
              }
          },
          fn2() {
              console.log(111)
          },
          fn3: this.fn1(this.fn2, 1000), // 这种不行 因为此时还没有fn1 fn2
          fn3(){
              // 这种不行 必须是fn3本身是fn1返回值
              return this.fn1(this.fn2, 2000)
          }
      }
  })
  ```


## 手写Promise

- 简单来说`new Promise`传入的函数会==立即(同步)执行==，而形参的`resolve reject`是==异步==执行

  - `then`的工作就是往链式的==前一个==`promise对象`身上用==闭包==记录自己的回调函数、`resolve reject`，等自己的方法执行时，用==闭包保存==的`resolve/reject`==修改自身状态==

  ```js
  function Promise(callback){
      // 每个Promise对象都有的以下属性
      this.status = 'pending'
      this.value = null
      this.fulfilledCallback = [] // 成功回调
      this.rejectedCallback = [] // 失败回调
      const resolve = (value) => {
          setTimeout(() => { // resolve/reject是异步
              if(this.status !== 'pending'){
                  return
              }
              // 改变状态、赋值 并执行绑定在自身的下一级promise对象回调方法
              this.status = 'fulfilled'
              this.value = value
              for(let fn of this.fulfilledCallback){
                  fn()
              }
          })
      }
      const reject = (err) => {
          setTimeout(() => {
              if(this.status !== 'pending'){
                  return
              }
              this.status = 'rejected'
              this.value = err
              for(let fn of this.rejectedCallback){
                  fn()
              }
          })
      }
      // 每一步执行都要用try catch包裹
      try{
          callback(resolve, reject) // 创建promise对象的回调函数是立即执行
      } catch(err){
          reject(err)
      }
  }
  Promise.prototype.then = function (onFulfilled, onReject){
      // 在创建promise对象前 先处理未传入回调的情况
      if(typeof onFulfilled !== 'function'){
          onFulfilled = (value) => { return value }
      }
      if(typeof onReject !== 'function'){
          onReject = (err) => { throw err }
      }
      // 创建promise对象 传入特定回调函数逻辑
      return new Promise((resolve, reject) => {
          // 公共逻辑部分
          let common = (fn) => {
              setTimeout(() => {
                  try {
                      let result = fn(this.value)
                      if(result instanceof Promise){
                          result.then(value => {
                              resolve(value)
                          }, err => {
                              reject(err)
                          })
                      } else {
                          resolve(result)
                      }
                  } catch(err){
                      reject(err)
                  }
              })
          }
          // 注意 读取的是上一级promise对象属性
          if(this.status === 'fulfilled'){
              common(onFulfilled)
          } else if(this.status === 'rejected'){
              common(onReject)
          } else if(this.status === 'pending'){
              // 给上一级promise对象绑定当前promise对象回调
              this.fulfilledCallback.push(() => {
                  common(onFulfilled)
              })
              this.rejectedCallback.push(() => {
                  common(onReject)
              })
          }
      })
  }
  Promise.prototype.catch = function (callback) {
      // catch还是复用then 只不过catch传入的单个回调作为then的失败回调
      return this.then(null, callback)
  }
  // 全部promise完成才返回结果
  Promise.all = function (promise_list) {
      // 还是返回promise对象
      return Promise((resolve, reject) => {
          // 处理传入参数不符合条件的情况
          if(!Array.isArray(promise_list)){
              throw '必须传入数组'
          }
          for(let val of promise_list){
              if(val instanceof Promise){
                  throw '必须传入promise对象'
              }
          }
          // 计数统计promise完成数量
          let count = 0
          let total = promise_list.length
          // 因为返回的值是成功后的数组 所以用数组记录结果
          let result = []
          // 这里要用for let i的形式遍历
          // 因为循环内部是异步 需要用索引记录在结果数组中第几位
          for(let i = 0; i < total; i++){
              // 通过then取值
              promise_list[i].then(value => {
                  count++ // 计数增加
                  result[i] = value // 对应位置填结果值
                  // 如果计数结束 将结果数组作为Promise.all返回值
                  if(count === total){
                      resolve(result)
                  }
              }, err => {
                  // 有一个promise对象执行失败 Promise.all返回报错信息
                  reject(err)
              })
          }
      })
  }
  // 只返回第一个状态改变的promise对象
  Promise.race = function (list) {
      return new Promise((resolve, reject) => {
          // 遍历异步执行所有promise
          // 但只传入当前new Promise的resolve reject
          // 只要第一个状态改变 resolve/reject执行 改变new Promise状态 后续不会执行
          for(let promise of list){
              promise.then(resolve, reject)
      	}
      })
  }
  ```

## 手写深拷贝

- 使用`JSON`API进行深拷贝，会有几个问题，无法拷贝属性值为`undefined`、`Date`对象、函数、正则

  ```js
  // 用哈希表记录遍历过的对象
  function deepClone(source, hash = new Map()){
      if(typeof source !== 'object'){
          // 基本数据类型 直接返回
          return source
      }
      // 如果是日期或正则对象则直接返回一个新对象
      if(source instanceof Date){
          return new Date(source)
      }
      if(source instanceof RegExp){
          return new RegExp(source)
      }
      if(hash.has(source)){
          // 哈希表中已经有同引用的对象 直接返回记录值 防止循环引用
          return hash.get(source)
      }
      // 准备一个容器装深拷贝结果
      let clone = Array.isArray(source)? [] : {}
      // 将当前对象存入哈希表 防止循环引用
      hash.set(source, clone)
      // 遍历 将元素/属性取出
      for(let key in source){
          // 判断是否是自身的属性 因为for in会取到原型链的属性
          if(source.hasOwnProperty(key)){
              // 递归拷贝每一个属性
              clone[key] = deepClone(source[key], hash)
          }
      }
      // 返回深拷贝后的结果
      return clone
  }
  ```


## 手写new操作符

```js
function myNew(constructor, ...params) {
    // 1、创建空对象
    let obj = new Object()
    // 2、将这个空对象原型指向构造函数原型
    obj.__proto__ = constructor.prototype
    // 3、以这个新对象作为构造函数的this执行
    let result = constructor.apply(obj, params)
    // 4、判断传入的构造函数是否返回了一个对象
    // 如果构造函数返回了一个对象 则以这个返回值为结果 其身上不一定有构造函数中的属性方法
    // 如果没有返回一个对象 则返回obj作为结果 obj经过构造函数 已经为其身上添加了属性方法
    return typeof result === 'object'? result : obj
}
```

## 函数柯里化

- 柯里化简单来说就是==返回值为函数==，并且应用==闭包、递归==将外层变量存下来进行传递

  - 注：`函数.length`是获得==函数的形参数量==

- 柯里化的几个题目，都是`fn(1)(3)(1,4)`这种形式

  1. 将一个函数柯里化

     ```js
     function target(a, b, c) {
         return a + b + c
     }
     function curry(fn) {
         if(typeof fn !== 'function') {
             throw '必须传入函数'
         }
         // 必须要用命名函数 因为要递归
         return function curried(...params) {
             // 递归就一定要有出口 比如本题递归出口就是参数数量
             if(params.length >= fn.length){
                 // 如果 累计 传入参数数量 大于等于 fn形参数 则传入fn返回结果
                 // 注意 改变fn的this指向
                 return fn.apply(this, params)
             } else {
                 // 传入参数数量不足 则返回一个新的函数 用来接收后续参数
                 // 主要是为了在未执行fn返回最终结果前 缓存 传入参数 然后在递归出口执行最终结果
                 return function (...params2) {
                     // 用了rest参数params是数组 将其合并params2新传入参数
                     // curried执行结果分 新函数 或 fn返回值
                     return curried.apply(this, params.concat(params2))
                 }
             }
         }
     }
     let fn = curry(target)
     console.log(fn(1, 2)(3)) // 6
     console.log(fn(1, 2)(3, 4)) // 6
     ```
     
  2. 实现`sum(1)(2)(3, 4)`
  
     ```js
     // 注意这里一定要用rest参数将其改编成数组 方便后面缓存参数
     function sum(...params) {
         // 这里不能直接返回函数 因为要以toString为递归出口
         function curried(...params2) {
             // 用外层params数组做闭包 缓存参数
             params.push(...params2)
             // 返回自身函数
             return curried
         }
         // 设置递归出口 被console.log输出时执行 覆写toString方法
         curried.toString = () => {
             // 取出缓存的参数 进行运算
             return params.reduce((pre, cur) => {
                 return pre + cur
             }, 0)
         }
         // 返回声明的函数
         return curried
     }
     console.log(sum(1, 2)(3)(4)) // 10
     
     // 另一种实现方式 递归出口为传入一个空函数 sum(1)(2)()
     function sum(...params) {
         function curried(...params2) {
             if(params2.length) {
                 // 参数不为空 则缓存参数
                 params.push(...params2)
                 return curried
             } else {
                 // 递归出口 参数为空 进行运算
                 return params.reduce((pre, cur) => {
                     return pre + cur
                 }, 0)
             }
         }
         return curried
     }
     console.log(sum(1)(2)(3, 4)()) // 10
     ```
     

## 实现AJAX请求

```js
function request(url, method = 'get', data = null) {
    // 链式调用 所以返回promise对象
    return new Promise((resolve, reject) => {
        // 创建http请求
        let xhr = new XMLHttpRequest()
        xhr.open(method, url, true)
        // post请求要设置请求头
        if(method === 'post') {
            xhr.setRequestHeader('Content-Type', 'application/json')
        }
        // 请求回来后执行的逻辑
        xhr.onload = function () {
            if(this.status === 200) {
                // 能请求到接口 请求状态就是200
                resolve(this.reponseText)
            } else {
                // 接口不存在 返回错误信息
                reject(throw this.statusText)
            }
        }
        // 网络错误
        xhr.onerror = function () {
            reject(throw '网络异常')
        }
        // 如果请求要传数据
        if(data) {
            xhr.send(data)
        } else {
            xhr.send()
        }
    })
}
```

## 交换a b值 不用临时变量

- 使用加减法(仅限数字)

  ```js
  let a = 5
  let b = 10
  a = a + b // a 15 b 10
  b = a - b // a 15 b 5
  a = a - b // a 10 b 5
  ```

- 解构赋值

  ```js
  let a = 'aa'
  let b = 'b'
  [a, b] = [b, a] // a 'b' b 'aa'
  ```

## 数组元素求和

- `for`循环

  ```js
  function sum(arr){
      let r = 0
      for(let i = 0; i < arr.length; i++){
          r += arr[i]
      }
      return r
  }
  ```

- 使用`array.reduce`

  ```js
  function sum(arr){
      return arr.reduce((pre, cur) => pre + cur, 0)
  }
  ```

## 数组扁平化

- 使用递归和`array.concat`

  - 因为`concat`可以接收数组作为参数，并将其展开，相当于一次降维

  ```js
  function fn(arr){
      let r = []
      // 遍历传入的数组元素 看是否又是数组
      for(let val of arr) {
          if(Array.isArray(val)){
              // 元素是数组 则递归 将其返回的结果作为concat参数进行降维
              r = r.concat(fn(val))
          } else {
              // 不是数组则添加到结果数组
              r.push(val)
          }
      }
      return r
  }
  ```

- 使用递归、`reduce`、扩展运算符

  ```js
  function fn(arr){
      return arr.reduce((pre, cur) => {
          // 不论元素是不是数组 都将pre结果数组展开 并与当前元素合并成新数组返回
          if(Array.isArray(cur)){
              // 元素是数组 则递归 并将其返回的结果展开 与pre合并成新数组
              return [...pre, ...fn(cur)]
          } else {
              return [...pre, cur]
          }
      }, [])
  }
  ```

- 使用迭代、扩展运算符、`concat`、`some`

  - `concat`可以传入数组和单独的元素，并且会将数组展开
  
  ```js
  function fn(arr){
      while(arr.some(e => Array.isArray(e))) {
          // 元素中有数组 则将整个数组展开 作为concat参数
          arr = [].concat(...arr)
      }
      return arr
  }
  ```
  
- 使用`flat`(了解即可)

  - `flat(参数)`参数为要展开的层数

  ```js
  let t = [1, [2, [3, [4]], 5]]
  console.log(t.flat(Infinity)) // [1, 2, 3, 4, 5]
  ```

- 使用`toString`和`split`

  - `toString`会把数组转换成`1,2,3,...`这样去除`[]`用`,`号分隔的字符串

  ```js
  function fn() {
      return t.toString().split(',')
  }
  let t = [1, [2, [3, [4]], 5]]
  fn(t) // [1, 2, 3, 4，5]
  ```

## 实现数组flat方法

- 通过==递归==，并用`deep`参数控制递归层数

  ```js
  function fn(arr, deep) {
      // 递归出口
      if (deep <= 0) {
          // deep已经为0 说明不需要再递归展开子元素
          return arr
      }
      let r = []
      for (let val of arr) {
          if (Array.isArray(val)) {
              // deep - 1等于0时 只展开一层
              r.concat(fn(val, deep - 1))
          } else {
              r.push(val)
          }
      }
      return r
  }
  ```

## 实现数组map方法

- 思路：创建一个新的数组，拿每个数组元素传入回调函数的返回值存入该数组

  ```js
  Array.prototype.map = function (callback) {
      if (typeof callback !== 'function') throw '必须传入函数'
      let r = []
      // 注意 this即调用map的数组
      for (let val of this) {
          r.push(callback(val))
      }
      return r
  }
  ```

## 实现数组filter方法

- 思路：类似`map`实现方式，判断数组元素传入回调函数返回值是否为`true`，将其存入新数组

  ```js
  Array.prototype.map = function (callback) {
      if (typeof callback !== 'function') throw '必须传入函数'
      let r = []
      // 注意 this即调用map的数组
      for (let val of this) {
          callback(val) && r.push(val)
      }
      return r
  }
  ```

## 类数组转化为数组

- 如具有数字索引、`length`属性的对象，转化为真正的数组

- 使用`Array.prototype.slice.call()`

  - 利用`Array`原型身上的`slice`生成数组，但是因为非数组没有`slice`方法，所以要用`call`将`slice`调用者改为目标

  ```js
  let t = {0: 'a', 1: 'b', 2: 'c', length: 3}
  Array.prototype.slice.call(t) // ['a', 'b', 'c']
  ```

- 使用扩展运算符

  ```js
  let t = {0: 'a', 1: 'b', 2: 'c', length: 3}
  let t2 = [...t]
  console.log(t2) // ['a', 'b', 'c']
  ```

- 使用`Array.from`

  - 用于从一个类似数组或可迭代的对象创建一个新的数组实例

  ```js
  let t = {0: 'a', 1: 'b', 2: 'c', length: 3}
  let t2 = Array.from(t)
  console.log(t2) // ['a', 'b', 'c']
  ```

## 将js对象转化为树形结构

- 注意和树节点过滤的区别，过滤只取当前节点符合或存在子节点符合才将当前节点填入当前层结果数组，而本题是将所有属于父节点的子节点填入当前层结果数组

- 递归

  ```js
  const items = [  
    { id: 1, name: 'Item 1', parentId: null },  
    { id: 2, name: 'Item 1.1', parentId: 1 },  
    { id: 3, name: 'Item 1.2', parentId: 1 },  
    { id: 4, name: 'Item 2', parentId: null },  
    { id: 5, name: 'Item 2.1', parentId: 4 }
  ]
  // 顶层节点的父节点默认值 null
  function fn(list, parentId = null) {
      let r = []
      for(let val of list) {
          if(val.parentId == parentId) {
              // 继续递归找其子节点
              let child = fn(list, val.id)
              // 如果有子节点 则修改当前节点属性
              if(child.length) {
                  val.child = child
              }
              // 只有属于父级id的子节点才填入当前层级的结果数组
              r.push(val)
          }
      }
      // 递归出口 只有属于当前parentId的节点才会进入下次递归
      // 到叶子节点后 只会再往下递归一次 然后因为找不到子节点 返回空数组 并出栈到上一层继续执行
      return r
  }
  let r = fn(itmes)
  [
      {  
      id: 1,  
      name: 'Item 1',  
      parentId: null,  
      child: [  
        { id: 2, name: 'Item 1.1', parentId: 1 },  
        { id: 3, name: 'Item 1.2', parentId: 1 }  
      ]  
    },  
    {  
      id: 4,  
      name: 'Item 2',  
      parentId: null,  
      child: [  
        { id: 5, name: 'Item 2.1', parentId: 4 }  
      ]  
    }
  ]
  ```

- 迭代

  ```js
  function fn(list) {
      let result = []
      // 将对象及其对应id存起来
      let map = {}
      for (let val of list) {
          map[val.id] = val
      }
      // 利用同一对象 其引用地址相同 在其身上修改
      // 不受遍历顺序影响
      for (let val of list) {
          if (val.parentId) {
              // 有父节点 则根据父级id 在map中找到对应对象
              // 添加child属性 装入当前对象引用地址
              let t = map[val.parentId].child || (map[val.parentId].child = [])
              t.push(val)
          } else {
              // 没有父节点 说明放在result数组最外层
              result.push(val)
          }
      }
      return result
  }
  ```

## 图片异步加载

```js
function load(url) {
    return new Promise((resolve, reject) => {
        // 创建图片对象
        let img = new Image()
        // 设置加载失败和成功的回调
        img.onload = () => {
            resolve(img) // 用resolve返回img对象
        }
        img.onerror = (err) => {
            reject(err)
        }
        // 赋值到src属性 开始加载图片
        img.src = url
    })
}
load('xxx').then(img => {
    // 将返回的img对象绑定到元素节点
}).catch(err => console.log(err))
```

## 实现发布-订阅模式

- 事件驱动中很常见，如DOM事件

  ```js
  class PubSub {
      constructor() {
          this.subscribes = {} // 收集订阅的事件
      }
      // 添加订阅
      addSub(eventName, callback) {
          if(!this.subscribes[eventName]) {
              // 如果没有对应事件 创建
              this.subscribes[eventName] = []
          }
          // 将订阅传入的回调函数存起来
          this.subscribes[eventName].push(callback)
      }
      // 取消订阅
      removeSub(eventName, callback) {
          // 存在对应事件才执行
          if(this.subscribes[eventName]) {
              // filter过滤出来不等于传入回调的方法 
              this.subscribes = this.subscribes.filter(fn => fn !== callback)
          }
      }
      // 触发订阅事件
      publish(eventName, data) {
          if(this.subscribes[eventName]) {
              this.subscribes.forEach(fn => fn(data))
          }
      }
  }
  // 使用示例
  let p = new PubSub()
  // 订阅
  function fn() {}
  p.addSub('aaa', fn)
  // 发布事件
  p.publish('aaa')
  // 取消订阅
  p.removeSub('aaa', fn)
  ```

## 实现双向数据绑定

- 结合发布-订阅模式、观察者模式

  ```js
  // vue
  class Vue {
      constructor(options) {
          // vue2是将目标对象改造成代理
          this.$data = options.data
          observerOld(this.$data)
          // vue3则是返回新对象
          this.$data = observerNew(options.data)
          // 创建vue实例时初次渲染 以及 解析模板
          compile(options.el, this)
      }
  }
  // Vue2用defineProperty
  function observerOld(obj) {
      if (typeof obj !== 'object') {
          // 不是对象不继续执行
          return;
      } else {
          // 每读取一层 创建一个发布-订阅实例闭包
       	let dep = new Dep()
          // 遍历对象属性
          for(let key in obj) {
              // 关键点 设置局部变量形成闭包 而不是直接读取修改 避免死循环
              let value = obj[key]
              // 递归 子属性继续数据劫持
              observerOld(value)
              // 当前对象进行代理配置 不会生成新对象
              Object.defineProperty(obj, key, {
                  // 默认不可修改和遍历 需设置为true
                  enumerable: true,
                  configurable: true,
                  // 设置getter setter
                  get() {
                      // 关键点 此时正是创建watcher实例 读取属性触发get
                      // 全局变量存着正在创建的watcher实例
                      if(Dep.temp) {
                          // 将其存入发布-订阅数组中 这样watcher实例就不会被释放
                          dep.addSub(Dep.temp)
                      }
                      // 返回闭包value
                      return value
                  },
                  set(newValue) {
                      // 修改闭包值
                      value = newValue
                      // 新值有可能是对象 而defineProperty是对属性进行监听
                      // 所以继续数据代理 否则后续在读取当前属性对象下的属性时无法触发拦截
                      observerOld(newValue)
                      // 值发生变化 发布-订阅通知watcher实例 触发更新dom的回调方法
                      dep.notify()
                  }
              })
          }
      }
  }
  // Vue3使用proxy
  // 注意 必须要创建哈希表存proxy对象
  // 否则 多层级对象修改属性时 在读取目标属性父级时
  // 会因为触发getter创建一个新的proxy对象
  // 而此时Dep.temp为null 导致丢失watcher实例
  // 因此要记录proxy对象 只有查不到时才创建新的
  function observerNew(obj, map = new Map()) {
      if (typeof obj !== 'object') {
          // 不是对象则返回原值
          return obj;
      } else {
          // 查询map中是否有存对应proxy对象
          let old_proxy = map.get(obj)
          if (old_proxy) {
              // 查到了直接返回记录值 不执行后续
              return old_proxy
          }
          let dep = new Dep() // 同observerOld
          // 与defineProperty不同的是 proxy代理会返回一个新对象 所以不需要用value闭包
          // Vue3 数据劫持是惰性的 因为Proxy的特性
          // 它不需要一开始就遍历对象的属性然后对每个属性进行劫持 而是以一个对象为整体
          // 当访问到该属性时再去进行劫持
          // 而defineProperty是对对象属性进行代理 只有读取对应属性才触发拦截
          let new_proxy = new Proxy(obj, {
              // target 被代理的对象 key 当前读取的属性名
              get(target, key) {
                  if (Dep.temp) {
                      // 同observerOld
                      dep.addSub(Dep.temp)
                  }
                  // 对子属性数据代理 将返回的proxy对象作为当前proxy对象属性值
                  return observerNew(target[key], map)
              },
              set(target, key, value) {
                  target[key] = value // 修改值
                  // 注意 这里和defineProperty的区别
                  // 因为proxy是在get中返回一个新proxy对象作为属性值
                  // 所以不需要在set时对新赋值的子属性进行代理
                  // 由dep通知watcher触发更新
                  dep.notify()
                  // proxy中内置了对数组修改的拦截 无需像Vue2重写数组方法
                  // 但是需要对正确修改的操作return ture
                  return true
              }
          })
          // 根据obj索引地址 作为key 记录新创建的proxy对象
          map.set(obj, new_proxy)
          // 再返回该proxy对象
          return new_proxy
      }
  }
  // 解析 替换DOM节点文本内容 生成虚拟dom树
  function compile(dom, vm) {
      // 在vue实例上添加$el属性 保存真实dom根节点
      vm.$el = document.querySelector(dom)
      // 创建空虚拟dom容器
      let fragment = document.createDocumentFragment()
      // 遍历根节点 将所有真实子dom添加到虚拟dom片段中
      let child = vm.$el.firstChild
      while(child) {
          // 注意 同一个dom只能存在于一处
          // 即如果被添加到虚拟dom中 真实dom树中该节点就会消失
          fragment.appendChild(child)
          // 从真实dom树中移除该节点后 vm.$el.firstChild就会移向下一个节点
          // 注 换行 空格也是文本节点 所以也会被添加到虚拟dom中
          child = vm.$el.firstChild
      }
      // dom节点解析替换内容方法
      function fragmentCompile(node) {
          // 以下只有 {{}}插值语法 v-model 解析替换节点内容的示例
          if(node.nodeType === 3) {
              // 解析插值
              // {}是特殊符号需要\转义 插值语法中可能有空格也要进行匹配
              // 用()包裹要替换匹配的字符 exec方法就能提取出()部分的内容
              let reg = /\{\{\s*(\S+)\s*\}\}/ // 过滤 换行 空格 节点
              let result = reg.exec(node.nodeValue) // 值为null 或 数组
              if(result) {
                  // 用闭包保存插值字符串 如{{xx}}
                  // 便于后面watcher回调函数替换节点内容
                  let str = node.nodeValue
                  // result数组中第一个元素是 完整匹配结果
                  // 往后是按顺序用()包裹的子匹配结果 所以取第2个元素
                  let key = result[1] // 'xx'
                  let keyList = path_list(key) // ['xx']
                  // 读取在data配置项中存的属性值
                  let value = keyList.reduce((pre, cur) => pre[cur], vm.$data)
                  // 首次渲染 将数据根据正则匹配 替换原dom内容
                  node.nodeValue = str.replace(reg, value) // <div>12</div>
                  // 关键点 创建watcher实例时 会触发$data中数据拦截
                  // 将当前watcher实例添加到闭包dep中 存在内存中不被释放
                  new Watcher(vm, keyList, newvalue => {
                      // 关联属性 值 发生变化 触发该回调方法
                      node.nodeValue = str.replace(reg, newvalue)
                  })
              }
          } else if(node.nodeType === 1 && node.nodeName === 'INPUT') {
              // input标签节点类型为1 节点名为INPUT
              // 遍历节点属性 找是否有v-model字段
              for(let val of node.attributes) {
                  if(val.nodeName === 'v-model') {
                      // 获取v-model后绑定的属性字段
                      // 不用正则 可以看出不同指令/语法解析逻辑是有区别的
                      let keyList = path_list(val.nodeValue)
                      let value = keyList.reduce((pre, cur) => pre[cur], vm.$data)
                      // 注意 这里修改input节点的value属性 而不是nodeValue
                      val.value = value
                      // 创建watcher实例 传入后续更新回调方法
                      new Watcher(vm, keyList, newvalue => {
                          node.value = newvalue
                      })
                      // 注意 直到上面new watcher为止 都是model到view的逻辑
                      // 接下来设置 view到model逻辑
                      // 要修改内存中属性值 需要找到父级对象索引
                      let parentKey = keyList.slice(0, keyList.length - 1)
                      let parent = parentKey.reduce((pre, cur) => pre[cur], vm.$data)
                      let childKey = keyList[keyList.length - 1]
                      // 添加input事件监听
                      // 这就是为什么说v-model是语法糖 还是要手动添加oninput事件
                      node.addEventListener('input', event => {
                          parent[childKey] = event.target.value
                      })
                      break
                  }
              }
          }
          // 递归 解析子节点
          for(let val of node.childNodes) {
              fragmentCompile(val)
          }
      }
      // 从根节点开始解析虚拟dom
      fragmentCompile(fragment)
      // 将编辑好的虚拟dom插入真实dom
      vm.$el.appendChild(fragment)
  }
  // 将取值路径字符串转换为数组
  function path_list(str) {
      // 先将字符串中[号换成 .
      let t = str.replace(/\[/g, '.')
      // 再将]号去掉
      let t2 = t.replace(/\]/g, '')
      // 最后以.进行分割 返回数组
      return t2.split('.')
  }
  // 观察者
  class Watcher {
      // 接收参数 vue实例 读取属性的key 如'a.b' 更新dom的回调方法
      constructor(vm, keyList, callback) {
          this.vm = vm
          this.keyList = keyList
          this.callback = callback
          // value属性用于对比新旧值 避免重复更新
          this.value = this.get()
      }
      // 只在创建实例时 调用一次
      get() {
          // 先将 当前watcher实例 添加到全局变量 临时存一下
          Dep.temp = this
          // 再读取vue实例身上的属性 触发属性getter 将watcher实例存到发布-订阅实例中
          let value = this.keyList.reduce((pre, cur) => pre[cur], this.vm.$data)
          // 读取完 就将全局变量释放
          Dep.temp = null
          return value
      }
      // 触发更新DOM方法
      update() {
          let newValue = this.keyList.reduce((pre, cur) => pre[cur], this.vm.$data)
          if(this.value !== newValue) {
              // 触发时 值发生变化才执行
              this.value = newValue // 更新value属性
              this.callback(newValue)
          }
      }
  }
  // 发布-订阅
  class Dep {
      constructor() {
          // 注意 这里是数组不是对象 因为由闭包触发更新 不需要知道是哪个事件
          this.subs = []
      }
      // 添加订阅
      addSub(watchObj) {
          // 将传入的观察者实例存起来
          this.subs.push(watchObj)
      }
      // 通知更新
      notify() {
          this.subs.forEach(obj => obj.update())
      }
  }
  ```
  

## 实现简单路由

- 用`hash`实现方式

  - `html`部分

  ```html
  <nav>  
      <a href="#/">Home</a> |  
      <a href="#/page1">About</a> |  
      <a href="#/page2">Contact</a>  
  </nav>  
    
  <div id="content"></div>
  ```

  - `js`部分

  ```js
  let route = {
      // 路由本质就是函数中实例化组件对象来替换目标dom节点内容
      // 其实函数名就是路径
      '/': function () {
          document.getElementById('content').textContent = 'Home Page'
      },
      '/page1': function () {
          document.getElementById('content').textContent = 'Page1'
      },
      '/page2': function () {
          document.getElementById('content').textContent = 'Page2'
      },
  }
  function init() {
      // 通过hash或history截取地址栏路径变化
      let hash = window.location.hash.substring(1)
      if (route[hash]) {
          // 匹配对应函数执行
          route[hash]()
      } else {
          route['/']()
      }
  }
  init()
  // 通过事件监听获取hash变化
  window.addEventListener('hashchange', function () {
      init()
  })
  ```

## 实现斐波那契数列

- 规则：每个数都是前两个数之和，都是正整数

  - `n`表示数列中第`n`个数
  - 递归实现
    - 直接，但是效率低，因为每个新数，都会重新计算之前的数

  ```js
  function fn(n) {
      if(n <= 1) {
          // 递归出口
          return n
      } else {
          // 从-1 -2开始一直递归到n<=1再出栈 最后返回相加值
          return fn(n-1) + fn(n-2)
      }
  }
  ```

  - 迭代实现

  ```js
  function fn(n) {
      if(n <= 1) {
          return n
      }
      let last // 指向新值
      let pre1 = 1 // 指向前1个值
      let pre2 = 0 // 指向前2个值
      for(let i = 2; i <= n; i++) {
          last = pre1 + pre2 // 先计算新值
          pre2 = pre1 // pre2移动到pre1
          pre1 = last // pre1移动到last
      }
      return
  }
  // 哈希表
  function fn(n) {
      // 数组形式的哈希表 第n个即数组长度为n+1
      let arr = new Array(n + 1).fill(0) // 默认填充0
      // 前两个数赋值
      arr[0] = 0
      arr[1] = 1
      for(let i = 2; i <= n; i++) {
          arr[i] = arr[i-1] + arr[i-2]
      }
      return arr[n]
  }
  ```


## 字符串出现的不重复最长长度

```js
// 思路
// 因为是无序字符 所以需要哈希表记录字符
// 用滑动窗口方法 以即将加入的下一个字符判断哈希表内是否出现重复
// 以此为条件 循环缩短窗口 直到窗口内哈希表不存在重复
// 再吸收字符 并判断结果值是否需要更新

function fn(source) {
    let max = 0 // 找最大值初始值就为0
    // 哈希表 记录滑动窗口内字符种类
    let map = new Set() // 因为不需要计数 用set就够了
    let start = 0 // 滑动窗口起始位置
    for (let end = 0; end < source.length; end++) {
        // 因为字符串不是按顺序排列 因此遇到重复的字符
        // 滑动窗口缩短不止一次 因此要用循环直到窗口内没有重复字符
        while (map.has(source[end])) {
            // 即将加入的字符在map中重复 则移动起始位置 缩短窗口
            // 因为要移动起始位置 因此原起始位置字符就要从map中移除
            map.delete(source[start])
            start++ // 移动起始位置
        }
        map.add(source[end]) // 将不重复的新字符添加到map
        if (max < end - start + 1) {
            // 当前窗口长度更长 更新max结果
            max = end - start + 1
        }
    }
    return max
}

// 验证
let str = "abcabcbb"
console.log('最长为' + fn(str)) // 3
```

## 使用setTimeout实现setInterval

- 用递归

  ```js
  function fn(callback, delay) {
      setTimeout(() => {
          fn(callback, delay)
          callback()
      }, delay)
  }
  fn(() => {
      console.log(111)
  }, 2000)
  ```

## 两数之和

- 见`算法.md`的`哈希表-数字之和-两数之和`
- 总结
  - 两数之和用到了哈希表记录另一半
  - 其实两数之和是将一个原数组分两次取用，先遍历一遍存到哈希表中，再遍历一遍用`target - num`匹配记录值，可以看作是两个数组中取值，所以`四数之和II`中从四个数组取值用的是和两数之和一个思路


## 三数之和

- 见`算法.md`的`哈希表-数字之和-三数之和`
- 总结
  - 三数之和没有用哈希表，是在第一层循环固定一个数后，第二层循环挑动另外两个数来组合三数之和
  - 用的是`if`判断来进行去重
  - 三数之和与四数之和都是从一个数组中取值，所以用同一个思路

## 找到字符串中第一个不重复字符的下标

```js
// 思路
// 先遍历字符串 用哈希表统计字符个数
// 再次遍历字符串 每遍历一个字符到哈希表中找对应个数
// 找到第一个个数为1的 返回其下标
function fn(str) {
    let map = {}
    for (let i = 0; i < str.length; i++) {
        let key = str[i]
        map[key] = (map[key] || 0) + 1
    }
    for (let i = 0; i < str.length; i++) {
        if(map[str[i]] === 1){
            return i
        }
    }
    return -1
}

// 验证
let str = 'abcabcbb'
console.log('第一个不重复字符下标：' + fn(str)) // -1
```

## 找到字符串所有排列组合

```js
// 思路
// 利用递归压栈出栈的顺序 每找到一个不重复字符
// 就递归找下一个可加入的字符 然后递归出栈到上一层 继续执行上一层的循环

function fn(str, arr = [], result = []) {
    // 递归出口 arr收集满了就添加到结果数组 返回上一层继续进行循环
    if (arr.length === str.length) {
        // 注意 这里要把arr转换成字符串
        // 否则arr作为闭包在整个过程中使用 最后都会清空
        result.push(arr.join(''))
        return
    }
    // 遍历str 寻找每个可加入arr的字符
    for (let i = 0; i < str.length; i++) {
        // 跳过重复字符
        if (arr.includes(str[i])) {
            continue
        }
        arr.push(str[i])
        // 填入字符 并继续递归遍历整个str 找可能的结果
        fn(str, arr, result)
        // 递归结束 出栈回来 则弹出当前arr.push进去的str[i]
        // 然后继续循环 找可能的字符
        arr.pop()
    }
    // 每一层递归结束 都向上返回result 直至最外层
    return result
}

// 验证
console.log('abc排列组合结果:' + fn('abc')) // abc,acb,bac,bca,cab,cba
```

## 冒泡排序

```js
// 思路
// 用两层循环 外层控制冒泡终点位置
// 因为每次冒泡完都会将最大/小值放到末尾 不用参与排序 因此排除在外
// 里层循环控制单趟排序 相邻元素两两对比交换

function fn(list) {
    let len = list.length
    // 注意 是<len-1 而不是<len 因为是当前元素和后一位对比 因此只取到末尾元素的前一个
    for (let j = 0; j < len - 1; j++) {
        for (let k = 0; k < len - 1 - j; k++) {
            if (list[k] > list[k + 1]) {
                [list[k], list[k + 1]] = [list[k + 1], list[k]]
            }
        }
    }
}

// 验证
let list = [34, 8, 64, 51, 32, 21]
fn(list)
console.log('冒泡排序：' + list) // 8,21,32,34,51,64
```

## 选择排序

```js
// 思路
// 形似冒泡排序 由两层循环组成
// 外层用来固定里层遍历的起始点 并且交换元素位置
// 里层找最小/大元素

function fn(list) {
    // 移动的是起始位置 所以循环终止条件都是数组末尾
    for (let j = 0; j < list.length; j++) {
        // 先设起始位置为最小值
        let minIndex = j
        for (let k = j + 1; k < list.length; k++) {
            if (list[minIndex] > list[k]) {
                // 找到更小的 更新索引
                minIndex = k
            }
        }
        // 里层循环遍历完 找到移动起始点到数组末尾的最小值 交换
        [list[j], list[minIndex]] = [list[minIndex], list[j]]
    }
}

// 验证
let list = [64, 25, 12, 22, 11]
fn(list)
console.log('选择排序：' + list) // [11,12,22,25,64]
```

## 快速排序

```js
// 思路
// 类似1~100累加的递归思路
// 将每层递归传入的数组切一半 小的放左边 大的放右边
// 直到递归传入的数组元素个数小于2 再一层一层向上返回
// 每层递归都将返回的数组降维 合并到当前层的数组
// 最后得到排序结果

function fn(list) {
    // 递归出口
    if (list.length < 2) {
        // 小于等于1 直接返回 因为已经是有序的
        return list
    }
    let mid = Math.floor(list.length / 2) // 中间位置
    let left = [] // 左数组
    let right = [] // 右数组
    for (let val of list) {
        // 注意 遍历时会取到中间值 必须要跳过 否则会死循环
        // 因为每次把中间值去掉 递归下去的数组才能越来越小
        if (val === list[mid]) {
            continue
        }
        if (val <= list[mid]) {
            left.push(val)
        } else {
            right.push(val)
        }
    }
    // 递归左右数组 将其结果合并成新数组
    return [...fn(left), list[mid], ...fn(right)]
}

// 验证
let list = [3, 6, 8, 10, 1, 2, 1]
console.log('快速排序：' + fn(list)) // [1,2,3,6,8,10]
```

## 插入排序

```js
// 思路
// 外层循环记录当前值 里层循环以当前值前一位开始
// 从后往前遍历 遇到比当前值大的 就往后移一位
// 直到前面的已经排好序 比当前值小 又因为大的往后移了
// 中间就出现空缺 就将当前值插到此处

function fn(list) {
    // 从第二个元素开始遍历 默认前面的已排序
    for (let j = 1; j < list.length; j++) {
        let current = list[j] // 记录当前值
        let pre = j - 1 // 前一个元素索引
        //  将当前元素与已排序部分的元素比较 找到合适的位置插入
        while (pre >= 0 && list[pre] > current) {
            list[pre + 1] = list[pre] // pre位置的值往后移
            pre-- // 往前移
        }
        // 此时小于current的没动 大于current的都往后移了一位
        // 中间空了 将current插到此处
        // 注意 此时pre因为最后pre-- 在目标位置前一位
        list[pre + 1] = current
    }
}

// 验证
let list = [4, 3, 2, 10, 12, 1, 5, 6]
fn(list)
console.log('插入排序：' + list) // [1,2,3,4,5,6,10,12]
```

## 树的深度优先搜索

- 见`算法.md`下`二叉树的递归遍历`

  ```js
  function fn(node, result = []) {
      if(node === null){
          // 递归出口
          return
      }
      result.push(node.value) // 中节点
      // 左右节点递归改为遍历子节点递归
      for(let val of node.children || []) {
          fn(val, result)
      }
      return result
  }
  ```

## 树的广度优先搜索

- 见`算法.md`下`二叉树的层序遍历`

  - 与深度搜索的区别在于，不用递归，要用队列

  ```js
  function fn(node, result = []) {
      let queue = []
      queue.push(node)
      // 用一个动态长度队列 一层一层取
      while (queue.length) {
          let size = queue.length
          let layer = [] // 记录每层节点值
          while (size--) {
              let n = queue.shift()
              layer.push(n.value)
              // 判断左右节点是否存在 改为 子节点是否存在 遍历入队列
              for (let val of n.children || []) {
                  queue.push(val)
              }
          }
          result.push(layer)
      }
      return result
  }
  ```

## 树节点过滤

- 后代节点符合条件，保留父节点

  ```js
  function fn(nodes, keyword) {
      function find(node) { // 找当前节点是否符合方法
          return node.label.indexOf(keyword) !== -1
      }
      let result = [] // 记录符合 条件 的节点
      if (!nodes || !nodes.length) {
          return result
      }
      for (let node of nodes) {
          // 先递归
          let child = fn(node.children, keyword)
          // 条件 子节点不为空 或 当前节点符合
          if (child.length || find(node)) {
              node.children = child // 不然到这改了children就丢失子节点了
              result.push(node)
          }
      }
      return result
  }
  ```

- 只保留符合的节点，不保留父节点

  ```js
  function fn(nodes, keyword) {
      function find(node) {
          return node.label.indexOf(keyword) !== -1
      }
      let result = []
      if (!nodes || !nodes.length) {
          return result
      }
      for (let node of nodes) {
          let child = fn(node.children, keyword)
          // 区别在这 不判断child是否为空 只看当前节点是否符合
          // 从而决定如何处理child
          if (find(node)) {
              // 符合 则保留层级结构
              node.children = child
              result.push(node)
          } else {
              // 不符合 则不管当前节点而是将其子节点展开 提升到当前层级
              result.concat(child)
          }
      }
      return result
  }
  ```


## 判断数组是否符合二叉查找树前序遍历

```js
// 思路
// 二叉查找树：特点是所有左节点比父节点的值小 所有右节点比父节点的值大
// 既然是以二叉树结构遍历检查数组 因此以递归的思路每次将当前片段的数组截成两段
// 并在递归时记录下一段左子树的最大值 右子树的最小值
// 以此作为判断是否符合二叉查找树的依据 并以片段的起始位置大于结束位置作为递归出口
// 注 js中 逻辑运算符 为短路运算 如&&是找false 只要找到第一个运算结果为false的就停下
// 并返回其结果(本题是false) 如果没找到false 则返回最后一个表达式运算结果(本题是true)

function fn(arr) {
    // 递归检查子树是否满足前序遍历特性
    function 判断(arr, start, end, min, max) {
        // 每次递归都会向后移动start
        // 当start > end 说明一边的子树已经遍历完 且中间未返回false
        if (start > end) return true; // 递归出口
        // 因为是前序遍历 中左右 当前片段起始位置的元素为中间(根)节点
        let root = arr[start];
        // 关键点 因为每次递归 左子树的最大值会缩小
        // 右子树的最小值会增大 所以如果子树还没start > end的情况下
        // 左子树中间节点大于它的右子节点 或 右子树中间节点小于它的左子节点
        // 说明数组不符合二叉查找树
        if (root < min || root > max) return false; // 递归出口
        // 记录右子树起始位置索引
        // 注意 不一定是右子树最小值
        let right_start;
        // 遍历的起始位置 从中间节点后一位开始
        for (right_start = start + 1; right_start <= end; right_start++) {
            // 找到 第一个大于 子树中间节点的索引位置
            // 作为右子树起始点
            if (arr[right_start] > root) break;
        }
        // 分别递归左右子树 有一个返回false 整个return结果为false
        // 注意 从这递归时 就将数组断开成左右子树范围 分别去递归遍历
        return 判断(arr, start + 1, right_start - 1, min, root - 1) &&
            判断(arr, right_start, end, root + 1, max);
    }
    // Number.是限制数组内数字在可计算范围
    return 判断(arr, 0, arr.length - 1, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
}

// 验证
const 正确例子 = [8, 5, 1, 7, 10, 12];
const 错误例子 = [8, 5, 10, 1, 7, 12];
console.log(fn(正确例子)); // true  
console.log(fn(错误例子)); // false
```

## 买卖股票问题

- 数组中每个元素表示当天的股票价格，求利润最大值

  ```js
  // 思路
  // 本题求累计利润最大值 那依据的就是之前的利润值
  // 注意 当天未持股时利润 = 前一天持股时手头金额 + 今天卖出股票的钱 - 手续费
  // 当天持股时剩余利润 = 前一天未持股时手头金额 - 今天股价
  // 最后取两者中最大值
  
  function fn(prices, fee) {
      // 创建数组哈希表 记录每天 持股时利润hold 和 未持股时利润cash
      let map = new Array(prices.length).fill({ cash: 0, hold: 0 })
      // 先初始化第一天 第一天默认买入股票
      // 所以cash为0 而因为买入股票 hold为负
      map[0].hold = map[0].cash - prices[0]
      // 从第二天开始观察是否卖出
      for (let i = 1; i < prices.length; i++) {
          // 第i天cash 对比 前一天cash 和 假如今天卖出股票累计利润cash
          map[i].cash = Math.max(map[i - 1].cash, map[i - 1].hold + prices[i] - fee)
          // 第i天hold 对比 前一天hold 和 假如今天买入股票剩余利润
          map[i].hold = Math.max(map[i - 1].hold, map[i - 1].cash - prices[i])
      }
      // 对比 持股时累计利润 和 未持股时累计利润
      return Math.max(map[prices.length - 1].cash, map[prices.length - 1].hold)
  }
  
  // 验证
  const prices = [1, 3, 2, 8, 4, 9]
  const fee = 2
  console.log(fn(prices, fee)) // 8
  ```


## 滑动窗口最大值

- 见`算法.md`下`滑动窗口最大值`

## 最长递增子序列

- 找到整数数组中最长递增子序列的值

  ```js
  // 思路
  // 因为是记录不一定连续的递增子序列 因此依赖于之前递增子序列长度
  // 来得到起始位置到当前位置所构成的子序列长度
  // 并记录最大长度 以此判断是否更新 最长子序列末尾索引
  // 通过构建类似KMP next数组 记录子序列每个数的前一位索引
  // 最后通过该索引数组 找到符合的子序列
  
  function fn(nums) {
      if (nums.length < 2) return []
      // 记录历史长度 子序列最少为1个数 所以最小长度为1
      // 初始值先全部填充成1
      let max_lengths = new Array(nums.length).fill(1)
      // 记录nums每个位置的最长递增子序列的前一个元素的索引
      // 初始值-1用来作判断条件 不能用0 因为0位置的元素也可能在子序列中
      let pre_indexs = new Array(nums.length).fill(-1)
  
      let max = 1 // 记录nums最大子序列长度 最小为1
      let end_index // 最长子序列末尾索引
  
      // 子序列最小长度是1 从nums第二个元素开始遍历
      for (let fast = 1; fast < nums.length; fast++) {
          // 外层循环每移动到一个新位置 相当于从0到fast的滑动窗口
          // 里层遍历滑动窗口内元素 找到最大递增子序列长度
          // 并记录fast位置 构成的子序列 前一个数的索引位置
          // 只遍历到fast前一个位置 因为fast不需要跟自己作比较
          for (let slow = 0; slow < fast; slow++) {
              if (nums[slow] < nums[fast]) {
                  // slow位置的数小于fast时
                  // 说明新加入的fast使得0~slow子序列长度+1
                  // 因此在max_lengths[slow]的基础上+1 得到新值
                  // 然后比较max_lengths[fast]当前值 和 新值 得到0~fast区间最大子序列长度
                  max_lengths[fast] = Math.max(max_lengths[slow] + 1, max_lengths[fast])
                  // 并记录以fast为末尾的子序列 其前一个数位置
                  pre_indexs[fast] = slow
              }
          }
          // 更新最大子序列长度
          if (max_lengths[fast] > max) {
              max = max_lengths[fast]
              // 注意区分 0~fast区间的最长子序列 和 nums的最长子序列
              // for循环中是以加入fast为前提 是否会增加子序列长度
              // 如果增加 说明0~fast区间的最长子序列 就是以fast为末尾
              // 而nums的最长子序列 末尾元素索引 不一定是nums末尾元素
              end_index = fast
          }
      }
      let result = []
      // 根据pre_indexs 从后往前找最长子序列
      while (end_index !== -1) {
          result.unshift(nums[end_index])
          // 移动end_index
          end_index = pre_indexs[end_index] // 是不是很像KMP的next数组？
      }
      return result
  }
  
  // 验证  
  const nums = [10, 9, 2, 5, 3, 7, 101, 18];
  console.log(`最长子序列:` + fn(nums)); // [2,3,7,101]
  ```

## 手写Object.create

- `Object.create`用于创建一个新对象，并将其原型对象设置为传入的对象

  ```js
  function fn(obj) {
      function F(){}
      F.prototype = obj
      return new F()
  }
  ```

## 手写instanceof

- `instanceof`用于判断构造函数`prototype`属性==是否出现在对象的原型链中的任何位置==

  - `Object.getPrototypeof`：标准方法，用于获取对象的原型对象
  - `obj.__proto__`：非标准方法，不被Web标准认可，可能会有兼容性问题

  ```js
  function fn(left, right) {
      let p = Object.getPrototypeof(left) // 获取目标原型
      // right传入的是构造函数 所以可以用这个属性直接取原型
      let target = right.prototype
      // 沿着原型链 移动p的指向
      while(true) {
          if(!p) return false // 找到原型链末端都没找到 返回false
          if(p == target) return true
          p = Object.getPrototypeof(p) // 没找到 继续移动指针
      }
  }
  ```


## 手写类型判断函数

- 经测试无法返回自定义类的类型

  ```js
  function getType(value) {
      // null会被typeof判断为object 先过滤
      if(value === null) return 'null'
      let type = typeof value
      if(type === 'object') {
          // 对象则先用Object原型方法将对象转换成字符串[object xxx]
          let str = Object.prototype.toString.call(value)
          // 将[object xxx]中的xxx取出
          type = str.split(' ')[1].split(']')[0]
          return type.toLowerCase() // 换成小写
      } else {
          return type // 基本类型直接返回
      }
  }
  ```

## 手写call、apply、bind函数

```js
// call
Function.prototype.call = function(obj, ...params) {
    // 先判断call调用者是不是函数
    if(typeof this !== 'function') throw 'type error'
    // 如果没传入obj则默认window
    obj = obj || window
    // 添加临时属性 复制 调用call的函数
    obj.fn = this // this为call的调用者 也就是函数
    // 使用复制的函数体执行 返回结果
    let result = obj.fn(...params)
    // 将添加的临时属性删除
    delete obj.fn
    return result
}

// apply
Function.prototype.apply = function(obj, params) {
    // 注意 call和apply接收参数区别
    if(typeof this !== 'function') throw 'type error'
    obj = obj || window
    obj.fn = this
    let result = obj.fn(...params)
    delete obj.fn
    return result
}

// bind 返回一个函数 而不是立即执行
Function.prototype.bind = function(obj, ...params) {// 注意 bind传参数像call
    if(typeof this !== 'function') throw 'type error'
    obj = obj || window
    // 保存调用bind的函数
    let fn = this
    // 注意 这里不再是添加临时属性执行 而是返回函数
    // 且返回的不能是匿名函数 因为要判断返回的函数是否被用作构造函数这种特殊情况
    return function Fn(...params2) {// bind返回函数 可传入多个参数
        // 返回的函数被执行时 返回 保存的函数执行结果
        // 判断Fn是否被用作构造函数
        let context = obj instanceof Fn? this : obj // this指向Fn的实例对象
        // 传入Fn的参数 与 xxx.bind时传入的参数合并
        let args = [...params, ...params2]
        return fn.apply(context, args) // Fn执行时 调用apply返回结果
    }
}
```

## 日期格式化函数

- 本质是替换格式中固定字符串

  ```js
  function fn(date, text) {
    let year = date.getFullYear()
    let month = date.getMonth() + 1
    let day = date.getDate()
    text = text.replace(/yy/, year)
    text = text.replace(/mm/, month)
    text = text.replace(/dd/, day)
    return text
  }
  fn(new Date('2020-12-01'), 'yy/mm/dd') // 2020/12/01
  fn(new Date('2020-04-01'), 'yy年mm月dd日') // 2020年04月01日
  ```


## 数组乱序输出

```js
function fn(list) {
    // i > 0 因为 i = 0时 随机数只能为0
    for (let i = list.length - 1; i > 0; i--) {
        // 随机索引 随机数为[0, i) 因为要排除当前交换的索引
        let randomIndex = Math.floor(Math.random() * i)
        let t = list[randomIndex]
        list[randomIndex] = list[i]
        list[i] = t
    }
}

// 验证
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
fn(arr)
console.log(arr) // [3, 9, 2, 10, 1, 4, 8, 5, 6, 7]
```

## 字符串repeat方法

- 将一个字符串重复n次

  ```js
  function fn(str, n) {
      // new Array会创建 长度为n 元素为undefined数组
      // 因为用join拼接 undefined/null元素会被删除 只保留连接点字符串
      // 因此创建的空数组长度为n+1 如(new Array(2)).join('abc') 为'abc'
      let t = new Array(n + 1)
      return t.join(str)
  }
  ```

## 非负大整数相加

```js
// 思路
// 将大整数字符串 分割位数组 循环取最后一位
// 转换成数字相加 然后对10取余 保留个位数字 并拼接之前位数的字符串
// 每次循环判断是否需要往前进一位

function fn(a, b) {
    let result = '' // 存储大数字相加结果
    let 进位 = 0 // 是否往前进一位
    // 将大数字字符串 转换成数组
    a = a.split('')
    b = b.split('')
    // 只要a/b数组不为空 或 仍需要进位 就一直循环
    while (a.length || b.length || 进位) {
        // 每次循环从a b数组末尾取一位数字
        let a_str = a.pop() || 0 // 已经为空的数组 数字为0
        let b_str = b.pop() || 0
        // 当前位的数字相加后 再加上进位(0或1)
        let sum = Number(a_str) + Number(b_str) + 进位
        // 当前位总和对10取余 即为当前位实际值 再拼接result字符串
        result = (sum % 10) + result
        // sum大于9则需要往前进一位
        进位 = sum > 9 ? 1 : 0
    }
    return result
}

// 验证
let a = '123456789'
let b = '12'
console.log(fn(a, b)) // '123456801'
```

## 解析URL params参数

- 规则

  - 没有值的默认为`true`
  - 中文进行解码
  - 重复的`key`组装成数组

  ```js
  let url = 'http://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled'
  function fn(url) {
      // exec得到[0:..., 1:..., groups:...]
      let str = /.+\?(.+)$/.exec(url)[1] // 取得?后的字符串
      // 分割成数组
      let arr = str.split('&')
      let result = {}
      for (let val of arr) {
          if (/=/.test(val)) {
              // 解构赋值 取出key 和 value
              let [key, value] = val.split('=')
              // 所有value先经过解码 decodeURIComponent不会改变除中文编码以外的值
              value = decodeURIComponent(value)
              // 判断是否为纯数字 是数字则转换成number类型
              value = /^\d+$/.test(value) ? parseFloat(value) : value
              if (result.hasOwnProperty(key)) {
                  // result中已经有对应key 则转换成数组
                  // 注意 concat会把传入的数组展开
                  // 因此传入result[key] 无论是否已经是数组
                  // 都会结合新value 给result[key]赋一个新数组值
                  result[key] = [].concat(result[key], value)
              } else {
                  // 没有重复的 存为键值对
                  result[key] = value
              }
          } else {
              // 没有=号 默认为true
              result[val] = true
          }
      }
  }
  ```

## 小孩报数问题

- 编号从1-30，围成一圈依此报数1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩重新报数，问最后剩下的那个小孩儿的编号是多少

  ```js
  // 思路
  // 创建一个队列 装入所有编号
  // 创建循环 每次循环将前count-1个元素放到队列末尾
  // 再从队列头部弹出一个元素 直到队列只剩1个元素 该元素就是淘汰后的结果
  
  function fn(num, count) {
      let queue = [] // 队列
      // 先将所哟编号从头填入队列
      for (let i = 1; i <= num; i++) {
          queue.push(i)
      }
      // 直到队列剩下1个元素一直循环
      while (queue.length > 1) {
          // 将前count - 1个元素 按顺序弹出并填入队列末尾
          for (let i = 1; i < count; i++) {
              queue.push(queue.shift())
          }
          // 再弹出头部元素 作为被淘汰的
          queue.shift()
      }
      // 只剩一个元素 就是结果值
      return queue[0]
  }
  
  // 验证
  console.log(fn(30, 3)) // 29
  ```


## 图片异步加载

- 本质是用promise包裹图片加载进程

  ```js
  function load(url) {
      return new Promise((resolve, reject) => {
          let img = new Image()
          img.src = url
          img.onload = () => {
              resolve(img)
          }
          img.onerror = (err) => {
              reject(err)
          }
      })
  }
  load('url')
      .then((img) => {
          document.querySelector('xxx').appendChild(img)
      })
      .catch((err) => { })
  ```

  
