## webpack配置有哪些

- `entry`：指定打包入口文件
  - 可以是单个或多个JavaScript文件
  - 决定了`webpack`==从哪个**模块**开始生成**依赖关系图**==
- `output`：打包生成的文件名和目录位置
- `module`：配置`loader`处理模块
  - 如：打包css文件的`css-loader`
- `plugin`：增强功能
  - 如：`html-webpack-plugin`可以将打包后的js文件自动引用到HTML文件中
- `devServer`：web服务器和热重载功能

## 有哪些常见的loader和plugin

- `loader`
  - `babel-loader`：ES6代码转换成ES5
  - `css-loader`：解析css文件，处理依赖关系
  - `less-loader`：将Less文件编译成css
  - `vue-loader`：将`.vue`文件编译成`js`代码
- `plugin`
  - `HtmlWebpackPlugin`生成HTML文件，将打包后的js和css文件引入其中
  - `ExtractTextWebpackPlugin`：将CSS代码提取到单独的CSS文件中
  - `UglifyJsWebpackPlugin`：压缩JavaScript代码
  - `HotModuleReplacementPlugin`：热模块替换，用于在开发环境下实现热更新

## loader和plugin区别

- 功能不同
  - `loader`本质是个==函数==，webpack只能解析原生js文件，其他类型文件就需要loade进行转换
  - `plugin`是插件，用于增强webpack功能，在webpack生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 改变输出结果
- 用法不同
  - `loader`的配置是在`module.rules`下进行。类型为数组，每⼀项都是⼀个对象，其中描述了对于什么类型的⽂件，使⽤什么加载(`loader`)和使⽤的参数(` options `)
  - `plugin`配置在plugins下，类型为数组，每一项是一个实例(`new xxx()`)，参数都通过构造函数传入

## webpack构建流程

- 流程
  1. 初始化。解析`webpack.config.js`文件配置参数
  2. 编译。根据配置，注册所有插件，插件监听Webpack生命周期的事件节点，做出相应反应
  3. 构建抽象语法树。从`entry`配置，开始解析文件构建AST语法树，递归找出依赖，形成抽象语法树来描述依赖关系
  4. 编译模块。第3步递归过程中，根据`loader`配置，调用函数解析js外的文件
  5. 完成编译。经过3、4步得到每个文件内容及之间的依赖关系
  6. 输出进程。根据入口文件和依赖关系，组装成包含多个模块的`chunk`，再把每个`chunk`转换成单独的文件，加入到输出列表，==这步是可以修改输出内容的最后机会==
  7. 输出打包文件。定好输出内容后，根据`webpack.config.js`配置在对应路径生成对应文件

- 这个过程是串行的，就是将各个插件串联起来，一个插件的输出作为另一插件的输入

## 什么是webpack热更新

- 定义：不刷新页面的前提下，用新代码替换旧代码
- 原理
  - 首先是根据依赖关系图，找到改动的文件，将其替换，而不是重新对整体进行编译
  - 同时还创建一个本地服务器，本地资源发生变化后，会将有改动的模块重新打包放到内存中，然后向服务端推送更新，并附带上hash值，让客户端与上一次资源进行对比

## 什么是代码分割

- `code splitting`是一种优化技术，通过将一个大的`chunk`拆成多个小的`chunk`，实现按需加载，减少加载时间
- 在Webpack中通过`optimization.splitChunks`配置项来开启代码分割

## 什么是source map

- `source map`是一种文件，建立了编译后的代码与源代码之间的映射关系
- 通常用在开发阶段，Webpack中通过`devtool: 'source-map'`开启

## tree shaking原理

- 本质是利用ES6`import`模块静态结构特性
  - `import`引入文件路径是静态的
- 过程
  1. webpack分析代码时，会标记出所有`import`和`export`语句
  2. 当webpack确定某个js模块没有被引用时，会在打包编译中排除这个模块代码

- 配置文件中添加

  - 确保使用的是ES6模块语法(即import和export)，只有这样才能让Tree Shaking发挥作用

  ```json
  {
      // ...
      optimization: {
          usedExports: true,
          concatenateModules: true,
          minimize: true,
      }
  }
  ```

## 如何优化构建速度

- 使用==多线程==，如`thread-loader`
  - 但仅限于特别耗时的，否则还不如直接构建速度快
- 使用==热更新==插件
  - `DllPlugin`
    - 可以将第三方库预先打包成单独的文件，减少构建时间
  - `HardSourceWebpackPlugin`
    - 可以缓存中间文件，加速后续构建过程

- 使用`oneof`，这样在匹配到第一个符合的规则时就会停止遍历
- 缩小打包范围，使用`exclude/include`排除如`node_module`这样的包

- 利用缓存`cache`，只对修改的文件进行检查，构建速度会有提升
- 使用`babel`插件，因为`babel`编译时会为每个文件添加辅助代码，而这个插件可以使辅助代码作为独立模块==引入==

## 如何减少打包体积

- 使用`code split`，因为打包时会将所有JS文件打包成一个，用`code split`可以将其分割成多个JS文件，并按需引入
- 使用`Tree shaking`，去除无用的JS文件，不过是webpack默认开启的
- 提取公共资源，放在项目文件夹外，不用打包
- 压缩代码

## babel编译过程

- babel会将代码转换为字符串，再编译生成抽象语法树，然后对AST转变为新的代码

## vite比webpack快在哪里

- 开发模式的差异
  - Webpack是==先打包再启动开发服务器==，增加启动时间，而Vite则是==直接启动，再按需编译文件==
    - 按需编译指，html中`<script>`加载js模块时，再进行编译