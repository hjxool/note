## axios

### 简化版

- [get请求]()：

  ```js
  axios.get(url,{
    params:{			发送后		url?id=xxx&type=xxx2 params参数会以地址栏后拼接的形式
        id:'xxx',
        type:'xxx2'
    },
    headers:{},
    // 可以添加监听事件作为配置项
    onUploadProgress:function (progressEvent){//上传进度事件}
    onDownloadProgress:function (progressEvent){//下载进度事件}
  })
  .then(res=>{})
  ```


- [post请求]()：
  - `axios.post(url, {传送数据},{ params:{},headers:{} }).then(res=>{})`
- put请求同post
- 当请求IP端口等一致时，可以用`axios.defaults.baseURL = 'http://192.168.30.200'`，之后axios发送的请求前面都会拼接同样的IP地址段
- axios发送的请求体都是以JSON字符串形式发送

### 完整写法

- [get请求]()：

```js
axios({
	method:'get',
	url:''
}).then(res=>{})
```
- [post及put请求]()：

```js
axios({
	method:'post',
	url:'',
    data:{}
}).then(res=>{})
```

## fetch(无需引入原生方法)

- 与ajax及axios的区别

  - 收到代表错误的状态码时，==fetch()==返回的==promise==**不会被标记为reject**，而是标记为==resolve==，并依靠==ok属性==标识请求错误还是正常，**仅当**网络异常才会标记为reject
  - 不会发送跨域cookie
  - axios里的data配置项变为==body==
  - 返回的数据**并不是**直接能用的数据，需要将返回的数据用==json( )==方法转换为axios中常用的数据格式，**然后**再用==.then==接收处理后的数据

- 使用方式

  ```js
  fetch(url,{
      method:'post/put/get',
      body:(必须是字符串)`user=${user.value}&pas=${pas.value}`
      	或者
      	JSON.stringify(data)
      (post/put时)headers:{
      	'Content-Type':'application/json'
  	}
  }).then( res => { res.json()/text()/blob()/formData()/arrayBuffer() } )
    .then( res => {
      console.log(res)
  } )
  ```

  - ==第一次==返回的response有五种处理方法（==只能用一个==）

    - json( )最常用，得到解析过的json对象
    - text( ) - 得到字符串
    - blob( ) - 二进制blob对象
    - formData( ) - 表单对象
    - arrayBuffer( ) - 二进制arrayBuffer对象

## 跨域

- 所谓同源，即协议(http/https)、域名(IP地址)、端口号(8080等)相同，这是浏览器的安全策略

  - 跨域则是同源条件不满足

- 解决跨域的方法

  - JSNOP(==只支持Get请求==)：利用img、script、link、iframe==标签==的跨域能力

    - 如，`<script src="https://..." crossorigin="anonymous">`

    - ==crossorigin==属性可选值：anonymous(匿名)、use-credentials(使用凭证)

    - **但是**使用标签跨域访问接收的必须是==JS代码==，因为标签无法识别字符串，不会处理返回结果

      ```js
      app.all('./jsonp-server',(request,response)=>{
          let data = {
              name:'xxx'
          }
          let str = JSON.stringify(data)
          response.send(`handle(${str})`) handle是网页中的**全局**方法
      })
      HTML页面
      input.onblur = function (){
          let username = this.value
          let s = document.createElement('script')
          s.src = 'http://...'
          document.body.appendChild(s)
      }
      ```

  - ==CORS==响应头方法，需要在后端设置

    ```js
    app.all('./server',(request,response)=>{
        response.setHeader('Access-Control-Allow-Origin','*')
        ...
    })
    ```
