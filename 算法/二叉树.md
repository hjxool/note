# 二叉树种类

## 满二叉树

- 定义：所有节点要么没有子节点，要么只有两个子节点
- 满二叉树节点个数：`2^k - 1`
  - `k`为二叉树深度，从1开始

## 完全二叉树

- 除了底层==全满==，底层==从左到右节点是连续的==
- 满二叉树也是完全二叉树
- ==优先级队列(小顶堆/大顶堆)==就是完全二叉树

## 二叉搜索树

- 左子树的节点**的值**都小于中间节点**的值**，右子树的节点**值**都大于中间节点**值**
  - 简单来说就是所有节点都符合==左边小于中间，右边大于中间==
  - 注意：搜索树是有值的大小区分
- 搜索时间复杂度：`log(n)`

## 平衡二叉搜索树

- 空树或左右子树高度差的绝对值不超过**1**
  - 注意：所有子树都要符合这个规则。如左子树的左右子树高度差也不能超过1

# 二叉树存储方式

## 链式存储

- 用==左右指针==指向下一个节点
  - 本质是==链表==

## 线性存储

- 用数组存，从根节点往下一层一层存，每层从左到右
- 索引关系
  - `左子节点索引 = 2 * 父节点索引 + 1`
  - `右子节点索引 = 2 * 父节点索引 + 2`
  - `父节点索引 = (左子节点索引 - 1) / 2`
  - `父节点索引 = (右子节点索引 - 2) / 2`

# 二叉树的遍历方式

## 深度优先遍历

- 定义：先往深走，遇到叶子节点再往回走
- 属于深度优先搜索的方法
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 前/中/后序遍历其实取决于中间节点的顺序
  - 前序遍历：中左右
  - 中序遍历：左中右
  - 后序遍历：左右中
  - 注意：这里的左和右表示左/右子树
  - 个人理解：为什么前/中/后由中间节点的位置来决定？因为左和右都表示**子树**，而不是**节点**，只有==中表示节点本身==，才可以添加其值到结果数组中，对应到代码中就是`result.push(中间节点.value)`，而左和右都是`递归方法(中间节点.left)`和`递归方法(中间节点.right)`

## 广度优先遍历

- 定义：==一层一层==遍历
- 属于广度优先搜索的方法
  - 层次遍历（迭代法）

# 二叉树的递归遍历

- 递归本质是就是==压栈==，每次调用都将该步操作压栈，`return`就是出栈，所以最关键的就是==确定终止条件==，至于递归本身的处理代码靠经验

- 递归算法三要素

  1. 确定递归终止条件
  2. 确定递归函数的参数和返回值
  3. 确定单层重复执行的逻辑

- 前/中/后序遍历就是换`result.push(node.value)`的位置

  ```js
  let result = []
  // 前序遍历
  function pre(node){
      // 确定终止条件
      if(node === null){
          // 确定递归函数出口返回值
          return
      }
      // 确定重复执行逻辑
      result.push(node.value) // 中
      // 确定递归函数参数
      pre(node.left) // 左
      pre(node.right) // 右
  }
  ```

# 二叉树的迭代遍历

- 递归本质是压栈、出栈的过程，因此用迭代`while`循环实现同样的结果，就是在模拟压、出栈的行为

  - 但是因为迭代法是每次循环中都执行完才进行下次循环，所以与递归逻辑不同，递归可以在一次调用中不停的往下递归，再==自动==出栈执行一开始外层的后续操作，而迭代就得考虑如何在一次循环中把事情做完，且不影响后续循环操作
  - 简单来说，就是递归不用考虑出栈的问题，而迭代需要在每次循环及时出栈，并配合出栈执行相应的操作

- ==前/后==序遍历都可以用==中==在前的形式得到结果数组 但是中序不行，因为访问节点(遍历节点)与处理节点(将元素放进结果集)不一致

  ```js
  // 前序遍历
  function pre(root){
      let result = []
      let stack = [] // 模拟行为用的栈
      // 前序遍历 中在前 所以一开始就将根节点入栈
      stack.push(root)
      // 栈不为空就一直循环
      while(stack.length){
          // 中节点在栈顶 出栈 并将其装入结果数组
          let node = stack.pop()
          result.push(node.value)
          // 再将左右子节点压栈
          // 注意 因为栈是先进后出 所以先压栈右节点 这样出来的顺序才是先左后右
          if(node.right){
              // 空节点不入栈
              stack.push(node.right)
          }
          if(node.left){
              stack.push(node.left)
          }
      }
  }
  
  // 后序遍历
  function last(root){
      let result = []
      let stack = []
      // 后序遍历与前序遍历基本上是相反的
      // 所以就可以用前序遍历的模板 得到结果数组 然后再对数组反转
      stack,push(root)
      while(stack.length){
          let node = stack.pop()
          result.push(node.value)
          // 注意 虽然是以前序遍历的执行逻辑为模板 但是后序遍历是左右中
          // 反转数组是中右左 所以进栈时要左先入栈 右才能先出栈
          if(node.left){
              // 注意此处和前序遍历的区别
              stack.push(node.left)
          }
          if(node.right){
              stack.push(node.right)
          }
      }
      // 得到结果数组 中右左 将其反转得到后序遍历结果
      result.reverse()
  }
  
  // 中序遍历
  function mid(root){
      let result = []
      let stack = []
      // 中序遍历有所不同 因为结果数组无法先填入中节点
    	// 得先遍历左子树
      // 因此需要用一个指针遍历
      let curNode = root
      // 指针不为空 或 栈不为空就继续遍历
      while(curNode !== null || stack.length){
          // 中序遍历是先遍历左子树 左子树为空则回退到中节点
          // 将中节点放入结果数组 再遍历右子树
          if(curNode){
              // 当前节点不为空 放入栈中
              stack.push(curNode)
              // 接着遍历左子树
              curNode = curNode.left
          }else{
              // 当前节点为空 但栈不为空
              // 出栈 得到中节点(要处理的数据)
              curNode = stack.pop()
              // 将其填入结果数组
              result.push(curNode.value)
              // 继续遍历右子树
              curNode = curNode.right
          }
      }
  }
  ```

# 二叉树的统一迭代法

```js
// 统一迭代法的思路
// 每次循环 先出栈 并保留出栈的元素
// 如果遇到非空节点 说明遇到了左或右节点 需要继续遍历 就按顺序将其与左右子节点入栈(如果存在的话)
// 并在中节点入栈后在其前面再填一个 null 作为标记 这就是标记法
// 如果出栈为 null 说明回退到了中节点(注意栈中已经排列好顺序了)
// 那么就再次出栈 将中节点填入结果数组

class Node {
	constructor(value, left, right) {
		this.value = value;
		this.left = left;
		this.right = right;
	}
}

let n1 = new Node(1, null, null);
let n2 = new Node(2, null, null);
let n4 = new Node(4, n1, n2);
let n6 = new Node(6, null, null);
let root = new Node(5, n4, n6);

// 前序遍历
function pre(root) {
	let result = []; // 结果数组
	let stack = []; // 模拟栈
	// 先将根节点入栈
	// 注：虽然根节点也是中节点 但是特殊处理 没有在入栈时像后面的中节点一样添加null标识
	// 这是为了能进入循环时遍历左右子树
	stack.push(root);
	// 栈不为空就一直循环
	while (stack.length) {
		// 先出栈 并保存出栈元素
		let cur = stack.pop();
		if (cur) {
			// 当前出栈的元素不为空
			// 说明需要继续遍历左右子树
			// 前序遍历 中左右 入栈顺序右左中
			if (cur.right) {
				// 右
				stack.push(cur.right);
			}
			if (cur.left) {
				// 左
				stack.push(cur.left);
			}
			stack.push(cur); // 中
			// 注意 这里还要添加一个null标识中节点
			stack.push(null);
		} else {
			// 出栈元素为null
			// 说明下一个出栈元素是中节点 要填入结果数组
			let mid = stack.pop();
			result.push(mid.value);
		}
	}

	return result;
}

// 验证
console.log('前序遍历：' + pre(root)); // [5,4,1,2,6]

// 中序遍历
function mid(root) {
	let result = [];
	let stack = [];
	stack.push(root);

	while (stack.length) {
		let cur = stack.pop();
		if (cur) {
			// 中序遍历 左中右 入栈顺序 右中左
			if (cur.right) {
				// 右
				stack.push(cur.right);
			}
			// 中
			stack.push(cur);
			stack.push(null);
			if (cur.left) {
				// 左
				stack.push(cur.left);
			}
		} else {
			let mid = stack.pop();
			result.push(mid.value);
		}
	}

	return result;
}

// 验证
console.log('中序遍历：' + mid(root)); // [1,4,2,5,6]

// 后序遍历
function last(root) {
	let result = [];
	let stack = [];
	stack.push(root);

	while (stack.length) {
		let cur = stack.pop();
		if (cur) {
			// 后序遍历 左右中 入栈顺序 中右左
			// 中
			stack.push(cur);
			stack.push(null);
			if (cur.right) {
				// 右
				stack.push(cur.right);
			}
			if (cur.left) {
				// 左
				stack.push(cur.left);
			}
		} else {
			let mid = stack.pop();
			result.push(mid.value);
		}
	}

	return result;
}

// 验证
console.log('后序遍历：' + last(root)); // [1,2,4,6,5]
```

# 二叉树的层序遍历

- [力扣102](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

  ```js
  // 思路
  // 层序遍历 用一个队列存每层的节点
  // 外层循环一开始先记录队列中本层节点数 即出队列数
  // 然后小循环挨个出队列 并将本层节点的子节点填入队列
  // 小循环结束 队列中存的就是下一层节点
  
  class Node {
      constructor(value, left, right) {
          this.value = value
          this.left = left
          this.right = right
      }
  }
  let n1 = new Node(1, null, null);
  let n2 = new Node(2, null, null);
  let n4 = new Node(4, n1, n2);
  let n6 = new Node(6, null, null);
  let root = new Node(5, n4, n6);
  
  function layer(root) {
      let result = []
      let queue = []
      queue.push(root)
      while (queue.length) {
          // 记录当前层节点数
          let size = queue.length
          // 用一个数组记录本层节点
          // 并遍历将下一层节点添加到队列
          let curLayer = []
          while (size--) {
              // 将队列头部节点出列
              let node = queue.shift()
              // 将其装入本层数组
              curLayer.push(node.value)
              // 将其子节点装入队列
              // 注：这里就体现为什么要提前记录队列长度
              // 因为队列长度会变化 所以一开始要记录本层需要出列的数量
              if (node.left) {
                  queue.push(node.left)
              }
              if (node.right) {
                  queue.push(node.right)
              }
          }
          // 循环结束 将本层数组装入结果数组
          result.push(curLayer)
      }
      return result
  }
  
  // 验证
  console.log('层序遍历', layer(root)) // [[5], [4, 6], [1, 2]]
  ```

## 反向排列的层序遍历

- [力扣107](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/)

  ```js
  // 思路
  // 依旧从上往下层序遍历 只不过将每层数组从头部插入结果数组
  
  class Node {
  	constructor(value, left, right) {
  		this.value = value;
  		this.left = left;
  		this.right = right;
  	}
  }
  
  let n7 = new Node(7, null, null);
  let n15 = new Node(15, null, null);
  let n20 = new Node(20, n15, n7);
  let n9 = new Node(9, null, null);
  let root = new Node(3, n9, n20);
  
  function layer2(root){
      let result = [] // 记录每层结果
      let queue = [] // 辅助数据结构队列
      queue.push(root) // 初始装入根节点
  
      while(queue.length){
          // 记录本层节点数
          let size = queue.length
          // 记录本层节点值的数组
          let curLayer = []
          while(size--){
              // 根据初始队列长度弹出节点
              let node = queue.shift()
              // 将其值装入数组
              curLayer.push(node.value)
              // 将其子节点填入队列
              if(node.left){
                  queue.push(node.left)
              }
              if(node.right){
                  queue.push(node.right)
              }
          }
          // 从头部插入结果数组 避免还要倒序排列
          result.unshift(curLayer)
      }
  
      return result
  }
  
  // 验证
  console.log('反向层序遍历', layer2(root)) // [[15, 7], [9, 20], [3]]
  ```

## 二叉树的右视图

- 本题层序遍历是最优解，因为不是单纯遍历右子树节点，而是取每层最后一个节点

- [力扣199](https://leetcode.cn/problems/binary-tree-right-side-view/description/)

  ```js
  // 思路
  // 层序遍历时 只存每层最后一个节点
  
  class Node {
      constructor(value, left, right) {
          this.value = value;
          this.left = left;
          this.right = right;
      }
  }
  
  let n1 = new Node(1, null, null);
  let n2 = new Node(2, null, null);
  let n4 = new Node(4, n1, n2);
  let n6 = new Node(6, null, null);
  let root = new Node(5, n4, n6);
  
  function fn(root) {
      let result = []
      let queue = []
      queue.push(root)
  
      while (queue.length) {
          let size = queue.length
  
          let lastNode
          while (size--) {
              let node = queue.shift()
              if (!size) {
                  // 本层最后一个节点 进行保存
                  lastNode = node.value
              }
              // 将本层的子节点装入队列
              if (node.left) {
                  queue.push(node.left)
              }
              if (node.right) {
                  queue.push(node.right)
              }
          }
          result.push(lastNode)
      }
      return result
  }
  
  // 验证
  console.log('二叉树右视图：' + fn(root)) // [5, 6, 2]
  ```

## 二叉树的层平均值

- [力扣637](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/)

  ```js
  // 思路
  // 层序遍历 每层记录值并求均值
  
  class Node {
      constructor(value, left, right) {
          this.value = value;
          this.left = left;
          this.right = right;
      }
  }
  
  let n1 = new Node(1, null, null);
  let n2 = new Node(2, null, null);
  let n4 = new Node(4, n1, n2);
  let n6 = new Node(6, null, null);
  let root = new Node(5, n4, n6);
  
  function fn(root) {
      let result = []
      let queue = []
      queue.push(root)
  
      while (queue.length) {
          // 记录当前层节点个数
          let size = queue.length
          // count为循环用变量
          let count = size
          // 记录每层节点值总和
          let sum = 0
          while (count--) {
              let node = queue.shift()
              sum += node.value
              // JS中&&符 是找false 找到就不再进行后面的运算
              node.left && queue.push(node.left)
              node.right && queue.push(node.right)
          }
          // 循环结束 求均值
          result.push(sum / size)
      }
      return result
  }
  
  // 验证
  console.log('二叉树每层平均值：' + fn(root)) // [5, 5, 1.5]
  ```


## N叉树的层序遍历

- [力扣429](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/)

  ```js
  // 思路
  // 依旧是层序遍历模板
  // 区别在于不再是只取二叉树左右子节点 而是遍历子节点列表
  
  class Node {
      constructor(value, child) {
          this.value = value;
          this.child = child;
      }
  }
  
  let n1 = new Node(1, []);
  let n2 = new Node(2, []);
  let n4 = new Node(4, [n1, n2]);
  let n6 = new Node(6, []);
  let root = new Node(5, [n4, n6]);
  
  function fn(root) {
      let result = []
      let queue = []
      queue.push(root)
  
      while (queue.length) {
          let size = queue.length
  
          let curLayer = []
          while (size--) {
              let node = queue.shift()
              curLayer.push(node.value)
  
              // 将当前节点的子节点取出
              for (let item of node.child) {
                  item && queue.push(item)
              }
          }
          result.push(curLayer)
      }
      return result
  }
  
  // 验证
  console.log('N叉树的层序遍历', fn(root)) // [[5], [4, 6], [1, 2]]
  ```

## 在每个树行中找最大值

- [力扣515](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/)

  ```js
  // 思路
  // 层序遍历模板 取每一层最大值
  
  class Node {
      constructor(value, left, right) {
          this.value = value;
          this.left = left;
          this.right = right;
      }
  }
  
  let n9 = new Node(9, null, null);
  let n3_3 = new Node(3, null, null);
  let n5 = new Node(5, null, null);
  let n2 = new Node(2, null, n9);
  let n3 = new Node(3, n5, n3_3);
  let root = new Node(1, n3, n2);
  
  
  function fn(root) {
      let result = []
      let queue = []
      queue.push(root)
  
      while (queue.length) {
          let size = queue.length
          // 记录最大值
          let max
          while (size--) {
              let node = queue.shift()
              if (!max || node.value > max) {
                  // 如果max未赋值 或 节点值大于max 则记录
                  max = node.value
              }
              node.left && queue.push(node.left)
              node.right && queue.push(node.right)
          }
          // 本层 循环结束 将最大值装入结果数组
          result.push(max)
      }
  
      return result
  }
  
  // 验证
  console.log('每层最大值：' + fn(root)) // [1, 3, 9]
  ```

## 填充每个节点的下一个右侧节点指针

- [力扣116](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/)

  ```js
  // 思路
  // 层序遍历模板 只是要记录前一个节点 让其next指向当前节点
  
  class Node {
      constructor(value, left, right, next = null) {
          this.value = value;
          this.left = left;
          this.right = right;
          this.next = next
      }
  }
  
  let n4 = new Node(4, null, null)
  let n5 = new Node(5, null, null)
  let n6 = new Node(6, null, null)
  let n7 = new Node(7, null, null)
  let n2 = new Node(2, n4, n5)
  let n3 = new Node(3, n6, n7)
  let root = new Node(1, n2, n3)
  
  function fn(root) {
      // 不需要结果数组
      // let result = []
      let queue = []
      queue.push(root)
      
      while (queue.length) {
          let size = queue.length
          
          while(size--){
              // 先拿到当前节点
              let curNode = queue.shift()
              // 如果size大于0说明本层还有节点
              // 就将其连到下一个即将要出队列的节点
              if(size){
                  curNode.next = queue[0]
              }
  
              curNode.left && queue.push(curNode.left)
              curNode.right && queue.push(curNode.right)
          }
      }
      // return result
      return root
  }
  
  // 验证
  console.log('填充next', fn(root))
  ```


## 二叉树的最大深度

- [力扣104](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

  ```js
  // 思路
  // 层序遍历模板 只不过每遍历一层 记录下深度
  
  class Node {
      constructor(value, left, right) {
          this.value = value;
          this.left = left;
          this.right = right;
      }
  }
  
  let n1 = new Node(1, null, null);
  let n2 = new Node(2, null, null);
  let n4 = new Node(4, n1, n2);
  let n6 = new Node(6, null, null);
  let root = new Node(5, n4, n6);
  
  function fn(root) {
      let queue = []
      queue.push(root)
  
      let deep = 0
      while (queue.length) {
          let size = queue.length
          // 每层循环一开始先累加层数
          deep++
          while (size--) {
              let node = queue.shift()
              node.left && queue.push(node.left)
              node.right && queue.push(node.right)
          }
      }
      return deep
  }
  
  // 验证
  console.log('二叉树深度为：' + fn(root)) // 3
  ```

## 二叉树的最小深度

- [力扣111](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

  ```js
  // 思路
  // 层序遍历模板 找到 第一个 左右孩子都为空的节点 所在层 即为最小深度
  
  class Node {
      constructor(value, left, right) {
          this.value = value;
          this.left = left;
          this.right = right;
      }
  }
  
  let n1 = new Node(1, null, null);
  let n2 = new Node(2, null, null);
  let n4 = new Node(4, n1, n2);
  let n6 = new Node(6, null, null);
  let root = new Node(5, n4, n6);
  
  function fn(root) {
      let queue = []
      queue.push(root)
  
      let minDeep = 0
      while (queue.length) {
          let size = queue.length
          // 每层循环开始先累加最小层高
          minDeep++
          while (size--) {
              let node = queue.shift()
              // 找到第一个叶子节点 就不必往下遍历了 返回结果
              if (!node.left && !node.right) {
                  return minDeep
              }
              node.left && queue.push(node.left)
              node.right && queue.push(node.right)
          }
      }
  }
  
  // 验证
  console.log('二叉树最小深度:' + fn(root)) // 2
  ```

# 翻转二叉树

- [力扣226](https://leetcode.cn/problems/invert-binary-tree/description/)

  ```js
  // 思路
  // 递归 层序遍历 皆可实现 只是递归的 中序遍历 要注意左子树翻转后变成右子树
  // 因此 左中右 遍历右子树时 要改成遍历左子树
  
  function fn(node) {
      if (node == null) return
      // 前序遍历 中左右
      // 交换左右子树
      let t = node.right
      node.right = node.left
      node.left = t
      // 遍历子树
      fn(node.left)
      fn(node.right)
  
      // 后序遍历 左右中
      // fn(node.left)
      // fn(node.right)
      // let t = node.right
      // node.right = node.left
      // node.left = t
  
      // 中序遍历 左中右
      // fn(node.left)
      // let t = node.right
      // node.right = node.left
      // node.left = t
      // fn(node.left)
  
      return node
  }
  
  // 验证
  console.log('翻转结果', fn(root))
  ```

# 对称二叉树

- [力扣101](https://leetcode.cn/problems/symmetric-tree/description/)

# 完全二叉树的节点个数

- [力扣222](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

- 定义

  - 除了最底层节点，其他层节点全满，并且从左到右连续

- 完全二叉树只有两种情况

  - 一种是满二叉树，所有叶子节点全满
  - 一种是叶子节点没有全满

  ```js
  // 思路
  // 递归实现
  // 在递归遍历二叉树的基础上 将中间节点 记为1 逐层返回中间节点 加 左右子树节点数
  // 迭代实现
  // 累加 每层 节点数
  // 满二叉树特性实现
  // 满二叉树节点数 可以用公式 2^深度 - 1 计算得到
  // 可以通过判断子树左右两边层级是否相等 判断是否为满二叉树
  // 不是满二叉树的则递归像左右子树遍历 并累加中间节点数
  // 每递归一层 判断当前子树是否为满二叉树 是则根据公式直接返回当前子树节点数
  // 注 叶子节点也是满二叉树
  // 完全二叉树特性实现的有点在于 二叉树越大
  // 这种实现方式时间上的优势越明显 因为不用遍历满二叉树中间部分的节点
  
  class Node {
      constructor(value, left, right) {
          this.value = value;
          this.left = left;
          this.right = right;
      }
  }
  
  let n1 = new Node(1, null, null);
  let n2 = new Node(2, null, null);
  let n4 = new Node(4, n1, n2);
  let n6 = new Node(6, null, null);
  let root = new Node(5, n4, n6);
  
  // 递归实现 例 前序遍历
  function fn1(node) {
      // 递归出口 递归到末端向上返回
      if (node == null) return 0
      // 单层递归逻辑
      let 左子树节点个数 = fn1(node.left)
      let 右子树节点个数 = fn1(node.right)
      let 中间节点个数 = 1
      return 左子树节点个数 + 右子树节点个数 + 中间节点个数
  }
  
  // 验证
  console.log('递归实现', fn1(root)) // 5
  
  // 层序遍历 迭代 实现
  function fn2(root) {
      let result = 0
      let queue = [] // 辅助队列
      // 初始值 将根节点装入队列
      queue.push(root)
      while (queue.length) {
          // 记录初始队列
          let size = queue.length
          // 累加本层节点数
          result += size
          while (size--) {
              let node = queue.shift()
              node.left && queue.push(node.left)
              node.right && queue.push(node.right)
          }
      }
      return result
  }
  
  // 验证
  console.log('迭代实现', fn2(root)) // 5
  
  // 利用完全二叉树性质
  function fn3(node) {
      if (node === null) {
          // 递归出口1 空节点返回节点数0
          return 0
      }
      // 计数
      let 左节点数 = 0
      let 右节点数 = 0
      // 设置迭代指针
      let left = node.left
      // 有子节点计数+1
      while (left) {
          左节点数++
          // 向左遍历
          left = left.left
      }
      let right = node.right
      while (right) {
          右节点数++
          // 向右遍历
          right = right.right
      }
      // 之所以向左右遍历 是因为满二叉树特性 左右两边子节点铺满
      // 就可以用 2^深度 - 1 求得满二叉树节点个数
      if (左节点数 === 右节点数) {
          // 递归出口2 当前子树是满二叉树的情况
          // 左边 等于 右边 说明 是满二叉树 用公式计算当前满二叉树节点数
          // 注意 子树深度 + 1才是从当前节点开始的深度
          return Math.pow(2, 左节点数 + 1) - 1
      }
      // 当前子树不是满二叉树 则递归遍历左右子树 并加上中间节点数
      return fn3(node.left) + fn3(node.right) + 1
  }
  
  // 验证
  console.log('利用满二叉树特性', fn3(root)) // 5
  ```