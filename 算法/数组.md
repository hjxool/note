![img](https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)

# 二分法

## 二分查找

- [力扣704](https://leetcode.cn/problems/binary-search/description/)

  ```js
  // 时间复杂度：O(log n)
  // 空间复杂度：O(1)
  
  // 方式1 左闭右闭区间
  function fn1(list, target) {
      let left = 0 // 左闭[0, right)
      let right = list.length - 1 // 右闭[left, length-1]
      // 左右能够相等就是 左闭右闭
      while (left <= right) {
          // 每次循环计算中间位置索引和值
          // >> 是将值转换为10后向右移动 1位
          // 相当于Math.floor((right - left) / 2)
          let mid = left + ((right - left) >> 1)
          if (list[mid] > target) {
              // 区间内中间值比目标值大
              // 则缩小右区间(最大值)
              // 又因为是右闭合 且已知mid≠target 所以mid值可以排除
              // 因此右区间等于mid - 1 向内缩一格
              right = mid - 1
          } else if (list[mid] < target) {
              // 中间值比目标值小
              // 则加大左区间(最小值)
              // 又因为是左闭合 且已知mid≠target 所以mid值可以排除
              // 因此左区间等于mid + 1 向内缩一格
              left = mid + 1
          } else {
              // 中间值等于目标值 找到 直接返回
              return mid
          }
      }
      // 循环结束 都没有找到
      return -1
  }
  
  // 验证
  console.log(fn1([1, 2, 3, 4], 3)) // 2
  
  // 方式2 左闭右开区间
  function fn2(list, target) {
      let left = 0 // 依旧是左闭 同方法1
      let right = list.length // 右开[left, length)
      // 因为右边是开区间 所以左右必不可能相等
      while (left < right) {
          let mid = left + ((right - left) >> 1)
          if (list[mid] > target) {
              // 中间值比目标值大 则缩小最大值
              // 又因为右是开区间 所以不可能等于最大值
              // 因此不需要-1
              right = mid
          } else if (list[mid] < target) {
              // 同方法1
              left = mid + 1
          } else {
              return mid
          }
      }
      // 没有找到返回-1
      return -1
  }
  
  // 验证
  console.log(fn2([1, 6, 22, 44, 78], 22)) // 2
  ```


## 搜索插入位置

- [力扣35](https://leetcode.cn/problems/search-insert-position/description/)

  ```js
  // 时间复杂度：O(log n)
  // 空间复杂度：O(1)
  
  // 搜索插入位置 本质就是找到临近目标值 第一个等于或小于目标值的位置
  
  // 以左闭右开区间方式为例
  function fn(list, target) {
      let left = 0
      let right = list.length - 1
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          // 因为是找第一个大于目标值的值
          // 等同于找循环结束后的右区间(最大值)
          // 且这个值不会和目标值相等
          // 因此判断条件为 大于时 和 小于等于时
          if (list[mid] > target) {
              right = mid - 1
          } else if (list[mid] < target) {
              left = mid + 1
          } else {
              // 此时已经找到第一个等于的值
              return mid
          }
      }
      // 没找到等于的值 但是循环已经结束 返回离目标值最近且大于它的值
      // 因为left<=right是循环条件 所以最后right<left
      // 因此right要加1
      return right + 1
  }
  
  // 验证
  console.log('目标值小于所有值时:' + fn([3, 4, 5, 6], 1)) // 0
  console.log('目标值大于所有值时:' + fn([3, 4, 5, 6], 10)) // 4
  console.log('目标值等于某一元素:' + fn([1, 4, 7, 15], 4)) // 1
  console.log('目标值在区间内且不等于任意值:' + fn([1, 4, 7, 15], 8)) // 3
  console.log('目标值等于某一连续元素:' + fn([1, 4, 4, 4, 7, 15], 4)) // 2
  
  // 简化fn方法
  function fn2(list, target) {
      let left = 0
      let right = list.length - 1
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          if (list[mid] < target) {
              left = mid + 1
          } else {
              // 因为要的是右区间或等于的值 所以把两者条件合并到一起
              right = mid - 1
          }
      }
      return right + 1
  }
  ```
  

## 在排序数组中查找元素的第一个和最后一个位置

- [力扣34](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

  ```js
  // 思路
  // 用二分法分别找到
  // 目标值出现的第一个位置 即list[mid] >= target来不断移动右区间
  // 和目标值出现的最后一个位置 即list[mid] <= target来不断移动左区间
  // 情况1：不在数组范围内 返回{-1, -1}
  // 情况2：在范围内 但不存在 返回{-1, -1}
  // 情况3：在范围内 且存在 返回[left, right]左闭右闭区间
  
  class Fn {
      constructor(list, target) {
          this.left = this.getLeft(list, target)
          this.right = this.getRight(list, target)
          this.range = this.getRange()
      }
      getRight(list, target) {
          let left = 0
          let right = list.length - 1
          while (left <= right) {
              let mid = left + ((right - left) >> 1)
              // 注意
              // 因为是找目标值右边界 所以要让left不断移动 而不去动right
              // 当最后一次循环left == right后
              // 此时left > right 此时right就等于目标值最末尾的位置
              if (list[mid] <= target) {
                  left = mid + 1
              } else if (list[mid] > target) {
                  right = mid - 1
              }
          }
          // 因为要的是等于目标值的最末尾位置 所以不加1
          return right
      }
      getLeft(list, target) {
          let left = 0
          let right = list.length - 1
          while (left <= right) {
              let mid = left + ((right - left) >> 1)
              // 注意
              // 因为是找左边界 所以要让right不断移动 而不去动left
              // 当最后一次循环left == right后
              // 此时left > right 此时left就等于目标值第一次出现的位置
              if (list[mid] < target) {
                  left = mid + 1
              } else if (list[mid] >= target) {
                  right = mid - 1
              }
          }
          return left
      }
      getRange(left = this.left, right = this.right) {
          if (left > right) {
              // 说明 没有找到目标值 返回 -1
              return [-1, -1]
          } else {
              // left <= right 说明目标值存在且取到了左右边界
              return [left, right]
          }
      }
  }
  
  // 验证
  console.log('不在数组范围内', new Fn([1, 2, 3], 4)) // left:3 right:2 range:[-1, -1]
  console.log('在范围内但不存在', new Fn([1, 2, 3, 5], 4)) // left:3 right:2 range:[-1, -1]
  console.log('在范围内且存在', new Fn([1, 2, 2, 2, 3, 4], 2)) // left:1 right:3 range:[1, 3]
  console.log('在范围内且存在', new Fn([1, 2, 3, 4], 2)) // left:1 right:1 range:[1, 1]
  ```
  

## x的平方根

- [力扣69](https://leetcode.cn/problems/sqrtx/description/)

  ```js
  // 二分法思路
  // 视数字为1到n的整数数组 不断求 中间值平方是否等于n
  // 如果等于则直接返回中间值
  // 如果没找到 以左闭右闭区间为例 最后一次循环 left == right
  // 执行完left > right 所以取right值为开根号后的整数值
  
  function fn(num) {
      // 0 和 1 的平方根等于自身
      if (num === 0 || num === 1) {
          return num
      }
      let left = 1
      let right = num
      // 左闭右闭区间
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          if (mid * mid > num) {
              // 中间值的平方大于目标值 自然要缩小中间值
              // 因此缩小最大值(右区间)
              right = mid - 1
          } else if (mid * mid < num) {
              // 中间值的平方小于目标值 自然要增大中间值
              // 因此增大最小值(左区间)
              left = mid + 1
          } else {
              // 找到平方根值
              return mid
          }
      }
      // 循环结束 没找到mid * mid == num
      // 此时left > right 取right值返回
      return right
  }
  
  // 验证 平方根只保留整数 舍弃小数位
  console.log('二分法4的平方根:' + fn(4)) // 2
  console.log('二分法8的平方根:' + fn(8)) // 2
  console.log('二分法15的平方根:' + fn(15)) // 3
  ```
  

## 有效的完全平方数

- [力扣367](https://leetcode.cn/problems/valid-perfect-square/description/)

  ```js
  // 思路
  // 同力扣69的求平方根 只不过本题只求整数平方正好等于原值 其他算作false
  // 因此只需在力扣69的基础上将return right改为return false
  
  function fn(num) {
      if (num === 0 || num === 1) {
          return true
      }
      let left = 1
      let right = num
      // 以左闭右闭为例
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          if (mid * mid > num) {
              right = mid - 1
          } else if (mid * mid < num) {
              left = mid + 1
          } else {
              return true
          }
      }
      return false
  }
  
  // 验证
  console.log('4的有效平方数:' + fn(4)) // true
  console.log('8的有效平方数:' + fn(8)) // false
  console.log('15的有效平方数:' + fn(15)) // false
  ```

# 双指针

## 移除元素

- [力扣27](https://leetcode.cn/problems/remove-element/description/)

  ```js
  // 思路
  // 数组删除元素在内存中本质上是将删除位置后面所有元素向前移动一格
  // 删除后数组长度在内存中其实没变 末尾元素其实还在内存里 只是不进行处理
  // 所谓的数组长度改变 只是通过编程语言封装的方法返回给你的结果
  // 以此为理论基础 就可以设置一个快指针 它必然可以遍历完原数组
  // 再设置一个慢指针 它表示删除元素后的新数组
  // 每遇到一个要删除的元素就停滞一下 从而跟快指针拉开距离
  // 并将快指针所在位置不同于删除元素的值赋值给慢指针当前位置
  // 因为慢指针赋值后会往前移动 慢指针位置索引 === 新数组.length
  
  // 时间复杂度：O(n)
  // 空间复杂度：O(1)
  
  function fn(target, source) {
      let slowIndex = 0
      for (let fastIndex = 0; fastIndex < source.length; fastIndex++) {
          // 快指针当前值不等于目标值 则将该值赋值给慢指针当前停留位置
          // 并移动慢指针
          if (source[fastIndex] !== target) {
              source[slowIndex] = source[fastIndex]
              slowIndex++
          }
      }
      return slowIndex
  }
  
  // 验证
  let list = [11, 4, 22, 3, 4, 3, 11, 3]
  console.log('删除3后数组长度:' + fn(3, list)) // 5
  ```

## 删除排序数组中的重复项

- [力扣26](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

  ```js
  // 思路
  // 同力扣27 只不过目标值是动态的
  
  function fn(source) {
      let slow = 0
      // 因为是有序数组 因此重复元素是排在一起的
      // 设置target作为动态目标值
      let target
      let newList = [] // 慢指针作为新数组索引
      for (let fast = 0; fast < source.length; fast++) {
          // 第一次循环时 target 是undefined
          // 后续遍历时target每次只会等于不同的值
          // 就意味着会去重只将不同的值放入新数组
          if (source[fast] !== target) {
              // 第一次循环时赋初值
              target = source[fast]
              newList[slow++] = source[fast]
          }
      }
      return newList
  }
  
  // 验证
  let list = [0, 1, 1, 1, 2, 2, 3, 4, 4]
  console.log('去重结果', fn(list)) // [0, 1, 2, 3, 4]
  ```

## 移动零

- [力扣283](https://leetcode.cn/problems/move-zeroes/description/)

  ```js
  // 思路
  // 同力扣27删除元素 只不过在删除目标值形成新数组后
  // 此时慢指针位置在超出新数组末尾后一格
  // 删除多少个元素 就在末尾补多少个同样的元素
  // 因此就可以从慢指针位置开始到原数组末尾覆盖为同样的值
  
  // 时间复杂度：O(n)
  // 空间复杂度：O(1)
  
  function fn(source, target) {
      let slow = 0
      // 第一遍遍历将非目标值往前移动
      for (let fast = 0; fast < source.length; fast++) {
          if (source[fast] !== target) {
              source[slow++] = source[fast]
          }
      }
      // 第二遍遍历 从慢指针索引位置开始用目标值覆盖数组后面的值
      for (let i = slow; i < source.length; i++) {
          source[i] = target
      }
      return source
  }
  
  // 验证
  let list = [0, 1, 0, 3, 0, 0, 1]
  console.log('移动0', fn(list, 0)) // [1, 3, 1, 0, 0, 0, 0]
  ```

## 比较含退格的字符串

- [力扣844](https://leetcode.cn/problems/backspace-string-compare/description/)

  ```js
  // 重构字符串思路
  // 设一个新数组 将遇到的非#(退格)字符填入新数组
  // 当遇到#就对新数组执行出栈 最后对比新数组组成的字符串
  
  // 时间复杂度：O(N+M) N和M表示两个字符串个遍历一次
  // 空间复杂度：O(N+M)
  
  function fn(str1, str2) {
      let a1 = []
      let a2 = []
      for (let val of str1) {
          if (val != '#') {
              a1.push(val)
          } else if (val == '#') {
              a1.pop()
          }
      }
      for (let val of str2) {
          if (val != '#') {
              a2.push(val)
          } else if (val == '#') {
              a2.pop()
          }
      }
      return a1.join('') === a2.join('')
  }
  
  // 验证
  let t1 = 'ab#c'
  let t2 = 'ab##ac'
  console.log('重构字符串结果:' + fn(t1, t2)) // true
  
  // 双指针法思路
  // 因为#号会删除自身前一个非#号字符 且多个#号会累计删除字符数量
  // 因此指针因该从后往前遍历 这样在遇到#号时就累计 遇到非#号就减少累计
  // 两个指针分别指向两个数组末尾 然后放在同一个大循环中
  // 这样做的目的是为了让两个指针共同递减
  // 然后每一轮大循环中 执行各自的小循环
  // 小循环中一直累计和减少累计 直到累计为0 即当前指针所指向的值被保留就break
  // 然后在当前大循环中对比
  // 情况一 两个指针都没遍历完 且 两指针位置的保留字符不相同 这表示最终字符串一定不相同 return false
  // 情况二 情况一不符的条件下 任一指针没遍历完 这表示有一个指针已经遍历完 另一个没遍历完停在了保留字符
  // 即 最终字符串长度不同 也 return false
  // 情况一二都不符 说明两字符串还有相同的可能性 则对两指针同时递减 开启新一轮(大循环中的)小循环
  // 直到两指针都小于0 说明两字符串都遍历结束 结束大循环 进行到此时都没有触发情况一二
  // 说明字符串相等 return true
  
  function fn2(str1, str2) {
      let index1 = str1.length - 1 // 索引
      let count1 = 0 // #号累计(即要删除的字符数)
      let index2 = str2.length - 1
      let count2 = 0
      // >=0 是为了让两字符串都遍历完 再得出结果
      while (index1 >= 0 || index2 >= 0) {
          while (index1 >= 0) {
              if (str1[index1] === '#') {
                  // 如果遇到#号就累加
                  count1++
                  index1--
              } else if (count1 > 0) {
                  // 如果遇到非#号字符则减少累计
                  count1--
                  index1--
              } else {
                  // 没有累计 即不需要删除 就跳出循环准备对比
                  break
              }
          }
          while (index2 >= 0) {
              if (str2[index2] === '#') {
                  count2++
                  index2--
              } else if (count2 > 0) {
                  count2--
                  index2--
              } else {
                  break
              }
          }
          if (index1 >= 0 && index2 >= 0) {
              // 两字符串都没遍历完
              if (str1[index1] !== str2[index2]) {
                  // 保留字符不同 说明两字符串不同
                  return false
              }
          } else if (index1 >= 0 || index2 >= 0) {
              // 不满足前一个条件 说明有一个字符串已经遍历完
              // 即 字符串长度不相同
              return false
          }
          // 说明两字符串当前循环对比的字符相同 继续进入大循环
          // 或 两个字符串都遍历完了 跳出循环
          index1--
          index2--
      }
      return true
  }
  
  // 验证
  let str1 = 'a##ab#c'
  let str2 = '##ac#c'
  console.log('双指针验证结果:' + fn2(str1, str2)) // true
  ```

## 有序数组平方

- [力扣977](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)

  ```js
  // 思路
  // 题目条件是升序排列数组 因为数组中有负数所以平方后负数可能会大于正数平方
  // 利用题目条件 先找到负数和正数的分界位置
  // 因为负数越小 平方越大 所以负数是从最小的负数开始递减遍历
  // 而正数索引则是从最小正整数开始递增遍历
  // 将这两者遍历放到一个循环中执行 每轮对比正数和负数的平方值大小
  // 将较小值填入新数组 直到一方遍历完 将另一方值依序填入新数组
  
  function fn(list) {
      let boundary // 记录分界位置
      // 注意是升序数组 如果起始位置不是负数 则跳过循环
      for (let i = 0; i < list.length; i++) {
          if (list[i] < 0) {
              boundary = i
          } else {
              break
          }
      }
      let j = boundary // 遍历负数索引
      let k = boundary + 1 // 遍历正数索引
      let newList = [] // 结果数组
      while (j >= 0 || k < list.length) {
          if (j < 0) {
              // 负数先遍历完
              // 则将正数按序填入
              newList.push(list[k] * list[k])
              k++
          } else if (k === list.length) {
              // 正数先遍历完
              // 将负数按序填入
              newList.push(list[j] * list[j])
              j--
          } else if (list[j] * list[j] < list[k] * list[k]) {
              // 负数的平方比正数小 则将负数平方填入新数组
              newList.push(list[j] * list[j])
              j--
          } else {
              // 负数平方比正数平方大 则将正数平方填入数组
              newList.push(list[k] * list[k])
              k++
          }
      }
      return newList
  }
  
  // 验证
  let list = [-4, -1, 0, 5, 10]
  console.log('平方数数组为', fn(list)) // [0, 1, 16, 25, 100]
  ```
