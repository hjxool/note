## 小程序特点

- 没有DOM
- 使用组件化开发，类似Vue单文件
- 项目体积不能超过2M，否则无法上线
- 文件功能

  - `.js`逻辑功能
  - `.wxml`视图结构，同`.html`
  - `.wxss`样式，同`.css`
  - `.json`存储数据
- 使用`rpx`适配方案，而不是`rem`

  - 单位：`rpx`
  - 规定任何屏幕==宽度==都为`750rpx`
    - 例：`375px`宽度的手机屏，它的`1rpx = 0.5px`，在写样式时`50px`的元素就可以设置为`100rpx`

  - 小程序会根据屏幕宽度自动计算`rpx`
- 项目最外层必须要有`app.js`

  - 用途：注册整个小程序应用
- 单个页面下使用`Page({配置项})`配置数据，类似Vue的`new Vue({配置项})`
- 没有全局对象`window`，取而代之的是`wx`
- 更新迭代很快，有的方法已经废弃，详情见[官网](https://mp.weixin.qq.com/)
- `wxml`页面元素上绑定变量使用`<image src="{{userInfo.icon}}">`
- 样式
  - 不能`*{...}`给全部元素设置样式
- `wxml`中的`{{ }}`语法**只能**填入`data:{}`中定义的属性，不能用函数返回值作为其内容
- 创建项目时`AppID`不变，用户的`_openid`就不会变


## 文件结构

- `app.wxss`公共样式

- `app.json`全局配置

  - 如：页面文件路径、窗口样式、网络超时时间等

    ```json
    {	// 在任一级目录下"新建 Page"会自动在此添加文件路径
        "pages": ["pages/index/index"]
    }

- `app.js`入口文件

- 单独页面文件夹下
  - `xxx.json`表示==当前==页面==配置==
    - 如：当前页名称
    - 配置项名和`app.json`相同，**但是**不需要在`window`下写，直接写最外层即可
  - `xxx.wxss`、`xxx.wxml`、`xxx.js/ts`当前页样式、结构、逻辑

## 静态页面

- `<view>`等于`<div>`

- `<text>`等于`<span>`

- 所有页面外层都包裹着`<page>`作为根节点，但是`<page>`默认没有高度，由内部元素撑开，所以需要在`app.wxss`或者`app.less`设置==公共样式==

  ```less
  page{
      height: 100%;
  }

## 数据绑定对比

- 小程序
  - `data:{}`中==初始化==数据
  
  - 取值时必须用`this.data.key`
  
  - 修改数据
    - 修改数据是==同步==执行
    
    - `this.setData`中`key`不需要加`this.data`
    
      ```js
      data: {
          sum: 0,
          obj1:{
              obj2:'xxx'
          },
          obj3:{
              obj4:[{obj5:'xxx'}]
          }
      }
      fn(){
          this.setData({
              sum: this.data.sum + 1,
              // 第一种方式用数组字符串 动态字段时必须用数组
              ['obj1.obj2']: newValue,
              // 如
              [`obj3.obj4[${index}].obj5`]: newValue,
              // 第二种字符串
              'obj1.obj2': newValue
              'obj3.obj4[0].obj5': newValue
      	})
      }
    
  - 没有数据代理
    - `this.data.xxx`取数据
    - 只有通过`setData`修改的数据才能回显到页面
    
  - 数据流
    - 只有`Model -> View`
      - 后续更新支持了双向绑定，但是不支持`对象.属性`的写法
  
- Vue
  - `data(){return {}}`中初始化数据
  - 修改数据：`this.key = value`
  - 数据流
    - 双向数据绑定：`Model <--> View`
  
- React
  - `state`中初始化状态数据
  - 修改数据：`this.setSate()`
    - 在生命周期函数中是==异步==执行
    - 非生命周期函数中是==同步==执行
  - 数据流
    - 只有`Model -> View`

## 获取页面节点信息

- 事件对象只有==相对==位置

- 获取节点使用`createSelectorQuery()`

  - 自定义组件或当前页面使用`this.createSelectorQuery()`

  - 全局获取节点才用`wx.createSelectorQuery()`

    ```js
    let query = this.createSelectorQuery()
    let dom = query.select('#id/.class/view等')
    dom.boundingClientRect(res => {
    	console.log('相对视窗的绝对定位', res)
    })
    dom.scrollOffset(res => {
    	console.log('滚动距离', res)
    })
    // 关键 必须要执行才能获得上述节点信息
    query.exec()

## 事件绑定

- 小程序分==冒泡事件==和==非冒泡事件==

- `bind`绑定事件会冒泡

  ```html
  <view bindtap="fn">屏幕点击事件</view>
  ```

- `catch`绑定事件**不会**冒泡

  ```html
  <view catchtap="fn">屏幕点击事件</view>

- 事件回调放置在生命周期函数同级

  ```ts
  Page({
      data:{},
      onLoad:{}.
      ...
      fn(){}
  })
  ```

- `wxml`绑定事件传入自定义参数

  - 小程序中绑定事件不能用`bindtap="fn(参数)"`这种形式，但是`bindtap="fn"`绑定事件，`fn`只会有`event`一个参数

  - 因此同一事件方法想传入自定义参数进行区分操作，就需要用`data-*`属性

    ```html
    <button catchtap="fn" data-cc="test"></button>
    ```

  - `event`中`target`、`currentTarget`都有`dataset`属性

    - `target`不一定是==绑定==事件的元素，有可能是子元素冒泡到的父元素
    - `currentTarget`要求绑定事件的元素一定是触发事件的元素

    ```js
    fn(event){
        console.log(event)
        // 打印的event
        {
            target: {
                dataset: {
                    cc: 'test'
                },
                ...
            },
            ...
        }
    }
    ```

- `target`与`currentTarget`

  - `target`指向**触发**事件的元素

    - 如里层子元素

      ```html
      <!-- 这里fn的target取到的是里层dataset:cc -->      
      <view catchtap="fn" data-aa="{{index}}">
      	<view data-cc="{{other}}"></view>
      </view>

  - (推荐)`currentTarget`指向**捕获**事件的元素

    - `catchtap`就是**捕获**点击事件

## 页面跳转

- 需要调用API跳转

  - 路径只能是`app.json`里的绝对路径或相对路径
    - 路径不能带有`.wxml`后缀，只能用`/pages/目录/index`或`../目录/index`这种形式

  ```ts
  turnToPage(){
      // 保留当前页面跳转 跳转后有返回按钮
      wx.navigateTo({
          url: '/pages/logs/logs'
      })
      // 关闭当前页跳转 跳转后只有返回首页按钮
      wx.redirectTo({...})
   	// 关闭所有页面跳转 跳转后只有返回首页按钮
      wx.reLaunch({...})
  }
  ```

- 传参仅支持`query`参数

  - 但是`url`传参长度有限制

  ```js
  turnToPage(){
      wx.navigateTo({
          // 不建议用这种方式传数据量比较大的，建议配合后端服务传一个id过去调接口查询
          url: '/pages/logs/logs?key=' + value
      })
  }
  ```

- `Page`页面在`onLoad(){}`生命周期时已经可以操作`data:{}`中的数据了

## 底部切换页面tabbar

- 所有页面都会显示的组件，点击跳转到其他页面

- 在`app.json`中全局配置

  ```json
  {
      "tabBar": {
          "list": [
              {
                  "pagePath": "page/index/index",
                  "text": "主页",
                  "iconPath": "/static/img/xxx.png",
                  "selectedIconPath": "/static/img/xxx2.png"
              }
          ],
          "color": "#333",
          "selectedColor": "#d43c33",
          "backgroundColor": "#fff"
      }
  }

## 生命周期

- 页面==线程==和逻辑==线程==交互的时机

  ![img](https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png)

- 返回首页或前一页会销毁当前页`onUnload()`
  - 返回前一页只会触发`onShow()`
  - 返回首页会触发`onLoad()`、`onShow()`、`onReady()`

## 条件渲染

- 形如`v-if`的渲染方式，为`false`的不会挂载在页面上

  - 初始加载消耗低，切换显示消耗高


  ```html
  <view wx:if="{{showFlag === 1}}"></view>
  <view wx:elif="{{showFlag === 2}}"></view>
  <view wx:else></view>
  
  <!-- 如果要条件判断多个组件标签 可以用block标签
  block并不是一个组件 仅仅是包裹元素 不会渲染在页面 类似HTML中的template标签-->
  <block wx:if="{{条件}}">
  	<view>xxx</view>
      <view>...</view>
  </block>
  ```

- 形如`v-show`的渲染方式，为`false`只会隐藏，但元素还在页面

  - 不能用在`<block>`标签上
  - 切换显示消耗更低，初始加载消耗高

  ```html
  <view hidden="{{true}}">测试hidden是否会挂载到页面</view>


## 列表渲染

- `wx:key="itemKey"`可以直接绑定数组元素属性

  ```html
  <view wx:for="{{array}}" wx:key="id"></view>
  ```

  ```ts
  data:{
      array:[
          {id:1, value:'xxxx'},
          {id:2, value:'aa'},
          {id:3, value:'vv'},
      ]
  }
  ```

- `wx:key="*this"`

  - `*this`表示`item`本身作为唯一值`key`，如果`item`为==对象==则不行！
  - `array`结构`array:[1,2,3]`

  ```html
  <view wx:for="{{array}}" wx:key="*this">{{item}}</view>
  ```

- `wx:for="{{list}}"`

  - 默认下标名为`index`
  - 当前项默认名`item`

  ```html
  <view wx:for="{{list}}">
    {{index}}: {{item.message}}
  </view>
  ```

  - 使用 `wx:for-item` 可以指定数组当前元素的变量名
  - 使用 `wx:for-index` 可以指定数组当前下标的变量名

  ```html
  <view wx:for="{{list}}" wx:for-index="id" wx:for-item="itemName">
    {{id}}: {{itemName.message}}
  </view>

## 组件

1. 新建`Component`，写结构、逻辑、样式

   ```ts
   Component({
       // 等同Vue中的props 详见官方文档-框架接口-自定义组件
       properties: {
           title: {
               type: String, //数据类型
               value: 'xxx', //属性初始值
           },
           // 简写属性
           content: String
       },
       // 组件的内部数据 同Page中的data
       data: {},
       // 组件方法得写在methods里
       methods: {
           fn(){}
       }
   })

2. 编辑使用组件页面对应的`xxx.json`文件

   ```json
   {
       "usingComponents": {
           // "组件名": "/文件夹/文件夹/文件名"
           "navHeader": "/components/header/header"
       }
   }

3. 在页面使用不需要将驼峰式转为短横线

   ```html
   <navHeader title="xx" content="xx"></navHeader>
   ```

- 模板数据绑定

  ```html
  <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
      <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
      <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
  ```

- 监听、触发事件(子组件向父页面|组件通信)

  - 监听事件

    - Page|父组件页面

      ```html
      <component-tag-name bind:myevent="myEvent" />

    - Page|父组件的js

      ```js
      Page({
        myEvent: function(e){
          e.detail // detail即触发事件接收到的值
        }
      })

  - 触发事件

    - 组件页面

      ```html
      <button bindtap="myTap">点击这个按钮将触发“myevent”事件</button>
      ```

    - 组件js

      ```js
      Component({
        properties: {},
        methods: {
          myTap: function(){
            var myEventDetail = {key: value} // 传参
            // 配置项 非必填
            var myEventOption = {
                bubbles: true|false,//事件是否冒泡
                composed: true|false,//是否只能在引用组件的节点树上触发
                capturePhase: true|false,//时间是否拥有捕获阶段
            }
            this.triggerEvent('myevent', myEventDetail, myEventOption)
          }
        }
      })
      ```

- 父页面|组件向子组件通信传值

  - 属性绑定

    - 父组件|页面

      ```html
      <child customProp="{{parentData}}"></child>
      ```

    - 父组件|页面JS

      ```js
      data:{
          parentData: {key: value}
      }
      ```

    - 子组件JS中声明

      ```js
      Component({
          properties: {
              customProp: Object
          }
      })
      ```

    - 子组件JS中通过`this.properties.customProp.value`可以获取父页面传进的值

    - 子组件`wxml`中通过`{{customProp}}`来使用

  - 获取组件实例

    - 在父组件|页面中使用`this.selectComponent('css选择器')`来获取子组件实例对象

    - 子组件实例上**没有**`methods`中定义的方法，但可以通过子组件实例`setData`更新页面数据

      ```js
      // 父页面js
      let dom = this.selectComponent("#select_time")
      dom.setData({
          childkey: newValue
      })
      ```

    - 组件被 `selectComponent` 调用时的自定义返回值

      - 自定义返回值的组件必须使用内置`wx://component-export`

      ```js
      // 子组件
      Component({
        behaviors: ['wx://component-export'],//自定义必须引入
        export() {
          return { fn(){代码操作} }
        }
      })
      // 父页面
      let dom = this.selectComponent('#id')
      // dom结果为{fn(){...}}

- 组件引入公共内容`behaviors`

  - 同Vue的`mixins:[]`，用于共享代码

  - 注：`Behavior`中不是所有配置项都有！比如`Component({options:{...}})`就没有！

    ```js
    // my-behavior.js
    exports default Behavior({
      behaviors: [],
      properties: {
        myBehaviorProperty: {
          type: String
        }
      },
      data: {
        myBehaviorData: {}
      },
      attached: function(){},
      methods: {
        myBehaviorMethod: function(){}
      }
    })
    // my-component.js
    import myBehavior from 'my-behavior'
    Component({
        behaviors: [myBehavior],
    })
    ```

- 数据监听

  - 如：`this.data.sum` 永远是 `this.data.numberA` 与 `this.data.numberB` 的和

    ```js
    Component({
        data: {
            sum: 0,
            numberA: 5,
            numberB: 10,
        },
        observers: {
            // 可以同时监听多个字段
            'numberA, numberB': function(a, b){
                // 监听numberA numberB变化时重新计算sum值
                this.setData({
                    sum: a + b
                })
            }
        }
    })
    ```

- Tips

  - `app.wxss` 中的样式对自定义组件无效！想应用全局样式得在组件JS文件中添加配置

    - 该配置在`behaviors`中没有

    ```js
    Component({
        options:{
        	addGlobalClass:true,// 应用app.wxss全局样式
      	},
    })
    ```

## WXML模板

- 形似组件，但是只有样式和`wxml`结构

1. 在新建`xxx.wxml`和`xxx.less/wxss`

   ```html
   <!-- wxml文件 -->
   <!-- 必须要有name 用于指定是哪个模板 -->
   <template name="myTemplate">
     <view>
       <!-- 模板结构中动态属性在使用页data中定义 随使用页定义属性动态变化 -->
       <text> {{index}}: {{msg}} </text>
       <text> Time: {{time}} </text>
     </view>
   </template>
   ```

2. 使用页引入模板`wxml`文件

   ```html
   <!-- 引入文件 -->
   <import src="/template/myTemplate/myTemplate.wxml"/>
   <!-- 使用模板 通过data往模板中传入使用页data定义的属性 -->
   <template is="myTemplate" data="{{...obj}}"></template>
   ```

3. 使用页样式文件中引入模板样式

   - 注：使用页样式会覆盖模板样式中同名的

   ```css
   @import "/template/myTemplate/myTemplate.wxss"
   ```

## 移动端通用触控相关属性方法

- 获取手指坐标

  ```ts
  hanleTouchStart(event){
      // touches表示几根手指触屏 一般取第一个手指
      startY = event.touches[0].clientY
  }

## 数据共享(页面通信)

- 通常JS文件中声明的变量和函数只在该文件中有效，但是通过`getApp`获取全局应用实例可以达到共享数据

  ```js
  // app.js
  app({
      customData: 12,
      globalData: {...},
      // 可以自定义函数用于存取共享数据
      fn(...params){
          this.customData = params
      }
  })
  
  // xx.js
  let app = getApp()
  app.customData++
  // 使用app实例中自定义方法获取其他页面存的数据
  console.log(app.customData) // ['参数1','参数2']
  
  // xx2.js
  let app = getApp()
  app.fn('参数1','参数2')

- 使用小程序API中==数据缓存==相关接口，利用本地缓存进行数据共享

- 如果一个页面由另一个页面通过 `wx.navigateTo`打开，这两个页面间将建立一条数据通道

  - ==被打开==的页面可以通过 `this.getOpenerEventChannel()` 方法来获得一个 `EventChannel` 对象

  - `wx.navigateTo` 的 `success` 回调中也包含一个 `EventChannel` 对象

    ```js
    // 跳转前页面
    wx.navigateTo({
        url: '...',
        // events中监听被打开页面发送到当前页面的数据
        events: {
            sonToParent(data){
                console.log('父页面收到的数据', data)
            }
        },
        // 成功跳转后的回调函数
        // 注意 仅只有success成功回调中才有EventChannel对象
        success(res){
            // 页面跳转后向被打开页面通信
            res.eventChannel.emit('parentToSon', {msg: '我是跳转前页面'})
        }
    })
    
    // 被打开页面
    onLoad(){
        this.hhh = this.getOpenerEventChannel()
        this.hhh.on('parentToSon', function(data){
            console.log(子页面收到的数据', data)
        })
    }
    customfn(){
        this.hhh.emit('sonToParent', '我是跳转页')
    }
    ```

## 分包

- 当代码打包超过上限`2M`时，就需要分包，将代码根据不同页面分成最大`2M`的一个个小包，总大小不超过`20M`左右

- 常规分包

  1. 在==根目录==下创建包文件夹。如`package1`、`package2`

  2. 将主包外的页面==文件夹==放入对应包文件夹

  3. 在`app.json`中配置

     - 未配置在`subpackages`中的其他页面文件夹作为==主包==
     - 分包页面文件路径不能出现在外层`pages`(主包)中
     - `subpackages`中`pages`分包路径是以分包文件夹为根目录

     ```json
     {
         "pages": ["pages/index/index"],
         "subpackages": [
             {
                 "root": "package2",
                 "pages": ["pages/userInfo/userInfo"]
             }
         ],
         ...
     }
     ```

  4. 修改页面文件中`navigateTo`等API路径

     - API跳转路径都是从项目根目录下查找

     ```js
     // index.js
     turnTo(){
         wx.navigateTo({
             url: '/package2/pages/userInfo/userInfo'
         })
     }

- 独立分包

  1. 相比常规分包，需要在`subpackages`中增加配置项`independent`

     ```json
     {
         "pages": ["pages/index/index"],
         "subpackages": [
             {
                 "root": "package2",
                 "pages": ["pages/userInfo/userInfo"],
                 "independent": "true"
             }
         ],
         ...
     }

  - 与常规分包的区别
    - 独立分包不需要加载主包，可单独访问分包内容
    - 独立分包不能依赖主包及其他分包内容

## 分包预载

- 进入某个分包页面时自动预下载可能需要的分包，提升进入后续分包页面的启动速度

  ```json
  {
      "pages": [],
      "subpackages": [],
      "preloadRule": {
        // 指定页面路径
        "pages/index": {
            // wifi(默认，仅wifi预下载) all(不限)
            "network": "all",
            // 进入页面后预下载分包名 分包名同subpackages中的root或name
            "packages": ["package2"]
        }
      }
  }

## 云开发

1. 使用云能力前，需要先在`app.js`初始化

   - `env `参数说明
     - `env` 参数决定接下来小程序发起的云开发调用`wx.cloud.xxx`会默认请求到哪个云环境的资源
     - 如不填则使用默认环境（第一个创建的环境）

   ```js
   App({
       onLaunch(){
           if(wx.cloud) {
             wx.cloud.init({
                 // 此处请填入环境 ID, 环境 ID 可打开云控制台查看
                 env: 'cloud1-xxx',
                 traceUser: true,// 固定写法
             })  
           }
       }
   })

2. 云能力初始化后想使用数据库API增删改查，需要先获取数据库引用

   ```js
   const db = wx.cloud.database()
   ```

3. 要操作集合，需要先获取它的引用

   ```js
   const testdoc = db.collection('testdoc')
   ```

4. 得到集合的引用后即可操作文档记录

   - 获取单条文档引用，用于对特定文档进行操作(前/后端均可用)

     ```js
     const specialLog = testdoc.doc('记录的_id')
     ```

   - 往集合中插入数据

     ```js
     testdoc.add({
         // data表示需要新增的JSON数据
         data: {
             // _id: '可选 传则自定义id 且不能与已有_id冲突 不传自动生成',
             cusKey1: 'xxx',
             cusKey2: new Date(),
             cusKey3: new db.Geo.Point(113,23),// 添加地理位置
             cusKey4: {
                 cusKey5: 'aaa',
                 cusKey6: 10
             }
         },
         success(res){
         	// res是一个对象，其中_id字段表示刚创建的记录的id
     	}
     }).then(res => {
         // add对象中不传入success、fail、complete即Promise风格
         // res 是一个对象，其中 _id 字段表示刚创建的记录的 id
     })
     ```
   
   - 查询数据
   
     - 查询结果为空则返回==空数组==
   
     - 通过文档引用(前端)
   
       ```js
       // 普通方式
       specialLog.get({
           success(res){
               // res.data包含该记录的数据
           }
       })
       // Promise风格
       specialLog.get().then(res => {
           console.log(res.data)
       })
       ```
   
     - 通过集合的`where`方法指定查询条件，再调用`get`方法返回满足条件的==记录==(服务端)
   
       - `where`中每个字段和它的值构成一个匹配条件，各个字段间的关系是 `与`，即需同时满足
       - `key: value`全等匹配
   
       ```js
       testdoc.where({
           cusKey1: 'xxx',
           cusKey4: {
               cusKey5: 'aaa'
           }
           // 也可以用 点表示法 表示嵌套字段
           'cusKey4.cusKey5': 'aaa'
       }).get().then(res => )
       ```
   
     - 条件查询
   
       - 指令在`db.command`对象上
       - 指令都是函数形式，可以在`()`后连其他指令。如`_.gt(10).and()`
   
       ```js
       const _ = db.command
       testdoc.where({
           // gt大于 gte大于等于 lt小于 lte小于等于 eq等于 neq不等于
           'cusKey4.cusKey6': _.gt(10),// 大于10的条件
           
           // and与 or或
           'cusKey4.cusKey6': _.gt(10).and(_.lt(30)),// 同时满足_.gt(10) _.lt(30)
           'cusKey4.cusKey6': _eq(0).or(_.eq(100)),// _.eq(0) 或 _.eq(100)
       }).get().then(res => )
       // 跨字段进行 或 等操作 where()中不再传入{} 而是指令函数
       testdoc.where(
           // _.and([obj1, obj2])表示多个查询条件必须同时满足
           // _.and没必要使用 因为where({})中的条件本身就是and连接
           
           // _.or([obj1, obj2])表示多个查询条件满足任一
       	_.or([
       		{'cusKey4.cusKey6': _.gt(10}},
           	// _.in([val1, val2])表示cusKey1值满足数组中任意一个元素
           	// _.nin不在给定数组中
           	{ cusKey1: _.in(['xxx', 'yyy']) }
       	])
       )
       ```
   
     - 查询数组/对象
   
       - 匹配==数组==中的==元素==。可传入数组中存在的而元素来筛选
   
         ```js
         // 集合中记录
         {
             "list": [10, 20, 30]
         }
         // 匹配所有list字段中有20的记录
         testdoc.where({
             list: 20
         }).get()
         // 匹配数组
         testdoc.where({
             list: [10, 20, 30]
         }).get()
         // 匹配数组第n项元素 同数组下标
         testdoc.where({
             'list.1': 20
         }).get()
         ```
   
       - 数组也可以使用`lt`、`gt`等指令
   
         ```js
         // 集合中记录
         {
             "list": [10, 20, 30]
         }
         const _ = db.command
         testdoc.where({
             // 数组元素同时满足大于等于20且小于50的
             list: _.gte(20).and(_.lt(50))
             list: _.elemMatch(_.gte(20).lt(50))
             // 同时包含10 30的数组
             list: _all([10, 30])
         
         	// 数组长度为3的记录
         	list: _.size(3)
         }).get()
         ```
   
       - 匹配==多层嵌套==的数组和对象
   
         ```js
         // 集合中记录
         {
             "list": [
                 {"numbers": [10, 20, 30]},
                 {"numbers": [50, 60, 70]},
             ],
             "list2": [
                 {a: 'aaa', b: 11, c: 10},
                 {a: 'bbb', b: 33, c: 30}
                 ...
             ]
         }
         const _ = db.command
         testdoc.where({
             // 查询集合中所有list字段中numbers字段中大于等于20的结果
             // 无需写下标 即表示遍历所有元素
             'list.numbers': _.gte(20),
             
             // _.elemMatch用于 数组字段 的筛选条件
             // 要求数组中包含至少一个满足elemMatch给定条件的元素
             // 至少一个 同时满足 numbers包含10 30的数组元素
             list: _.elemMatch({
                 numbers:_.all([10, 30])
             }),
             // 至少一个元素 同时满足b小于20 c小于20
             list2: _.elemMatch({
                 b: _.lt(20),
                 c: _.lt(20),
             })
             
             // 如果不用elemMatch则表示每个条件有至少一个数组元素满足就行
             // 至少一个元素满足b小于20 且至少一个元素满足c大于20
             list2: {
                 b: _.lt(20),
                 c: _.gt(20)
             }
         }).get()
         ```
   
     - 获取整个集合数据/==分页==查询
   
       - 不建议通过`testdoc.get()`获取，因为上限20条
       - 建议用云函数获取，可以突破20条限制
       - `count()`计算集合/查询结果总数
       - `skip`跳过n条数据
       - `limit`取前n条数据
       - `where({})`传空对象，表示全查，同`testdoc.get()`
       
       ```js
       // 例 后端做分页查询接口 需要将数据全查计算总数并分页返回
       // 引入云函数
       const cloud = require('wx-server-sdk')
       cloud.init() // 同wx.cloud一样要初始化后才能使用
       // 连接数据库
       const db = cloud.database()
       const max_limit = 100
       const testdoc = db.collection('testdoc')
       async function get_data(pageNum, pageSize){
           // 先计算记录总数
           let {total} = await testdoc.count()
           // 计算分几页 向上取整
           // let pageNums = Math.ceil(total / max_limit)
           // 返回查询结果
           return await testdoc
               .skip((pageNum-1)*max_limit)
               .limit(max_limit)
               .get()
           // 当使用条件筛选并分页时 可以用where
           return await testdoc
           	// condition为空对象表示 全部
               .where(condition)
           	.skip((pageNum-1)*max_limit)
           	.limit(max_limit)
               .get()
       }
   
   - 更新数据
   
     - `update`局部更新一个或多个文档
   
       - 注：更新==多条==记录必须在==服务器端==用==云函数==操作！以下示例中修改多条都是在服务器端。前端只能用`doc('id')`或者修改单条数据
       - ==只有指定字段会更新==，其他字段不受影响
   
       ```js
       // 服务器端环境
       // 引入云函数工具库
       const cloud = require('wx-server-sdk')
       const db = cloud.database()
       const _ = db.command
       const testdoc = db.collection('testdoc')
       testdoc.where({'cusKey4.cusKey6': _.gt(10)}).update({
           // data 传入需要局部更新的数据
           data: {
               cusKey1: 'yyy',// 表示将cusKey1值改为'yyy'
           },
           success(res){}
       })
       ```
   
     - 操作指令
   
       - 指令都在`db.command`对象上
   
         ```js
         testdoc.where({cusKey1: 'xxx'}).update({
             data: {
         		// set设置为指定值 remove删除字段 inc自增 mul自乘
         		// 字段值为数组时 push往末尾添加值 pop删除末尾元素 shift删除头部元素 unshift头部增加值
                 'cusKey4.cusKey6': _.inc(10)
             },
             success(res){}
         })
   
       - `_.set`指令
   
         - `_.set`的用处在于更新一个值为一个对象。如下例是更新`cusKey4.cusKey5`字段值为`'ttt'`，而不是把`cusKey4`字段值更新为`{cusKey5: 'ttt'}`对象
   
           ```js
           data: {
               cusKey4: {
                   cusKey5: 'ttt'
               }
           }
   
         - 如果要整个==替换==`cusKey4`对象，就需要使用`_.set`指令
   
           ```js
           data: {
               cusKey4: _.set({
                   cuskey7: 11
               })
           }
   
     - `set()`==替换==整条==记录==，使用传入对象替换指定记录
   
         - 如果指定ID的记录不存在，则会自动新建记录，该记录拥有指定ID
   
           ```js
           const specialLog = testdoc.doc('记录id')
           specialLog.set({
             data: {
                 cusKey7: 'sss'
             }
           }).then()
   
     - 更新数组/对象
   
       - **只**更新==数组==中某一项元素
   
         ```js
         // 集合中记录
         {
             "list": [10, 20, 30],
             "list2": [
                 {a:'aaa', b:11, c:22}
             ]
         }
         
         testdoc.where({
             list: [10, 20, 30]
         }).update({
             data: {
                 //将list第二个元素20改为50
                 'list.1': 50,
                 // 修改对象数组 元素中某一属性
                 'list2.0.b': 33,
             }
         })
         ```
   
       - 更新数组==操作符==
       
         ```js
         // 集合中记录
         {
             "list": [10, 20, 30]
         }
         
         const _ = db.command
         testdoc.where({
             _id: 'xxx'
         }).update({
             data: {
                 // push操作 如果字段不存在 则创建 并设为数组 再插入值
                 // 末尾插入一个元素
                 list: _.push('1'),
                 // 末尾插入多个元素
                 list: _.push([1, 2]),
         		// 从第二个位置开始插入
                 list: _.push({
                     each: [1, 2],
                     position: 1
                 }),
                 // 插入吼对数组排序
                 list: _.push({
                     each: '1',
                     sort: 1,
                 }),
                 // 插入后只保留后两个元素
                 list: _.push({
                     each: 1,
                     slice: -2,
                 }),
                 // 不插入保留前两个元素
                 list: _.push({
                     each: [],
                     slice: 2,
                 }),
                 // 数组尾部元素删除
                 list: _.pop(),
                 // unshift操作同push 字段不存在 则创建后再插入值
                 // 数组头部插入一个或多个值
                 list: _.unshift([1, 2]),
                 // 删除数组头部元素
                 list: _.shift(),
                 // 给定值或查询条件 将数组中匹配的元素移除
                 // pull可以传入对象和常量 但只能有一个值
                 list: _.pull(20),
                 // pullAll只能传入常量 但只能有多个值(数组)
                 list: _.pullAll([10, 20]),
                 // 给定一个或多个元素 只有数组中不存在相同元素时添加
                 list: _.addToSet(40),
                 list: _.addToSet({
                     $each: [40, 50]
                 })
             }
         })
       
       - 更新数组字段时用`字段路径.$`来表示更新数组字段的==第一个满足匹配条件的元素==
       
         - 注：查询条件**必须**包含该数组字段
         - 如果是==对象数组==的话，则是`字段路径.$.字段路径`
         - 不支持数组嵌套数组
       
         ```js
         // 集合中记录
         {
           "_id": "doc1",
           "list": [10, 20, 30]
         }
         {
           "_id": "doc2",
           "list": [20, 20, 40]
         }
         // 所有list中第一个20的元素更新为25
         testdoc.where({
             list: 20
         }).update({
             data: {
                 'list.$': 25
             }
         })
         ```
       
       - 更新数组中==所有匹配的元素==用`字段路径.$[]`
       
         - 注：查询条件中不可用！
       
         ```js
         // 集合中记录
         {
             "list": [
                 {"score": 10},
                 {"score": 20},
                 {"score": 30},
             ]
         }
         // list中所有score加10
         testdoc.where({
             'list.score': _.gte(20)
         }).update({
             data:{
                 'list.$[].score': _.inc(10) //所有匹配的score自增10
             }
         })
         ```
       
       - 更新多重嵌套数组和对象
       
         ```js
         // 集合中记录
         {
             "list": [
                 {"numbers": [10, 20, 30]},
                 {"numbers": [50, 60, 70]},
             ]
         }
         // 更新所有所有匹配结果中list第2项的numbers的第2项为30
         testdoc.where({
             'list.numbers': _.gte(20)
         }).update({
             data:{
                 'list.1.numbers.1': 30
             }
         })
   
   - 删除数据
   
     - 通过文档引用删除该条数据
   
       ```js
       const specialLog = testdoc.doc('记录id')
       specialLog.remove({
           success(res){}
       })
       ```
   
     - 删除多条记录，只能通过云函数操作
   
       ```js
       // 引入云函数
       const cloud = require('wx-server-sdk')
       const db = cloud.database()
       db.collection('testdoc').where({
           cusKey1: 'xxx'
       }).remove().then()

- Tips
  - 同一个用户在同一个小程序(`AppID`)中的`_openid`是不变的，且唯一，用于识别用户身份
  - ==前端==只能用`doc('id')`方法
    - `then`和`await`返回值中`data`才是返回数据
  - ==后端==可以用`collection('xx').doc(id)`、`where({})`等方法
    - `then(res)`等取得的`res`结果中的`data`字段才是返回值

## 云开发函数方法

- `count()`

  - 统计集合记录总数或查询结果的记录数

    ```js
    // res是对象 其中total为记录总数
    testdoc.where({...}).count().then(res => res.total)
    testdoc.count().then(res => res.total)
    ```

- `watch()`

  - 监听集合中符合查询条件的数据的更新事件

    ```js
    testdoc.watch({
        // 数据库发生变化时触发
        onchange(res){
            // docChanges发生变化的数据
            // docs最新数据
        },
        // 失败回调
        onError(err){}
    })
    ```

- `limit(num)`取前`num`条

  - 同mongoose中`limit`
  - 例`db.collection('test').limit(10).get().then().catch()`

- `skip(num)`跳过前`num`条

  - 同mongoose中`skip`
  - 例`db.collection('test').skip(10).limit(20).get().then().catch()`

- `orderBy('字段路径', '排序方式')`排序

  - 可以用==点表示法==表示嵌套字段，如`'style.color'`
  - 排序方式只能取`asc`或`desc`
  - 可以按多个字段排序。例`db.collection('test').orderBy('age', 'desc').orderBy('asset', 'asc').get().then().catch()`

- `field({字段:true|false})`只返回记录中所需的字段

  - 传入的对象中`key`表示要返回或不要返回的字段，`value`填`true|false`或`1|-1`

  ```js
  db.collection('test').field({
    age: true,
    name: true
  })
    .get()
    .then(console.log)
    .catch(console.error)

## 云开发操作符

- `exists(boolean)`判断字段是否存在

  ```js
  db.collection('test').where({
    age: _.exists(true)
  }).get()
  ```

- `all()`要求数组字段中包含==给定数组==的所有元素

  ```js
  db.collection('test').where({
    list: _.all(['xxx1', 'xxx2']) // 筛选list中有'xxx1'和'xxx2'的
  }).get()

- `elemMatch({条件})`要求数组中包含==至少一个==满足**所有**给定条件的==元素==

  - 注：返回值不是符合条件的数组，是符合条件的元素组成的数组

  ```js
  // 集合记录
  {
    "_id": "a0",
    "city": "x0",
    "places": [{
      "type": "garden",
      "area": 300,
      "age": 1
    }, {
      "type": "theatre",
      "area": 50,
      "age": 15
    }]
  }
  // 找出至少同时包含"area大于100且age小于2"的元素
  db.collection('test').where({
    places: _.elemMatch({
      area: _.gt(100),
      age: _.lt(2),
    })
  }).get()

- `size(num)`要求数组长度为给定值

  ```js
  db.collection('test').where({
    list: _.size(2) // 筛选数组长度为2的
  }).get()
  ```

- `inc(num)`自增。`num`可正可负，为负则是自减

  - 用于更新操作，见云开发更新示例

- `push(array|object)`用于更新数组，往数组中添加一个或多个值

  ```js
  // 传入数组
  db.collection('test').where({...}).update({
    data: {
      list: _.push(['xxx1', 'xxx2']) // 往数组中添加2个元素
    }
  })
  // 传入对象
  // 在数组第二个位置开始插入
  db.collection('test').doc('id').update({
    data: {
      list: _.push({
        // each表示插入元素
        each: ['xxx1', 'xxx2'],
        // position表示插入位置索引 从0开始
        position: 1,
        // sort对数组排序
        sort: 1, // 升序
      })
    }
  })
  ```

  - 如果是==对象数组==，可以根据元素==对象里的字段==进行排序

    ```js
    db.collection('test').doc('id').update({
      data: {
        list: _.push({
          each: [
            { name: 'xxx1', age: 18 },
            { name: 'xxx2', age: 60 },
          ],
          sort: {
            age: 1, // 根据age升序排列
          },
        })
      }
    })
    ```

  - 插入后**只**保留后2个元素

    ```js
    db.collection('test').doc('id').update({
      data: {
        list: _.push({
          each: ['xxx1', 'xxx2'],
          slice: -2, // 负数表示从后往前数n个 从1|-1开始计
        })
      }
    })

## 云函数

- 需要在==服务端==运行

  1. 在`project.config.json`文件中配置

     - 指定本地文件夹作为云开发==根目录==

     ```json
     {
         "cloudfunctionRoot": "cloudfunctions/"
     }
     ```

  2. 在云函数根目录上右键，选择`创建一个新的Node.js云函数`

  3. 在该云函数文件夹中的`index.js`中使用云函数创建接口

     - 注！调用云函数时==传参==，`event`就完全等于传入的`{key:value}`对象，**但是**没有传参，`event`**不是**`{}`而是默认参数`{userInfo:{appId:..., openId:...}}`

     ```js
     // 引入云函数工具库
     const cloud = require('wx-server-sdk')
     // 初始化环境
     cloud.init()
     // 连接数据库
     const db = cloud.database()
     // 收到请求后的业务逻辑
     exports.main = async (event, context) => {
         // event是前端调用接口时传入的参数 {params: value}
         // context是服务运行情况
         return await db.collection('test').where({...}).get()
     }
     ```

  4. 右键该云函数文件夹，选择`上传并部署：云端安装依赖`，才算真正完成云函数

  5. 在小程序页面中调用接口

     - 注：`result`才是返回值

     ```js
     wx.cloud.callFunction({
         name: 'getData', // 接口名
         // 通过data传数据给event
         data: {
             key: value
         }
     }).then(res => {
         // res中result即接口返回的结果对应第3步中return返回的值
     })
     ```

  6. 获取小程序用户信息

     - 调用`wx-server-sdk`提供的`getWXContext`可以获取到`openid`等信息

     ```js
     const cloud = require('wx-server-sdk')
     exports.main = async (event, context) => {
       // 这里获取到的 openId、 appId 和 unionId 是可信的，注意 unionId 仅在满足 unionId 获取条件时返回
       let { OPENID, APPID, UNIONID } = cloud.getWXContext()
       return {
         OPENID,
         APPID,
         UNIONID,
       }
     }
     ```

  7. 云函数中调用其他云函数。写法同前端一样，只不过不再用`wx.cloud`

     ```js
     const cloud = require('wx-server-sdk')
     cloud.init()
     exports.main = async (event, context) => {
       return await cloud.callFunction({
         name: 'sum',
         data: {
           x: 1,
           y: 2,
         }
       })
     }
     ```

  8. 打开`云开发`选择云函数，勾选本地调试，安装完`node`模块后即可本地调试云函数

     - 可以选择通过模拟器事件触发云函数，也可以通过手动输入JSON，传参和触发
     - 本地调试==无需上传部署==，在本地保存修改后即可触发、调试

- Tips

  - 使用`cloud.callFunction`不能自己调自己！
    - 例：有这样一个流程，修改订单——查询用户名下订单统计金额——更新用户信息中的支出——订单修改完成。订单接口具有增删改查功能，调用==订单接口==的改时，需要调用==统计接口==重新统计用户名下订单总计金额，而==统计接口==又复用了==订单接口==的查功能，在这一步，`cloud.callFunction`会直接抛出异常，猜测是因为第一次调用订单接口还在等待统计接口返回结果，但是订单接口又被调用导致的异常


## 云函数-事务

- 跨集合或记录的操作，要么一起成功，要么一起失败。如银行从A账户扣款，给B账户打款，如果B账号操作失败，那么理应A账户的扣款要还回去，这就需要用到事务

- 事务是数据库的==能力==，由Mongoose、微信云开发等框架提供与数据库交互的API，它不是给==操作过程==加锁，而是给==一系列操作相关联的数据库集合==上锁，而为了记录操作，就需要用==事务对象==去操作，但也不是必须用事务对象操作集合，比如查数据，不涉及回滚，就正常的用集合对象操作即可。

  - 需要用事务对象的操作，只有==增删改==，因为涉及到某一步操作失败回滚数据
  - 也不是必须用`try{}catch(err){}`，官方示例中是因为没有用`catch`等捕获==单个操作==的异常，如果是自己手动捕获异常以及对参数校验返回失败结果的话，不需要`try catch`，根据返回结果判断==提交事务==还是==回滚==即可

- 事务过程采用==快照隔离==

  1. 读操作返回的是==快照==，而非实际数据
  2. 写操作会
     1. 改变快照，保证接下来读操作的一致性
     2. 给正在操作的记录对象加事务锁
  3. 事务锁
     - 如果对象存在事务锁，==其他事务==写操作会直接失败
     - 更新操作会阻塞，直到事务锁释放或者超时
  4. 事务提交后，对快照的操作会写入数据库

- 事务**仅支持**==单记录==操作

  - 即不能用`obj.where(条件)`，仅能用`obj.doc('记录id')`和`obj.add()`
  - 这是为了避免大量上锁导致冲突，以及确保运行效率
  - 如果需要多记录操作，可以用`Promise.all(list)`等方法同时对==多个单记录==进行操作

- `startTransaction`：==自定义==流程控制方式

  ```js
  const cloud = require('wx-server-sdk')
  cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV })
  const db = cloud.database()
  
  exports.main = async (event) => {
      const transaction = await db.startTransaction()
      let res1 = await transaction.collection('orders').add({
          data: {
              // ...
          }
      }).then(res => true, err => false)
      if (!res1) {
          await transaction.rollback()
          return {msg: '添加订单失败', code: 400}
      }
      let res2 = await transaction.collection('users').doc('_id').update({
        data: {
          // ...
        }
      }).then(res => res.data, err => false)
      if (res2){
          await transaction.commit()
          return {msg: '更新用户信息成功', code: 200}
      } else {
          await transaction.rollback()
          return {msg: '更新用户失败', code: 400}
      }
  }
  ```

- `runTransaction`：简易、冲突自动重试方式

  - `db.runTransaction(callback, times)`
    - `times`是事务冲突重试次数，其他异常时不会重试，可以不传，默认3次

  ```js
  try {
      let result = await db.runTransaction(async transaction => {
          let res1 = await transaction.collection('orders').add({
              // ...
          })
          let res2 = await transaction.collection('users').doc('_id').update({
              // ...
          })
          if(res1.data && res2.data) {
              return {msg: 'success', code: 200}
          } else {
              // 传入参数会作为runTransaction reject的结果
              await transaction.rollback({msg: 'err', code: 400})
          }
      // 重试次数
      }, 3)
      return result
  } catch(err) {
      return {msg: 'err', code: 400}
  }

## 云函数-聚类

- ```js
  const db = wx.cloud.database()
  // 聚类操作符
  const $ = db.command.aggregate
  // aggregate()方法开启聚类
  db.collection('books').aggregate()
  // group 分组方法
    .group({
      // _id是固定字段 表示按$后的字段名分组
      _id: '$category',
      // _id也可以是对象 表示按 category + author 进行分组
      _id: {
          category: '$category',
          author: '$author',
      }
      // 以下是自定义字段 表示添加到分组生成的对象上的 新字段
      // 让输出的每组记录有一个 avgSales 字段，其值是组内所有记录的 sales 字段的平均值
      avgSales: $.avg('$sales')
    })
    .end()

## 云函数-定时任务

- 如用户订单时效等需要定时任务来更新记录

- 会在相应时间点==自动==触发，函数返回值不会返回给调用方

- 在云函数下`config.json`

  ```json
  {
    // triggers是固定字段
    // 触发器数组，目前仅支持一个触发器，即数组只能填写一个，不可添加多个
    "triggers": [
      {
        // name: 触发器的名字
        "name": "myTrigger",
        // type: 触发器类型，目前仅支持 timer (即 定时触发器)
        "type": "timer",
        // config: 触发器配置，在定时触发器下，config 格式为 cron 表达式，规则见下方说明
        "config": "0 0 2 1 * * *"
      }
    ]
  }
  ```

- cron表达式规则

  - | 第一位       | 第二位         | 第三位         | 第四位                      | 第五位                 | 第六位                       | 第七位            |
    | ------------ | -------------- | -------------- | --------------------------- | ---------------------- | ---------------------------- | ----------------- |
    | 秒(0-59整数) | 分钟(0-59整数) | 小时(0-23整数) | 日(1-31整数),需考虑月的天数 | 月(1-12整数或简写字符) | 星期(0-6整数,0指周日6指周六) | 年(1970-2099整数) |

  - 通配符`,-*/`

    - `,`用逗号隔开的字符取并集
      - 例：`0 0 1,2 * * * *`表示，每天1点和2点
    - `-`指定范围
      - 例：`0 0 5 1-15 * * * `表示，每月的1号到15号，每天5点
    - `*`表示所有值
      - 例：`0 0 * 1-15 * * *`表示，每月的1-15号，每小时执行
    - `/`增量
      - 例：`0 0 0/2 * * * *`表示，每天从0点开始间隔2小时就执行一次，如0点、2点、4点

## loading遮罩

```js
// 显示遮罩
wx.showLoading({
  title: '加载中',// 加载时显示内容
  mask: true,// 透明遮罩 防止加载时点击 默认false
})

// 隐藏遮罩 不使用不会消失
wx.hideLoading()
```

## 使用iconfont图标

1. 在[iconFont图库](https://www.iconfont.cn/)将选中的图表假如购物车

2. 点击购物车`添加至项目`

3. 进入项目后选择使用==Unicode==等方式，再点击`生成链接`

4. 打开链接后复制内容保存到本地

5. 推荐在`app.wxss`中全局引入样式表`@import '/static/icon.wxss'`

6. 在`.wxml`中使用

   ```html
   <view class="iconfont icon-a-013_dianhua"></view>

## 使用echarts

1. 下载[echarts-for-weixin](https://github.com/ecomfe/echarts-for-weixin/tree/master)项目

2. 确认对应的是什么版本的echarts，这影响到后续到echarts官网定制下载时替换文件的版本

3. 进入[echarts官网](https://echarts.apache.org/examples/zh/index.html#chart-type-pie)定制自己需要的图表，选择与`echarts-for-weixin`项目对应的版本

4. 找到下载的`echarts.min.js`，==更名为==`echarts.js`替换原文件里的`echarts.js`

   - 注意！新版小程序优化了canvas，echarts中也支持了新版小程序，但是`ec-canvas.js`中`isUseNewCanvas: false`变量值还是false，无法渲染`ec-canvas.wxml`中新版canvas`<canvas type="2d" wx:if="{{isUseNewCanvas}}">`，所以要将`isUseNewCanvas`值改为`true`！

5. 引入echarts

   ```js
   import echarts from '../echarts/echarts.min.js'
   function fn(canvas, width, height){
       let chart = echarts.init(canvas, null, {
           width: width,
           height: height,
       })
       canvas.setChart(chart)// 通过wxml绑定ec属性这句是必须的
       let options = {
           xAxis: {
               type: 'category',
               data: ['1','2','3'],
           },
           yAxis: {
               type: 'value'
           },
           series: [{...}]
       }
       chart.setOption(option)
       return chart //注！必须要返回实例化对象
   }
   ```

6. 在`data`里

   - 此处并不执行`fn`，而是将`fn`函数体赋值给`onInit`属性，在`wxml`引用`<ec-canvs>`标签上通过`ec="{{echart}}"`将对象绑定上去，组件会自动执行里面的`onOnit`函数，函数中`canvas`等参数是自动传入的

   ```js
   data: {
       echart: {
           onInit: fn,//注！必须是对象中含onInit字段，固定写法，在wxml中绑定
       }
   }
   ```

7. `.json`文件中引入插件

   ```json
   {
       "usingComponents": {
           "ec-canvas": "/components/echarts/ec-vanvas"
       }
   }
   ```

8. `wxml`文件中数据绑定

   - `canvas-id`以及`ec`都是必写的标签属性

   ```html
   <view class="ec_box">
   	<ec-canvas canvas-id="echart-bar" ec="{{echart}}"></ec-canvas>
   </view>
   ```

9. `wxss`文件中给容器设置宽高

   ```css
   .ec_box{
       width: 100%;
       height: 400rpx;
   }
   ```

- Tips

  - 微信小程序使用echarts方式与html的不同

    - html + Vue

      1. 引入echarts库

      2. 再获取页面元素节点`let dom = document.getElementById('id')`
      3. 保存echart实例对象`this.echartDom = echarts.init(dom)`
      4. 配置`options`选项，并`this.echartDom.setOption(option)`
      5. 需要更新图表时再执行`this.echartDom.setOption(newOption)`即可

    - 微信小程序

      1. 引入echarts库，放在`components`组件文件夹下作为组件引用

         - 注！一定要在对应页面的`.json`文件夹中配置组件！

           ```json
           {
               "usingComponents": {
               	"ec-canvas": "../../ec-canvas/ec-canvas"
             	}
           }
      
      - 方式1
      
        - 在页面元素使用组件引入，并通过`ec="{{ec}}"`绑定初始化函数
      
      - 方式2
      
        1. 获取组件节点`let dom = this.selectComponent('#mychart')`
      
        2. 通过组件对象的`init`方法创建
      
           - 推荐用这种方法，即与html方式类似，又可以保留echart实例对象便于后续更新
      
           ```js
           lifetimes: {
               // ready是组件布局完成后执行 即可以获取到元素节点
               ready(){
                   let dom = this.selectComponent('#muchart')
                   dom.init((canvas, width, height, dpr) => {
                       this.chart = echarts.init(canvas, null, {
                           width: width,
                           height: height,
                           devicePixelRatio: dpr
                       })
                       // 通过组件实例初始化就不需要canvas.setChart(this.chart)了
                       let options = {...}
                       this.chart.setOption(options)
                       return this.chart// 必须要返回实例对象
                   })
               }
           }
           // 需要更新数据时 在触发方法中
           this.chart.setOption({
               series: [
                   data: newData
               ]
           })

## input组件

- `value="{{value}}"`属性是用于在页面上==回显==的！
  - 虽然标签**没有**`value`属性不影响`event.detail.value`来获取`<input>`类型组件的值，**但是**没有`<input value="{{value}}"/>`就没法在页面显示，即使用`this.setData()`也不行
- `type="number"`得到的值也是`string`类型

## animation动画

1. 首先在要放大的元素上添加`animation`属性

   ```html
   <view id="xxx" animation="{{animationData}}" style="..."></view>
   ```

2. 创建动画实例对象

   - `step()`表示一组动画，一组动画中可以调用多个==动画方法==，这些方法是同时进行。一组动画完成才会进行下一组动画

   ```js
   Page({
       data: {
           animationData: null
       },
       onLoad(){
           // 创建动画实例
           this.animation = wx.createAnimation({
               duration: 1000,
               timingFunction: 'ease',
           })
           // 初始缩放比例
           this.scale = 1
       },
       // 手指触碰屏幕事件 记录起始距离
       touch_start(e){
           let startX1 = e.touches[0].clientX;
           let startY1 = e.touches[0].clientY;
           let startX2 = e.touches[1].clientX;
           let startY2 = e.touches[1].clientY;
           // 求两点间直线距离 即平方根
           this.start_distance = Math.sqrt(
               Math.pow(Math.abs(startX2 - startX1), 2) +
               Math.pow(Math.abs(startY2 - startY1), 2)
           );
           // 调用step()表示这是一组动画
           this.animation.scale(this.scale).step();
           // 修改animationData执行这组动画
       	this.setData({
               // export()导出动画队列，每次调用会清除掉之前的动画操作
               animationData: this.animation.export()
           });
       },
       // 手指移动时计算拉伸比例
       touch_move(e){
           let moveX1 = e.touches[0].clientX;
           let moveY1 = e.touches[0].clientY;
           let moveX2 = e.touches[1].clientX;
           let moveY2 = e.touches[1].clientY;
           let move_distance = Math.sqrt(
               Math.pow(Math.abs(moveX2 - moveX1), 2) +
               Math.pow(Math.abs(moveY2 - moveY1), 2)
           );
           // 计算缩放比例
           this.scale = move_distance / this.start_distance
           this.animation.scale(this.scale).step();
           this.setData({
               animationData: this.animation.export()
           });
       },
       // 手指移动结束保持缩放比例
   })

## 批量上传

1. 调用`wx.chooseMedia`选择图片等媒体文件

   ```js
   wx.chooseMedia({
     count: 9,//最多选择文件数
     mediaType: ['image','video'],//文件类型
     sourceType: ['album', 'camera'],//文件来源 相册和相机
     maxDuration: 30,//拍摄视频最长时长
     camera: 'back',//使用前置还是后置摄像头
     success(res) {
       // 成功回调 返回文件信息数组
       console.log(res.tempFiles[0].tempFilePath)//本地文件临时路径
       console.log(res.tempFiles[0].size)//文件大小
     }
   })
   ```

2. `wx.cloud.uploadFile`只能单个上传，封装使其可以批量上传

   - 注：上传同名、同路径文件会替换对应文件

   ```js
   // 传入文件列表 云存储路径
   async function uploadFile(list, cloud_path){
       // 加载遮罩
       let task = []//存储异步上传任务
       for(let val of list){
           let p = wx.cloud.uploadFile({
             cloudPath: `${cloud_path}/${val.fileName}`,
             filePath: val.filePath
           }).then(res => {
               // 上传成功一个就调接口往数据库里存一个
               wx.cloud.callFunction({
                   name: 'file_path',
                   data: {
                       file_name: val.fileName,
                       file_path: res.fileID
                   }
               })
               // 返回值中fileID即云存储文件路径 可直接放于image等标签显示
               return res.fileID
           }).catch(err => {
               return 'err'
           })
           task.push(p)
       }
       let res = await Promise.all(task).catch(err => 'err')
       // 全部上传结束(无论成功与否)关闭遮罩
       if(res !== 'err'){
          // 如果是数组说明全部上传成功
       }
   }
   ```

## 隐私协议

- [开发指南](https://developers.weixin.qq.com/miniprogram/dev/framework/user-privacy/PrivacyAuthorize.html#%E4%BA%94%E3%80%81%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E8%AF%B4%E6%98%8E)