## 小程序特点

- 没有DOM

- 使用组件化开发，类似Vue单文件

- 项目体积不能超过2M，否则无法上线

- 文件功能

  - `.js`逻辑功能
  - `.wxml`视图结构，同`.html`
  - `.wxss`样式，同`.css`
  - `.json`存储数据

- 使用`rpx`适配方案，而不是`rem`

  - 单位：`rpx`
  - 规定任何屏幕==宽度==都为`750rpx`
    - 例：`375px`宽度的手机屏，它的`1rpx = 0.5px`，在写样式时`50px`的元素就可以设置为`100rpx`

  - 小程序会根据屏幕宽度自动计算`rpx`

- 项目最外层必须要有`app.js`

  - 用途：注册整个小程序应用
- 单个页面下使用`Page({配置项})`配置数据，类似Vue的`new Vue({配置项})`
- 没有全局对象`window`，取而代之的是`wx`
- 更新迭代很快，有的方法已经废弃，详情见[官网](https://mp.weixin.qq.com/)
- `wxml`页面元素上绑定变量使用`<image src="{{userInfo.icon}}">`
- 样式
  - 不能`*{...}`给全部元素设置样式
- `wxml`中的`{{ }}`语法**只能**填入`data:{}`中定义的属性，不能用函数返回值作为其内容
- 创建项目时`AppID`不变，用户的`_openid`就不会变


## 文件结构

- `app.wxss`公共样式

- `app.json`全局配置

  - 如：页面文件路径、窗口样式、网络超时时间等

    ```json
    {	// 在任一级目录下"新建 Page"会自动在此添加文件路径
        "pages": ["pages/index/index"]
    }

- `app.js`入口文件

- 单独页面文件夹下
  - `xxx.json`表示==当前==页面==配置==
    - 如：当前页名称
    - 配置项名和`app.json`相同，**但是**不需要在`window`下写，直接写最外层即可
  - `xxx.wxss`、`xxx.wxml`、`xxx.js/ts`当前页样式、结构、逻辑

## 静态页面

- `<view>`等于`<div>`

- `<text>`等于`<span>`

- 所有页面外层都包裹着`<page>`作为根节点，但是`<page>`默认没有高度，由内部元素撑开，所以需要在`app.wxss`或者`app.less`设置==公共样式==

  ```less
  page{
      height: 100%;
  }

## 数据绑定

- 小程序
  - `data:{}`中==初始化==数据
  - 修改数据：`this.setData({key: newValue})`
    - 修改数据是==同步==执行
  - 没有数据代理
    - `this.data.xxx`取数据
    - 只有通过`setData`修改的数据才能回显到页面
  - 数据流
    - 只有`Model -> View`
      - 后续更新支持了双向绑定，但是不支持`对象.属性`的写法
- Vue
  - `data(){return {}}`中初始化数据
  - 修改数据：`this.key = value`
  - 数据流
    - 双向数据绑定：`Model <--> View`
- React
  - `state`中初始化状态数据
  - 修改数据：`this.setSate()`
    - 在生命周期函数中是==异步==执行
    - 非生命周期函数中是==同步==执行
  - 数据流
    - 只有`Model -> View`

## 获取页面节点信息

- 事件对象只有==相对==位置

- 获取节点使用`createSelectorQuery()`

  - 自定义组件或当前页面使用`this.createSelectorQuery()`

  - 全局获取节点才用`wx.createSelectorQuery()`

    ```js
    let query = this.createSelectorQuery()
    let dom = query.select('#id/.class/view等')
    dom.boundingClientRect(res => {
    	console.log('相对视窗的绝对定位', res)
    })
    dom.scrollOffset(res => {
    	console.log('滚动距离', res)
    })
    // 关键 必须要执行才能获得上述节点信息
    query.exec()

## 事件绑定

- 小程序分==冒泡事件==和==非冒泡事件==

- `bind`绑定事件会冒泡

  ```html
  <view bindtap="fn">屏幕点击事件</view>
  ```

- `catch`绑定事件**不会**冒泡

  ```html
  <view catchtap="fn">屏幕点击事件</view>

- 事件回调放置在生命周期函数同级

  ```ts
  Page({
      data:{},
      onLoad:{}.
      ...
      fn(){}
  })
  ```

- `wxml`绑定事件传入自定义参数

  - 小程序中绑定事件不能用`bindtap="fn(参数)"`这种形式，但是`bindtap="fn"`绑定事件，`fn`只会有`event`一个参数

  - 因此同一事件方法想传入自定义参数进行区分操作，就需要用`data-*`属性

    ```html
    <button catchtap="fn" data-cc="test"></button>
    ```

  - `event`中`target`、`currentTarget`都有`dataset`属性

    - `target`不一定是==绑定==事件的元素，有可能是子元素冒泡到的父元素
    - `currentTarget`要求绑定事件的元素一定是触发事件的元素
    
    ```js
    fn(event){
        console.log(event)
        // 打印的event
        {
            target: {
                dataset: {
                    cc: 'test'
                },
                ...
            },
            ...
        }
    }
    


## 路由跳转

- 需要调用API跳转

  - 路径只能是`app.json`里的绝对路径或相对路径
    - 路径不能带有`.wxml`后缀，只能用`/pages/目录/index`或`../目录/index`这种形式

  ```ts
  turnToPage(){
      // 保留当前页面跳转 跳转后有返回按钮
      wx.navigateTo({
          url: '/pages/logs/logs'
      })
      // 关闭当前页跳转 跳转后只有返回首页按钮
      wx.redirectTo({...})
   	// 关闭所有页面跳转 跳转后只有返回首页按钮
      wx.reLaunch({...})
  }
  ```

- 传参仅支持`query`参数

  - 但是`url`传参长度有限制

  ```js
  turnToPage(){
      wx.navigateTo({
          // 不建议用这种方式传数据量比较大的，建议配合后端服务传一个id过去调接口查询
          url: '/pages/logs/logs?key=' + value
      })
  }

## 生命周期

- 页面==线程==和逻辑==线程==交互的时机

  ![img](https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png)

- 返回首页或前一页会销毁当前页`onUnload()`
  - 返回前一页只会触发`onShow()`
  - 返回首页会触发`onLoad()`、`onShow()`、`onReady()`

## 条件渲染

- 形如`v-if`的渲染方式，为`false`的不会挂载在页面上

  ```html
  <view wx:if="{{showFlag === 1}}"></view>
  <view wx:elif="{{showFlag === 2}}"></view>
  <view wx:else></view>
  ```

- 形如`v-show`的渲染方式，为`false`只会隐藏，但元素还在页面

  ```html
  <view hidden="{{true}}">测试hidden是否会挂载到页面</view>

## 列表渲染

- `wx:key="itemKey"`可以直接绑定数组元素属性

  ```html
  <view wx:for="{{array}}" wx:key="id"></view>
  ```

  ```ts
  data:{
      array:[
          {id:1, value:'xxxx'},
          {id:2, value:'aa'},
          {id:3, value:'vv'},
      ]
  }

## 组件

1. 新建`Component`，写结构、逻辑、样式

   ```ts
   Component({
       // 等同Vue中的props 详见官方文档-框架接口-自定义组件
       properties: {
           title: {
               type: String, //数据类型
               value: 'xxx', //属性初始值
           },
           // 简写属性
           content: String
       },
   })

2. 编辑使用组件页面对应的`xxx.json`文件

   ```json
   {
       "usingComponents": {
           // "组件名": "/文件夹/文件夹/文件名"
           "navHeader": "/components/header/header"
       }
   }

3. 在页面使用不需要将驼峰式转为短横线

   ```html
   <navHeader title="xx" content="xx"></navHeader>

## WXML模板

- 形似组件，但是只有样式和`wxml`结构

1. 在新建`xxx.wxml`和`xxx.less/wxss`

   ```html
   <!-- wxml文件 -->
   <!-- 必须要有name 用于指定是哪个模板 -->
   <template name="myTemplate">
     <view>
       <!-- 模板结构中动态属性在使用页data中定义 随使用页定义属性动态变化 -->
       <text> {{index}}: {{msg}} </text>
       <text> Time: {{time}} </text>
     </view>
   </template>
   ```

2. 使用页引入模板`wxml`文件

   ```html
   <!-- 引入文件 -->
   <import src="/template/myTemplate/myTemplate.wxml"/>
   <!-- 使用模板 通过data往模板中传入使用页data定义的属性 -->
   <template is="myTemplate" data="{{...obj}}"></template>
   ```

3. 使用页样式文件中引入模板样式

   - 注：使用页样式会覆盖模板样式中同名的

   ```css
   @import "/template/myTemplate/myTemplate.wxss"

## 移动端通用触控相关属性方法

- 获取手指坐标

  ```ts
  hanleTouchStart(event){
      // touches表示几根手指触屏 一般取第一个手指
      startY = event.touches[0].clientY
  }

## 数据共享(页面通信)

- 通常JS文件中声明的变量和函数只在该文件中有效，但是通过`getApp`获取全局应用实例可以达到共享数据

  ```js
  // app.js
  app({
      customData: 12,
      globalData: {...},
      // 可以自定义函数用于存取共享数据
      fn(...params){
          this.customData = params
      }
  })
  
  // xx.js
  let app = getApp()
  app.customData++
  // 使用app实例中自定义方法获取其他页面存的数据
  console.log(app.customData) // ['参数1','参数2']
  
  // xx2.js
  let app = getApp()
  app.fn('参数1','参数2')

- 使用小程序API中==数据缓存==相关接口，利用本地缓存进行数据共享

- 如果一个页面由另一个页面通过 `wx.navigateTo`打开，这两个页面间将建立一条数据通道

  - ==被打开==的页面可以通过 `this.getOpenerEventChannel()` 方法来获得一个 `EventChannel` 对象

  - `wx.navigateTo` 的 `success` 回调中也包含一个 `EventChannel` 对象

    ```js
    // 跳转前页面
    wx.navigateTo({
        url: '...',
        // events中监听被打开页面发送到当前页面的数据
        events: {
            sonToParent(data){
                console.log('父页面收到的数据', data)
            }
        },
        // 成功跳转后的回调函数
        // 注意 仅只有success成功回调中才有EventChannel对象
        success(res){
            // 页面跳转后向被打开页面通信
            res.eventChannel.emit('parentToSon', {msg: '我是跳转前页面'})
        }
    })
    
    // 被打开页面
    onLoad(){
        this.hhh = this.getOpenerEventChannel()
        this.hhh.on('parentToSon', function(data){
            console.log(子页面收到的数据', data)
        })
    }
    customfn(){
        this.hhh.emit('sonToParent', '我是跳转页')
    }
    ```

## 分包

- 当代码打包超过上限`2M`时，就需要分包，将代码根据不同页面分成最大`2M`的一个个小包，总大小不超过`20M`左右

- 常规分包

  1. 在==根目录==下创建包文件夹。如`package1`、`package2`

  2. 将主包外的页面==文件夹==放入对应包文件夹

  3. 在`app.json`中配置

     - 未配置在`subpackages`中的其他页面文件夹作为==主包==
     - 分包页面文件路径不能出现在外层`pages`(主包)中
     - `subpackages`中`pages`分包路径是以分包文件夹为根目录

     ```json
     {
         "pages": ["pages/index/index"],
         "subpackages": [
             {
                 "root": "package2",
                 "pages": ["pages/userInfo/userInfo"]
             }
         ],
         ...
     }
     ```

  4. 修改页面文件中`navigateTo`等API路径

     - API跳转路径都是从项目根目录下查找

     ```js
     // index.js
     turnTo(){
         wx.navigateTo({
             url: '/package2/pages/userInfo/userInfo'
         })
     }

- 独立分包

  1. 相比常规分包，需要在`subpackages`中增加配置项`independent`

     ```json
     {
         "pages": ["pages/index/index"],
         "subpackages": [
             {
                 "root": "package2",
                 "pages": ["pages/userInfo/userInfo"],
                 "independent": "true"
             }
         ],
         ...
     }

  - 与常规分包的区别
    - 独立分包不需要加载主包，可单独访问分包内容
    - 独立分包不能依赖主包及其他分包内容

## 分包预载

- 进入某个分包页面时自动预下载可能需要的分包，提升进入后续分包页面的启动速度

  ```json
  {
      "pages": [],
      "subpackages": [],
      "preloadRule": {
        // 指定页面路径
        "pages/index": {
            // wifi(默认，仅wifi预下载) all(不限)
            "network": "all",
            // 进入页面后预下载分包名 分包名同subpackages中的root或name
            "packages": ["package2"]
        }
      }
  }

## 云开发

1. 使用云能力前，需要先在`app.js`初始化

   - `env `参数说明
     - `env` 参数决定接下来小程序发起的云开发调用`wx.cloud.xxx`会默认请求到哪个云环境的资源
     - 如不填则使用默认环境（第一个创建的环境）

   ```js
   App({
       onLaunch(){
           if(wx.cloud) {
             wx.cloud.init({
                 // 此处请填入环境 ID, 环境 ID 可打开云控制台查看
                 env: 'cloud1-xxx',
                 traceUser: true,// 固定写法
             })  
           }
       }
   })

2. 云能力初始化后想使用数据库API增删改查，需要先获取数据库引用

   ```js
   const db = wx.cloud.database()
   ```

3. 要操作集合，需要先获取它的引用

   ```js
   const testdoc = db.collection('testdoc')
   ```

4. 得到集合的引用后即可操作文档记录

   - 获取单条文档引用，用于对特定文档进行操作

     ```js
     const specialLog = testdoc.doc('记录id')
     ```

   - 往集合中插入数据

     ```js
     testdoc.add({
         // data表示需要新增的JSON数据
         data: {
             // _id: '可选项 自定义_id 多数场景使用数据库自动分配的_id即可',
             cusKey1: 'xxx',
             cusKey2: new Date(),
             cusKey3: new db.Geo.Point(113,23),// 添加地理位置
             cusKey4: {
                 cusKey5: 'aaa',
                 cusKey6: 10
             }
         },
         success(res){
         	// res是一个对象，其中_id字段表示刚创建的记录的id
     	}
     }).then(res => {
         // add对象中不传入success、fail、complete即Promise风格
     })
     ```

   - 查询数据

     - 通过文档引用

       ```js
       // 普通方式
       specialLog.get({
           success(res){
               // res.data包含该记录的数据
           }
       })
       // Promise风格
       specialLog.get().then(res => {
           console.log(res.data)
       })
       ```

     - 通过集合的`where`方法指定查询条件，再调用`get`方法返回满足条件的==记录==

       - `where`中每个字段和它的值构成一个匹配条件，各个字段间的关系是 `与`，即需同时满足
       - `key: value`全等匹配
   
       ```js
       testdoc.where({
           cusKey1: 'xxx',
           cusKey4: {
               cusKey5: 'aaa'
           }
           // 也可以用 点表示法 表示嵌套字段
           'cusKey4.cusKey5': 'aaa'
       }).get().then(res => )
       ```
   
     - 条件查询
   
       - 指令在`db.command`对象上
       - 指令都是函数形式，可以在`()`后连其他指令。如`_.gt(10).and()`
       - 可以多个字段进行`或`操作，只需要指令函数中传入==对象数组==`[{key:_.gt()}, {key2: _.lt()}]`，表示多个条件
   
       ```js
       const _ = db.command
       testdoc.where({
           // gt大于 gte大于等于 lt小于 lte小于等于 eq等于 neq不等于
           'cusKey4.cusKey6': _.gt(10),// 大于10的条件
           
           // and与 or或
           'cusKey4.cusKey6': _.gt(10).and(_.lt(30)),// 同时满足_.gt(10) _.lt(30)
           'cusKey4.cusKey6': _eq(0).or(_.eq(100)),// _.eq(0) 或 _.eq(100)
           
           // 枚举类型 in字段值在给定数组中 nin字段值不在给定数组中
           // _.and([obj1, obj2])表示多个查询条件必须同时满足
           // _.or([obj1, obj2])表示多个查询条件满足任一
           _.or([
           	{'cusKey4.cusKey6': _.gt(10}},
               // _.in([val1, val2])表示cusKey1值满足数组中任意一个元素
               {cusKey1: _.in(['xxx', 'yyy'])}
           ])
       }).get().then(res => )
       ```
   
     - 查询数组/对象
   
       - 匹配==数组==中的==元素==。可传入数组中存在的而元素来筛选
   
         ```js
         // 集合中记录
         {
             "list": [10, 20, 30]
         }
         // 匹配所有list字段中有20的记录
         testdoc.where({
             list: 20
         }).get()
         // 匹配数组
         testdoc.where({
             list: [10, 20, 30]
         }).get()
         // 匹配数组第n项元素 同数组下标
         testdoc.where({
             'list.1': 20
         }).get()
         ```
   
       - 数组也可以使用`lt`、`gt`等指令
   
         ```js
         // 集合中记录
         {
             "list": [10, 20, 30]
         }
         const _ = db.command
         testdoc.where({
             list: _.gte(20).and(_.lt(50))
         }).get()
         ```
   
       - 匹配==多层嵌套==的数组和对象
   
         ```js
         // 集合中记录
         {
             "list": [
                 {"numbers": [10, 20, 30]},
                 {"numbers": [50, 60, 70]},
             ]
         }
         // 查询集合中所有list字段中numbers字段中大于等于20的结果
         const _ = db.command
         testdoc.where({
             // 无需写下标 即表示遍历所有元素
             'list.numbers': _.gte(20)
         }).get()
         ```
   
     - 获取整个集合数据
   
       - 不建议通过`testdoc.get()`获取，因为上限20条
       - 建议用云函数获取，可以突破20条限制
       - `count()`计算集合/查询结果总数
       - `skip`跳过n条数据
       - `limit`取前n条数据
   
       ```js
       // 例 后端做分页查询接口 需要将数据全查计算总数并分页返回
       // 引入云函数
       const cloud = require('wx-server-sdk')
       cloud.init() // 同wx.cloud一样要初始化后才能使用
       // 连接数据库
       const db = cloud.database()
       const max_limit = 100
       const testdoc = db.collection('testdoc')
       async function get_data(pageNum, pageSize){
           // 先计算记录总数
           let {total} = await testdoc.count()
           // 计算分几页 向上取整
           // let pageNums = Math.ceil(total / max_limit)
           // 返回查询结果
           return await testdoc.skip((pageNum-1)*max_limit).limit(max_limit).get()
       }
   
   - 更新数据
   
     - `update`局部更新一个或多个文档
   
       - 注：更新==多条==记录必须在==服务器端==用==云函数==操作！以下示例中修改多条都是在服务器端。前端只能用`doc('id')`或者修改单条数据
       - ==只有指定字段会更新==，其他字段不受影响
   
       ```js
       // 服务器端环境
       // 引入云函数工具库
       const cloud = require('wx-server-sdk')
       const db = cloud.database()
       const _ = db.command
       const testdoc = db.collection('testdoc')
       testdoc.where({'cusKey4.cusKey6': _.gt(10)}).update({
           // data 传入需要局部更新的数据
           data: {
               cusKey1: 'yyy',// 表示将cusKey1值改为'yyy'
           },
           success(res){}
       })
       ```
   
     - 操作指令
   
       - 指令都在`db.command`对象上
   
         ```js
         testdoc.where({cusKey1: 'xxx'}).update({
             data: {
         		// set设置为指定值 remove删除字段 inc自增 mul自乘
         		// 字段值为数组时 push往末尾添加值 pop删除末尾元素 shift删除头部元素 unshift头部增加值
                 'cusKey4.cusKey6': _.inc(10)
             },
             success(res){}
         })
   
       - `_.set`指令
   
         - `_.set`的用处在于更新一个值为一个对象。如下例是更新`cusKey4.cusKey5`字段值为`'ttt'`，而不是把`cusKey4`字段值更新为`{cusKey5: 'ttt'}`对象
   
           ```js
           data: {
               cusKey4: {
                   cusKey5: 'ttt'
               }
           }
   
         - 如果要整个==替换==`cusKey4`对象，就需要使用`_.set`指令
   
           ```js
           data: {
               cusKey4: _.set({
                   cuskey7: 11
               })
           }
   
     - `set()`==替换==整条==记录==，使用传入对象替换指定记录
   
         - 如果指定ID的记录不存在，则会自动新建记录，该记录拥有指定ID
   
           ```js
           const specialLog = testdoc.doc('记录id')
           specialLog.set({
             data: {
                 cusKey7: 'sss'
             }
           }).then()
   
     - 更新数组/对象
   
       - **只**更新==数组==中某一项元素
   
         ```js
         // 集合中记录
         {
             "list": [10, 20, 30]
         }
         
         testdoc.where({
             list: [10, 20, 30]
         }).update({
             data: {
                 'list.1': 50 //将list第二个元素20改为50
             }
         })
         ```
   
       - 更新数组字段时用`字段路径.$`来表示更新数组字段的==第一个满足匹配条件的元素==
   
         - 注：查询条件**必须**包含该数组字段
         - 如果是==对象数组==的话，则是`字段路径.$.字段路径`
         - 不支持数组嵌套数组
   
         ```js
         // 集合中记录
         {
           "_id": "doc1",
           "list": [10, 20, 30]
         }
         {
           "_id": "doc2",
           "list": [20, 20, 40]
         }
         // 所有list中第一个20的元素更新为25
         testdoc.where({
             list: 20
         }).update({
             data: {
                 'list.$': 25
             }
         })
         ```
   
       - 更新数组中==所有匹配的元素==用`字段路径.$[]`
   
         - 注：查询条件中不可用！
   
         ```js
         // 集合中记录
         {
             "list": [
                 {"score": 10},
                 {"score": 20},
                 {"score": 30},
             ]
         }
         // list中所有score加10
         testdoc.where({
             'list.score': _.gte(20)
         }).update({
             data:{
                 'list.$[].score': _.inc(10) //所有匹配的score自增10
             }
         })
         ```
   
       - 更新多重嵌套数组和对象
   
         ```js
         // 集合中记录
         {
             "list": [
                 {"numbers": [10, 20, 30]},
                 {"numbers": [50, 60, 70]},
             ]
         }
         // 更新所有所有匹配结果中list第2项的numbers的第2项为30
         testdoc.where({
             'list.numbers': _.gte(20)
         }).update({
             data:{
                 'list.1.numbers.1': 30
             }
         })
   
   - 删除数据
   
     - 通过文档引用删除该条数据
   
       ```js
       const specialLog = testdoc.doc('记录id')
       specialLog.remove({
           success(res){}
       })
       ```
   
     - 删除多条记录，只能通过云函数操作
   
       ```js
       // 引入云函数
       const cloud = require('wx-server-sdk')
       const db = cloud.database()
       db.collection('testdoc').where({
           cusKey1: 'xxx'
       }).remove()

- Tips
  - 同一个用户在同一个小程序(`AppID`)中的`_openid`是不变的，且唯一，用于识别用户身份

## 云开发函数方法

- `count()`

  - 统计集合记录总数或查询结果的记录数

    ```js
    // res是对象 其中total为记录总数
    testdoc.where({...}).count().then(res => res.total)
    testdoc.count().then(res => res.total)
    ```

- `watch()`

  - 监听集合中符合查询条件的数据的更新事件

    ```js
    testdoc.watch({
        // 数据库发生变化时触发
        onchange(res){
            // docChanges发生变化的数据
            // docs最新数据
        },
        // 失败回调
        onError(err){
            
        }
    })
    ```

- `limit()`

  - 同mongoose中`limit`

## loading遮罩

```js
// 显示遮罩
wx.showLoading({
  title: '加载中',// 加载时显示内容
  mask: true,// 透明遮罩 防止加载时点击 默认false
})

// 隐藏遮罩 不使用不会消失
wx.hideLoading()
```