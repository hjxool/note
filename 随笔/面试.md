## 前端八股文

[文档](https://juejin.cn/post/7016593221815910408#heading-55)

[高级文档](https://juejin.cn/post/6941278592215515143?searchId=202406181750271102B44A611953C76546#heading-35)

### Vue底层实现原理

- 采用数据代理结合==发布者-订阅者模式==，当数据变动时，会触发监听对象的`setter`，==发布==消息给==订阅者==，触发相应的更新页面回调
- `Observer`数据监听器
  - 通过`Object.defineProperty`或`proxy`监听数据变动，定义`getter`和`setter`，当数据发生变化，就会触发`setter`，这时候监听器就会通知==订阅者==`Watcher`
- `Watcher`订阅者：作为==监听器==和==指令解析器==之间的桥梁，原理：
  1. 在自身实例化时，往订阅器里添加自己
  2. 每个订阅者身上都有`update`方法
  3. 当数据变化时，触发==指令解析器==中绑定的回调函数
- `Compile`指令解析器
  - 主要做的事是解析模板指令，将模板中变量替换成数据，然后==初始化渲染页面==，并将指令对应的节点==绑定更新函数==，添加订阅者，一旦数据有了变动，就会更新视图

### 谈谈对Vue生命周期的理解

- Vue实例在创建时，经过的一系列初始化过程，生命周期钩子就是某一阶段时触发的回调函数
  - `beforeCreate`：创建前，此时`data`和`methods`还未初始化
  - `created`：创建完毕，`data`初始化完成，但未挂载
  - `beforeMount`：挂载前，此时可以发请求获取数据
  - `mounted`：实例已经被挂载到真实DOM节点
  - `beforeUpdate`：当`data`中数据发生变化时，==触发==重新渲染==前==
  - `updated`：重新渲染完毕
  - `beforeDestory`：实例被销毁前，此时可以手动销毁一些方法
  - `destoryed`：实例销毁完毕
- 创建组件时的生命周期
  1. ==父组件==从创建(`beforeCreate`)到挂载到页面前(`beforeMount`)
  2. 然后再执行==子组件==从创建(`beforeCreate`)到挂载完成(`mounted`)
  3. 子组件==创建完毕后==，才继续执行父组件的挂载(`mounted`)
  4. 当子组件更新时，父组件会进入更新前(`beforeUpdate`)状态，在子组件更新周期完成后(`beforeupdate`和`updated`)，才执行父组件`updated`
  5. 当组件销毁时，父组件执行`beforeDestory`，才轮到子组件执行销毁周期(`beforeDestory`和`destoryed`)，然后父组件完成销毁(`destoryed`)

### 讲一下计算属性(`computed`)和监听属性(`watch`)

- 一般来说，`computed`和`watch`都能实现的功能，推荐用`computed`，因为`computed`有缓存功能，当其依赖的值发生变化时才会重新计算，而`watch`是只要触发了监听属性的`setter`就会执行，所以`watch`更适用于计算开销较大的操作

### 组件中的`data`为什么是一个函数

- 这主要是为了组件被复用时考虑，当存在多个同样的组件时，就会创建多个实例，如果`data`不是函数，而是对象的话，就会由于地址索引，影响到所有组件实例，为了保证组件之间==数据隔离==，`data`必须是一个函数的返回值

### 为什么`v-for`和`v-if`不建议一起使用

- 对于Vue2来说，`v-for`的优先级更高，这会导致每次循环时`v-if`都会执行，导致性能浪费

- 在Vue3中，`v-if`优先级更高，但还是建议避免这样使用，以免混淆

### `diff`算法核心原理

1. 对当前更新的节点同层级进行比较

2. 首先判断新旧节点是否完全一致，如果一致则退出

3. 否则判断新旧节点类型是否一致

   - 不一致
     1. 则将旧节点卸载并置为`null`
     2. 然后根据新节点类型调用不同处理方法
     3. 最后插入新节点

   - 一致
     1. 则更新节点内容

- (Vue`diff`算法比React更复杂，能够最大程度复用节点)

### React/Vue中key的作用

- 一是帮助`diff`算法执行时更快找到对应节点，高效更新虚拟DOM
  - Vue的`diff`算法中，会根据新节点`key`对比旧节点数组中的`key`，如果没找到则认为是新增节点
  - 如果没有`key`则会采用==遍历查找==找对应旧节点
- 二是数据变化时，避免==就地复用==带来的渲染错误

### Vue组件的通信方式

1. `props`父到子组件通信和`$emit`触发父组件监听方法
2. 全局事件总线
3. 父组件到后代组件的跨组件通信`provide`、`inject`

### 讲一下`nextTick`

- 执行时机
  - `updated`或`mounted`之后执行
- Vue更新是异步的，当数据发生变化，就会在事件循环中缓存数据变更操作，为避免不必要的操作和计算，`nextTick`会在队列中加入一个回调函数，并确保该函数在所有DOM操作完成后才调用

### 讲一下插槽

- 一种有三种插槽，默认插槽、具名插槽、作用域插槽

### 讲一下`keep-alive`

- 作用
  - 实现组件缓存，保持组件状态，避免因重复渲染导致性能问题
- 原理
  - Vue将真实DOM节点抽象成虚拟节点树，`keep-alive`就是基于虚拟节点，它将虚拟节点在`cache`对象中缓存起来，再在需要重新渲染时，将虚拟节点从`cache`对象中取出渲染

### 讲一下`mixins`

- 混入是当多个组件有重复逻辑时使用

### 讲一下你对Vuex的理解

- Vuex是专门为Vue开发的状态管理机，核心就是仓库`store`
- Vuex的状态存储是响应式的，仓库中状态发生变化，相应的组件也会更新
  1. 首先是通过`commit`触发`mutation`中定义的方法
  2. 然后对仓库中的状态进行更改

- 同时还存在`Module`，可以将单一仓库拆分为多个，并保持在单一状态树中

### 讲一下React中类组件和函数组件的区别

- 函数组件适用于简单组件，接收单个参数`props`，返回一个标签元素，并且没有`this`
- 而类组件继承`Component`类，可以设置`state`并直接使用`props`，可以实现复杂的组件

- 函数组件的重新渲染是返回新的标签元素，而类组件是创建一个新的实例

### hooks用过吗？

- 用过，`hooks`是为了让函数组件也可以使用`state`等React特性
- 分别有这么几个常用的：`useState`状态钩子、`useContext`共享状态钩子、`useReducer`action钩子、`useEffect`副作用钩子
  - ps：副作用指不直接与视图渲染相关的操作，如网络请求

### React组件通信方式

1. 父组件向子组件传值，用`props`
2. 子组件向父组件传值，父组件用`props`传入函数给子组件，子组件调用传入参数
3. 父组件向后代组件传值，用`context`，创建一个组件树的共享数据容器
4. 任意层级组件传值，通过消息订阅和发布

### setState是同步还是异步执行

- 在React事件中是==异步==，因为会将更新操作放到更新队列里，批量执行，而不是立即更新
- 但在DOM事件或定时器中是==同步==执行

### React生命周期

- 组件被创建时，执行`constructor`→`getDerivedStateFromProps`→`render`→`componentDidMount`
- 组件更新时：执行`getDerivedStateFromProps`→`shouldComponentUpdate`→`render()`→`getSnapshotBeforeUpdate`→`componentDidUpdate`
- 组件卸载时：执行`componentWillUnmount`

### 说一下react-filber

- 根据优先级对主线程中的执行任务进行调度

### React事件绑定原理

- 事件不是直接绑在DOM节点，而是对原生事件进行封装，然后绑定到==根组件==统一监听

### webpack做过那些优化？开发效率、打包策略等

#### 优化构建速度

1. 使用==多线程==，如`thread-loader`
   - 但仅限于特别耗时的，否则还不如直接构建速度快
2. 使用==热更新==，只对修改的模块进行打包，在程序运行时，删除、增加模块不会使页面重新刷新
   - 但是重新加载JS会使页面重新加载，因此需要手动设置规则只对某JS文件进行加载
3. 使用`oneof`，这样在匹配到第一个符合的规则时就会停止遍历
4. 缩小打包范围，使用`exclude/include`排除如`node_module`这样的包
5. 利用缓存`cache`，只对修改的文件进行检查，构建速度会有提升
6. 使用`babel`插件，因为`babel`编译时会为每个文件添加辅助代码，而这个插件可以使辅助代码作为独立模块==引入==
7. 使用`code split`，因为打包时会将所有JS文件打包成一个，用`code split`可以将其分割成多个JS文件，并按需引入

#### 优化打包体积

1. 使用静态图片压缩插件
2. 提取公共资源
3. 使用`Tree shaking`，去除无用的JS文件，不过是webpack默认开启的

### 简述一下Babel编译过程

- `babel`是一个工具链，将`ES6`语法编写为==向后兼容==的JS语法，是通过==抽象语法树==完成代码的转译

### http和https

#### 基本概念

- `http`是客户端和服务端应答的TCP协议，用于从服务端传输==超文本==到本地的传输协议
- `https`则是在`http`基础上增加`SSL`层，对==证书==、==密钥==、==数据完整性==进行验证

#### http和https区别和优缺点

- `http`是明文传输，`https`是==加密传输协议==，所以要更安全
- `http`端口默认`80`，`https`端口默认`443`
- `http`和`https`都属于==应用层==协议，且都是无状态的，只是在应用层横向加了个`SSL`协议
- `https`会使页面加载时间延长
- `https`缓存方面效能更低，如加密传输协议==无法直接缓存==，而是==重新建立连接==
  - 以及握手阶段，需要验证过程，而`http`只需向服务端发送请求，服务端就会返回数据

#### https协议工作原理

1. 客户端访问服务器时，会==要求==服务器建立`SSL`连接
2. 服务器收到请求后，会==将证书传给客户端==
3. 客户端和服务端协商`SSL`==安全等级==
4. 客户端和服务端通过协商一致的安全等级，==建立会话密钥==，然后通过==公钥==加密会话密钥，传给客户端
5. 服务器通过==私钥==解密会话密钥
6. 服务端通过==会话密钥==加密与客户端之间的通信

### 阐述TCP三次握手四次挥手

1. 第一次握手：建立连接时，客户端发送`syn包`到服务器，并进入`syn_sent`状态，==等待服务器确认==
   - `syn`：同步序列号
2. 第二次握手：服务器收到并确认客户端`syn包`，并回复`syn + ack包`，进入`syn_recv`状态
3. 第三次握手：客户端收到`syn + ack包`，并向服务器发送`ack包`，发送完进入==连接成功==状态

- 四次挥手：**客户端**发送==释放报文==(第一次)，**服务端**回复==确认报文==(第二次)，等发完最后的数据后，**服务端**发送==释放报文==(第三次)，**客户端**收到后回复==确认报文==(第四次)，并在稍后关闭连接，而服务端收到确认报文后是立即结束连接

### TCP/IP是如何保证数据包传输的可靠性

- 对数据流==分段并编号==，然后通过==ack回复==和==超时重发==两个机制保证
  1. 发送方把已发送的数据包保留在==缓冲区==
  2. 并为每个==已发送==的包设置一个==超时定时器==，定时器超时前收到应答的话，就会释放该数据包占用的缓冲区，否则重传，直到达到最大重试次数
  3. 接收方收到数据包后，先进行校验，如果数据正确则交给上层协议，然后回复一个累计应答包

### TCP和UDP的区别

- `TCP`==需要建立连接==，可靠性更强，而`UDP`是无需建立连接，直发数据
- `TCP`仅支持==单播传输==，`UDP`支持单播、多播、广播
- `UDP`传输效率更高，实时性好

### HTTP跨域问题

- 原理
  - 浏览器同源策略所致，当前网站不能执行其他网站==脚本==
- 解决方式
  - `jsonp`：通过`<script>`标签，发送请求
    - 缺点：只支持`get`请求
  - `postMessage`发送数据
  - `proxy`代理：服务器端设置代理
  - `CORS`：服务器设置`Access-Control-Allow-Origin`响应头，允许其他域名的访问

### Cookie、sessionStorage、localStorage之间的区别

- 相同点
  - 都存在客户端
- 区别
  - `cookie`数据不能超过4k，`session`和`local`要大得多
  - `cookie`在设置的过期时间之前一直有效，`local`==永久==存储，`session`在当前窗口关闭后自动清除
  - `cookie`数据会随请求带往服务器，`session`和`local`数据都存在本地

### TCP粘包问题

- 出现原因
  - 发送的若干数据包在接收时粘成一包，后一包数据头接前一包数据尾
- 解决方法
  1. TCP提供了强制传送的操作指令，不必等缓冲区满即会发送
     - 缺点：会降低网络发送效率
  2. 对于接收方，可以通过提高接收进程优先级，使其即时接收数据
     - 缺点：频率高时，还是可能会出现粘包
  3. 程序上控制，分多次接收，然后合并
     - 缺点：效率较低

### 从输入URL到页面加载的全过程

1. 浏览器根据URL查看缓存，是否存在该地址页面，如果有则显示
2. 如果缓存中没找到，则向DNS服务器发起请求，获得对应IP地址
   - DNS服务器就属于UDP
3. 根据IP地址，建立TCP连接
4. 客户端发起HTTP请求
5. 服务器返回请求结果
6. 当请求结束时，关闭TCP连接
7. 浏览器根据HTML内容，构建DOM树、根据CSS样式布局绘制页面，再进行JS解析

### JS数据类型如何检测

1. 用`typeof`
   - 缺点是不能对数组、对象和`null`进行区分
2. `instanceof`
   - 优点是可以区分数组、对象和函数，但是缺点是基本类型数据无法区分
3. `Object.prototype.toString.call(变量)`
   - 可以精准判断类型
   - 不过返回的是`[object String]`、`[object Array]`等，使用`Object`身上的`toString`方法最好是封装成函数
   - ==变量==自身带有内置的`toString`方法，是将自身转变为字符串，而`Object`原型身上的`toString`方法则是返回类型，==变量==的`toString`是对`Object`原型链上的覆写

### var、let、const之间的区别

- `var`定义的变量==没有块的概念，可以跨块访问==，但是不能跨函数
  - `var`可以==先使用后声明==，存在变量提升
  - `var`可以在作用域内声明重复变量，而`let`、`const`不行
- `let`定义的变量只能在块作用域内访问
  - `let`必须先声明后使用
- `const`定义的常量，使用时必须赋值，只能在块作用域内访问

### JS垃圾回收机制

- 回收机制会定期处理不再使用的变量，释放内存
- 常见的内存泄露有全局变量、闭包、DOM元素的引用、定时器

### 作用域和作用域链

- 作用域就是函数和变量可访问的范围，分全局作用域和函数作用域
- 作用域链就是变量在当前作用域下取值，如果找不到则向上查找，直到全局作用域，这个查找的过程即作用域链

### 闭包是什么？有什么作用？

- 闭包其实就是嵌套函数，内部函数引用了外部函数的变量
- 闭包的作用
  - 一是保护函数变量不被释放
  - 二是保护私有变量不被污染

### JS中this指向的问题

- 作为普通函数执行时，`this`指向`window`
- 作为对象的方法被调用时，指向该对象
- 在构造器中使用时，指向类实例化的对象
- 在箭头函数中，指向父函数调用者
- 使用`call`、`bind`等情况下，`this`指向传入的参数

### 请解释一下原型和原型链

- 原型是指定义的对象会包含一个预定的属性，`__proto__`或者`prototype`，指向它的原型对象
- 原型链指对象间都有指向其原型链接，这个原型又可以有自己的原型，形成一个链条
  - 访问一个对象的属性时，JS会沿着原型链向上搜索，直到找到属性或到达原型链末尾

### 请讲一下new运算符实现的原理

1. 首先创建一个==空对象==
2. 将对象的原型设置为函数的原型对象
3. 然后让函数的`this`指向这个对象，执行构造函数代码
4. 最后返回创建的对象

### 解释一下什么是事件循环

- 因为JS是单线程，为了防止单一函数执行时间过长，导致阻塞，会将异步执行的方法放到队列里面，等主线程执行完毕再执行队列中的任务
  - 队列又分为微任务队列和宏任务队列，微任务队列就比如`Promise.then`，宏任务队列就比如定时任务
- 简单来说经过以下几个步骤
  1. js执行，遇到同步代码就压入执行栈，遇到异步代码就丢给WebAPI，接着执行同步代码
  2. 此期间，webAPI会将异步代码的回调函数放入队列等待执行
  3. 执行栈为空后，事件循环会取出微任务执行，清空微任务后，再到宏任务队列取第一个任务执行，执行完毕，再查看微任务队列中是否有任务，如果有则执行清空微任务，再去宏任务找，如此循环，直到清空所有任务
- (一般不问)`node`运行环境下，事件循环还会添加一些I/O读写操作

### 介绍下Async/Await是如何实现同步执行异步操作

- 其实就是一个语法糖，本质是将`await`前后部分代码放入==生成器函数==，利用其特性将异步代码写成同步的形式，`await`的位置相当于`yield`，并对`await`后的`promise`对象添加一个`.then`然后执行`next()`方法，使得`prosmise`对象状态成功后才继续往下执行

### 介绍一下节流、防抖以及应用

- 节流
  - 指规定时间内，无论触发多少次，只调用一次
  - 应用
    - 需要高频点击或触发的时候
- 防抖
  - 无论触发多少次，等待时间过了，才会触发一次
  - 应用
    - 如搜索框搜索输入内容

### 浏览器重绘和重排的区别

- 重绘：元素外观发生改变
- 重排/回流：重新排列布局

### 如何触发重排和重绘

- 改变DOM的操作都会触发
  - 增删改DOM节点
  - `display:none`隐藏DOM节点
  - 移动DOM节点
  - 添加样式
  - 用户行为，如改变窗口大小

### 如何避免重绘或重排

- 元素定位改为`absolute`或`fixed`，即可脱离文档流，再修改样式就不会重排
- 集中改变样式，不要一条条修改DOM的样式

### Git常用命令有哪些

- `git branch`(查看/创建分支)、`git checkout`(切换分支)、`git merge`(合并分支)

### HTML5新特性、语义化

- 新增`header`、`footer`等标签，优点是即使没CSS样式，页面也有很好的结构效果，使代码结构更清晰易读

### CSS样式优先级

- `!important`>内联样式>ID选择器>类、属性、伪类选择器>元素、伪元素选择器>关系、通配符选择器

### Position属性值有哪些区别

- `fixed`：相对于浏览器窗口定位，脱离文档流
- `relative`：相对于元素自身定位，不会脱离文档流
- `absolute`：相对于最近的定位父元素定位，脱离文档流
- `sticky`：先按文档流定位，然后相对于==最近的块级父元素==定位，当元素位置在特殊阈值时，为固定定位

### 讲一下盒模型

- 盒模型是指由边距、边框、填充和内容组成的方盒
- 标准盒模型指`margin`、`border`、`padding`、`width`
- IE盒模型值`margin`、`width`，`width`包含了`padding`和`border`

### 讲一下BFC

- 是一个独立渲染区域，规定容器内部如何布局，并且容器内子元素不会影响到外面的元素
- `overflow`开启滚动显示或脱离文档流的定位方式即可开启BFC

## 手写代码题

### JS数组去重

#### 使用set

- `set`是JS内建对象，只允许存储唯一值

  - `set`只能用`for of`遍历，是一个可迭代对象

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  let t2 = [...new Set(t)] // [1, 2, 3, 4]
  ```

#### 使用filter

- 用`indexOf`找首个目标元素索引位置与当前元素索引位置是否相同决定是否返回该元素

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  let t2 = t.filter((ele, index) => t.indexOf(ele) === index)
  ```

#### 使用reduce

- `reduce`能用在所有归并一个结果的执行逻辑上

  - 需要用数组的`includes`方法

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  // 初始值为[]空数组
  let t2 = t.reduce((pre,cur) => {
      // 判断当前元素在结果数组中是否存在
      if(!pre.includes(cur)) {
          // 不存在 则填入数组
          pre.push(cur)
      }
      // 记得要把结果数组返回 作为下一轮循环的pre参数
      return pre
  }, [])
  ```

### 将数字每千分位用逗号隔开

- 使用`toLocaleString`

  ```js
  let num = 1234567.89;  
  let string = num.toLocaleString()
  console.log(string);  // 输出 可能 是 "1,234,567.89"
  // 如果想不受本地化设置影响 可以传入参数
  let string2 = num.toLocaleString('en-US')
  ```

### 手写防抖/节流

#### 防抖

- 指事件触发后，N秒内只能执行==一次==，N秒内再次触发则重新计算执行时间

- 适用于==延迟触发==的场景

  ```js
  function delounce(func, delay) {
      let timer = null
      // 这里不要用箭头函数 为了保存它自身被调用时的this
      return function (...params) {
          // 注意接收参数
          clearTimeout(timer)
          // 触发后 delay后执行一次
          timer = setTimeout(() => {
              // 为保证func内的this指向 要用call方法
              func.apply(this, params)
          }, delay)
      }
  }
  ```

#### 节流

- ==连续触发==，但N秒内只执行一次

- 适用于==控制频率==的场景

  ```js
  function throttle(func, delay) {
      let timer = false
      return function (...params) {
          if(!timer){
              // 触发后 立即执行 但是delay内不能再次执行
              func.apply(this, params)
              // 执行后一段时间内就不能再触发 将标识置为true
              timer = true
              // 并设置定时器 一段时间后再将标识置为false
              setTimeout(() => {
                  timer = false
              }, delay)
          }
      }
  }
  ```

#### Vue中使用防抖/节流

- 因为绑定事件的方法必须是防抖/节流返回的函数，因此要用赋值的写法，先执行防抖节流函数将其返回值赋给响应式变量

  ```js
  new Vue({
      el: '#root',
      data: {
  		fn3: null, // 先声明变量
      },
      created(){
          // 将返回函数作为fn3值
          this.fn3 = this.fn1(this.fn2, 2000)
      },
      methods: {
          fn1(func, delay) {
              let timer = false
              return (...params) => {
                  if (!timer) {
                      func.apply(this, params)
                      timer = true
                      setTimeout(() => {
                          timer = false
                      }, delay)
                  }
              }
          },
          fn2() {
              console.log(111)
          },
          fn3: this.fn1(this.fn2, 1000), // 这种不行 因为此时还没有fn1 fn2
          fn3(){
              // 这种不行 必须是fn3本身是fn1返回值
              return this.fn1(this.fn2, 2000)
          }
      }
  })
  ```


### 手写Promise

- 简单来说`new Promise`传入的函数会==立即(同步)执行==，而形参的`resolve reject`是==异步==执行

  - `then`的工作就是往链式的==前一个==`promise对象`身上用==闭包==记录自己的回调函数、`resolve reject`，等自己的方法执行时，用==闭包保存==的`resolve/reject`==修改自身状态==

  ```js
  function Promise(callback){
      // 每个Promise对象都有的以下属性
      this.status = 'pending'
      this.value = null
      this.fulfilledCallback = [] // 成功回调
      this.rejectedCallback = [] // 失败回调
      const resolve = (value) => {
          setTimeout(() => { // resolve/reject是异步
              if(this.status !== 'pending'){
                  return
              }
              // 改变状态、赋值 并执行绑定在自身的下一级promise对象回调方法
              this.status = 'fulfilled'
              this.value = value
              for(let fn of this.fulfilledCallback){
                  fn()
              }
          })
      }
      const reject = (err) => {
          setTimeout(() => {
              if(this.status !== 'pending'){
                  return
              }
              this.status = 'rejected'
              this.value = err
              for(let fn of this.rejectedCallback){
                  fn()
              }
          })
      }
      // 每一步执行都要用try catch包裹
      try{
          callback(resolve, reject) // 创建promise对象的回调函数是立即执行
      } catch(err){
          reject(err)
      }
  }
  Promise.prototype.then = function (onFulfilled, onReject){
      // 在创建promise对象前 先处理未传入回调的情况
      if(typeof onFulfilled !== 'function'){
          onFulfilled = (value) => { return value }
      }
      if(typeof onReject !== 'function'){
          onReject = (err) => { throw err }
      }
      // 创建promise对象 传入特定回调函数逻辑
      return new Promise((resolve, reject) => {
          // 公共逻辑部分
          let common = (fn) => {
              setTimeout(() => {
                  try {
                      let result = fn(this.value)
                      if(result instanceof Promise){
                          result.then(value => {
                              resolve(value)
                          }, err => {
                              reject(err)
                          })
                      } else {
                          resolve(result)
                      }
                  } catch(err){
                      reject(err)
                  }
              })
          }
          // 注意 读取的是上一级promise对象属性
          if(this.status === 'fulfilled'){
              common(onFulfilled)
          } else if(this.status === 'rejected'){
              common(onReject)
          } else if(this.status === 'pending'){
              // 给上一级promise对象绑定当前promise对象回调
              this.fulfilledCallback.push(() => {
                  common(onFulfilled)
              })
              this.rejectedCallback.push(() => {
                  common(onReject)
              })
          }
      })
  }
  Promise.prototype.catch = function (callback) {
      // catch还是复用then 只不过catch传入的单个回调作为then的失败回调
      return this.then(null, callback)
  }
  Promise.all = function (promise_list) {
      // 还是返回promise对象
      return Promise((resolve, reject) => {
          // 处理传入参数不符合条件的情况
          if(!Array.isArray(promise_list)){
              throw '必须传入数组'
          }
          for(let val of promise_list){
              if(val instanceof Promise){
                  throw '必须传入promise对象'
              }
          }
          // 计数统计promise完成数量
          let count = 0
          let total = promise_list.length
          // 因为返回的值是成功后的数组 所以用数组记录结果
          let result = []
          // 这里要用for let i的形式遍历
          // 因为循环内部是异步 需要用索引记录在结果数组中第几位
          for(let i = 0; i < total; i++){
              // 通过then取值
              promise_list[i].then(value => {
                  count++ // 计数增加
                  result[i] = value // 对应位置填结果值
                  // 如果计数结束 将结果数组作为Promise.all返回值
                  if(count === total){
                      resolve(result)
                  }
              }, err => {
                  // 有一个promise对象执行失败 Promise.all返回报错信息
                  reject(err)
              })
          }
      })
  }
  ```

### 手写深拷贝

- 使用`JSON`API进行深拷贝，会有几个问题，无法拷贝属性值为`undefined`、`Date`对象、函数、正则

  ```js
  // 用哈希表记录遍历过的对象
  function deepClone(source, hash = new Map()){
      if(typeof source !== 'object'){
          // 基本数据类型 直接返回
          return source
      }
      // 如果是日期或正则对象则直接返回一个新对象
      if(source instanceof Date){
          return new Date(source)
      }
      if(source instanceof RegExp){
          return new RegExp(source)
      }
      if(hash.has(source)){
          // 哈希表中已经有同引用的对象 直接返回记录值 防止循环引用
          return hash.get(source)
      }
      // 准备一个容器装深拷贝结果
      let clone = Array.isArray(source)? [] : {}
      // 将当前对象存入哈希表 防止循环引用
      hash.set(source, clone)
      // 遍历 将元素/属性取出
      for(let key in source){
          // 判断是否是自身的属性 因为for in会取到原型链的属性
          if(source.hasOwnProperty(key)){
              // 递归拷贝每一个属性
              clone[key] = deepClone(source[key], hash)
          }
      }
      // 返回深拷贝后的结果
      return clone
  }
  ```


### 手写new操作符

```js
function myNew(constructor, ...params) {
    // 1、创建空对象
    let obj = new Object()
    // 2、将这个空对象原型指向构造函数原型
    obj.__proto__ = constructor.prototype
    // 3、以这个新对象作为构造函数的this执行
    let result = constructor.apply(obj, params)
    // 4、判断传入的构造函数是否返回了一个对象
    // 如果构造函数返回了一个对象 则以这个返回值为结果 其身上不一定有构造函数中的属性方法
    // 如果没有返回一个对象 则返回obj作为结果 obj经过构造函数 已经为其身上添加了属性方法
    return typeof result === 'object'? result : obj
}
```

### 函数柯里化

- 柯里化简单来说就是==返回值为函数==，并且应用==闭包、递归==将外层变量存下来进行传递

  - 注：`函数.length`是获得==函数的形参数量==

- 柯里化的几个题目，都是`fn(1)(3)(1,4)`这种形式

  1. 将一个函数柯里化

     ```js
     function target(a, b, c) {
         return a + b + c
     }
     function curry(fn) {
         if(typeof fn !== 'function') {
             throw '必须传入函数'
         }
         // 必须要用命名函数 因为要递归
         return function curried(...params) {
             // 递归就一定要有出口 比如本题递归出口就是参数数量
             if(params.length >= fn.length){
                 // 如果 累计 传入参数数量 大于等于 fn形参数 则传入fn返回结果
                 // 注意 改变fn的this指向
                 return fn.apply(this, params)
             } else {
                 // 传入参数数量不足 则返回一个新的函数 用来接收后续参数
                 // 主要是为了在未执行fn返回最终结果前 缓存 传入参数 然后在递归出口执行最终结果
                 return function (...params2) {
                     // 用了rest参数params是数组 将其合并params2新传入参数
                     // curried执行结果分 新函数 或 fn返回值
                     return curried.apply(this, params.concat(params2))
                 }
             }
         }
     }
     let fn = curry(target)
     console.log(fn(1, 2)(3)) // 6
     console.log(fn(1, 2)(3, 4)) // 6
     ```
     
  2. 实现`sum(1)(2)(3, 4)`
  
     ```js
     // 注意这里一定要用rest参数将其改编成数组 方便后面缓存参数
     function sum(...params) {
         // 这里不能直接返回函数 因为要以toString为递归出口
         function curried(...params2) {
             // 用外层params数组做闭包 缓存参数
             params.push(...params2)
             // 返回自身函数
             return curried
         }
         // 设置递归出口 被console.log输出时执行 覆写toString方法
         curried.toString = () => {
             // 取出缓存的参数 进行运算
             return params.reduce((pre, cur) => {
                 return pre + cur
             }, 0)
         }
         // 返回声明的函数
         return curried
     }
     console.log(sum(1, 2)(3)(4)) // 10
     
     // 另一种实现方式 递归出口为传入一个空函数 sum(1)(2)()
     function sum(...params) {
         function curried(...params2) {
             if(params2.length) {
                 // 参数不为空 则缓存参数
                 params.push(...params2)
                 return curried
             } else {
                 // 递归出口 参数为空 进行运算
                 return params.reduce((pre, cur) => {
                     return pre + cur
                 }, 0)
             }
         }
         return curried
     }
     console.log(sum(1)(2)(3, 4)()) // 10
     ```
     

### 实现AJAX请求

```js
function request(url, method = 'get', data = null) {
    // 链式调用 所以返回promise对象
    return new Promise((resolve, reject) => {
        // 创建http请求
        let xhr = new XMLHttpRequest()
        xhr.open(method, url, true)
        // post请求要设置请求头
        if(method === 'post') {
            xhr.setRequestHeader('Content-Type', 'application/json')
        }
        // 请求回来后执行的逻辑
        xhr.onload = function () {
            if(this.status === 200) {
                // 能请求到接口 请求状态就是200
                resolve(this.reponseText)
            } else {
                // 接口不存在 返回错误信息
                reject(throw this.statusText)
            }
        }
        // 网络错误
        xhr.onerror = function () {
            reject(throw '网络异常')
        }
        // 如果请求要传数据
        if(data) {
            xhr.send(data)
        } else {
            xhr.send()
        }
    })
}
```

### 交换a b值 不用临时变量

- 使用加减法(仅限数字)

  ```js
  let a = 5
  let b = 10
  a = a + b // a 15 b 10
  b = a - b // a 15 b 5
  a = a - b // a 10 b 5
  ```

- 解构赋值

  ```js
  let a = 'aa'
  let b = 'b'
  [a, b] = [b, a] // a 'b' b 'aa'
  ```

### 数组元素求和

- `for`循环

  ```js
  function sum(arr){
      let r = 0
      for(let i = 0; i < arr.length; i++){
          r += arr[i]
      }
      return r
  }
  ```

- 使用`array.reduce`

  ```js
  function sum(arr){
      return arr.reduce((pre, cur) => pre + cur, 0)
  }
  ```

### 数组扁平化

- 使用递归和`array.concat`

  - 因为`concat`可以接收数组作为参数，并将其展开，相当于一次降维

  ```js
  function fn(arr){
      let r = []
      // 遍历传入的数组元素 看是否又是数组
      for(let val of arr) {
          if(Array.isArray(val)){
              // 元素是数组 则递归 将其返回的结果作为concat参数进行降维
              r = r.concat(fn(val))
          } else {
              // 不是数组则添加到结果数组
              r.push(val)
          }
      }
      return r
  }
  ```

- 使用递归、`reduce`、扩展运算符

  ```js
  function fn(arr){
      return arr.reduce((pre, cur) => {
          // 不论元素是不是数组 都将pre结果数组展开 并与当前元素合并成新数组返回
          if(Array.isArray(cur)){
              // 元素是数组 则递归 并将其返回的结果展开 与pre合并成新数组
              return [...pre, ...fn(cur)]
          } else {
              return [...pre, cur]
          }
      }, [])
  }
  ```

- 使用迭代、扩展运算符、`concat`、`some`

  - `concat`可以传入数组和单独的元素，并且会将数组展开
  
  ```js
  function fn(arr){
      while(arr.some(e => Array.isArray(e))) {
          // 元素中有数组 则将整个数组展开 作为concat参数
          arr = [].concat(...arr)
      }
      return arr
  }
  ```
  
- 使用`flat`(了解即可)

  - `flat(参数)`参数为要展开的层数

  ```js
  let t = [1, [2, [3, [4]], 5]]
  console.log(t.flat(Infinity)) // [1, 2, 3, 4, 5]
  ```

### 类数组转化为数组

- 如具有数字索引、`length`属性的对象，转化为真正的数组

- 使用`Array.prototype.slice.call()`

  - 利用`Array`原型身上的`slice`生成数组，但是因为非数组没有`slice`方法，所以要用`call`将`slice`调用者改为目标

  ```js
  let t = {0: 'a', 1: 'b', 2: 'c', length: 3}
  Array.prototype.slice.call(t) // ['a', 'b', 'c']
  ```

- 使用扩展运算符

  ```js
  let t = {0: 'a', 1: 'b', 2: 'c', length: 3}
  let t2 = [...t]
  console.log(t2) // ['a', 'b', 'c']
  ```

- 使用`Array.from`

  - 用于从一个类似数组或可迭代的对象创建一个新的数组实例

  ```js
  let t = {0: 'a', 1: 'b', 2: 'c', length: 3}
  let t2 = Array.from(t)
  console.log(t2) // ['a', 'b', 'c']
  ```

### 将js对象转化为树形结构

- 注意和树节点过滤的区别，过滤只取当前节点符合或存在子节点符合才将当前节点填入当前层结果数组，而本题是将所有属于父节点的子节点填入当前层结果数组

  ```js
  const items = [  
    { id: 1, name: 'Item 1', parentId: null },  
    { id: 2, name: 'Item 1.1', parentId: 1 },  
    { id: 3, name: 'Item 1.2', parentId: 1 },  
    { id: 4, name: 'Item 2', parentId: null },  
    { id: 5, name: 'Item 2.1', parentId: 4 }
  ]
  // 顶层节点的父节点默认值 null
  function fn(list, parentId = null) {
      let r = []
      for(let val of list) {
          if(val.parentId == parentId) {
              // 继续递归找其子节点
              let child = fn(list, val.id)
              // 如果有子节点 则修改当前节点属性
              if(child.length) {
                  val.child = child
              }
              // 只有属于父级id的子节点才填入当前层级的结果数组
              r.push(val)
          }
      }
      // 递归出口 只有属于当前parentId的节点才会进入下次递归
      // 到叶子节点后 只会再往下递归一次 然后因为找不到子节点 返回空数组 并出栈到上一层继续执行
      return r
  }
  let r = fn(itmes)
  [
      {  
      id: 1,  
      name: 'Item 1',  
      parentId: null,  
      child: [  
        { id: 2, name: 'Item 1.1', parentId: 1 },  
        { id: 3, name: 'Item 1.2', parentId: 1 }  
      ]  
    },  
    {  
      id: 4,  
      name: 'Item 2',  
      parentId: null,  
      child: [  
        { id: 5, name: 'Item 2.1', parentId: 4 }  
      ]  
    }
  ]
  ```

### 图片异步加载

```js
function load(url) {
    return new Promise((resolve, reject) => {
        // 创建图片对象
        let img = new Image()
        // 设置加载失败和成功的回调
        img.onload = () => {
            resolve(img) // 用resolve返回img对象
        }
        img.onerror = (err) => {
            reject(err)
        }
        // 赋值到src属性 开始加载图片
        img.src = url
    })
}
load('xxx').then(img => {
    // 将返回的img对象绑定到元素节点
}).catch(err => console.log(err))
```

### 实现发布-订阅模式

- 事件驱动中很常见，如DOM事件

  ```js
  class PubSub {
      constructor() {
          this.subscribes = {} // 收集订阅的事件
      }
      // 添加订阅
      addSub(eventName, callback) {
          if(!this.subscribes[eventName]) {
              // 如果没有对应事件 创建
              this.subscribes[eventName] = []
          }
          // 将订阅传入的回调函数存起来
          this.subscribes[eventName].push(callback)
      }
      // 取消订阅
      removeSub(eventName, callback) {
          // 存在对应事件才执行
          if(this.subscribes[eventName]) {
              // filter过滤出来不等于传入回调的方法 
              this.subscribes = this.subscribes.filter(fn => fn !== callback)
          }
      }
      // 触发订阅事件
      publish(eventName, data) {
          if(this.subscribes[eventName]) {
              this.subscribes.forEach(fn => fn(data))
          }
      }
  }
  // 使用示例
  let p = new PubSub()
  // 订阅
  function fn() {}
  p.addSub('aaa', fn)
  // 发布事件
  p.publish('aaa')
  // 取消订阅
  p.removeSub('aaa', fn)
  ```

### 实现双向数据绑定

- 结合发布-订阅模式、观察者模式

  ```js
  // vue
  class Vue {
      constructor(options) {
          // vue2是将目标对象改造成代理
          this.$data = options.data
          observerOld(this.$data)
          // vue3则是返回新对象
          this.$data = observerNew(options.data)
          // 创建vue实例时初次渲染 以及 解析模板
          compile(options.el, this)
      }
  }
  // Vue2用defineProperty
  function observerOld(obj) {
      if (typeof obj !== 'object') {
          // 不是对象不继续执行
          return;
      } else {
          // 每读取一层 创建一个发布-订阅实例闭包
       	let dep = new Dep()
          // 遍历对象属性
          for(let key in obj) {
              // 关键点 设置局部变量形成闭包 而不是直接读取修改 避免死循环
              let value = obj[key]
              // 递归 子属性继续数据劫持
              observerOld(value)
              // 当前对象进行代理配置 不会生成新对象
              Object.defineProperty(obj, key, {
                  // 默认不可修改和遍历 需设置为true
                  enumerable: true,
                  configurable: true,
                  // 设置getter setter
                  get() {
                      // 关键点 此时正是创建watcher实例 读取属性触发get
                      // 全局变量存着正在创建的watcher实例
                      if(Dep.temp) {
                          // 将其存入发布-订阅数组中 这样watcher实例就不会被释放
                          dep.addSub(Dep.temp)
                      }
                      // 返回闭包value
                      return value
                  },
                  set(newValue) {
                      // 修改闭包值
                      value = newValue
                      // 新值有可能是对象 而defineProperty是对属性进行监听
                      // 所以继续数据代理 否则后续在读取当前属性对象下的属性时无法触发拦截
                      observerOld(newValue)
                      // 值发生变化 发布-订阅通知watcher实例 触发更新dom的回调方法
                      dep.notify()
                  }
              })
          }
      }
  }
  // Vue3使用proxy
  // 注意 必须要创建哈希表存proxy对象
  // 否则 多层级对象修改属性时 在读取目标属性父级时
  // 会因为触发getter创建一个新的proxy对象
  // 而此时Dep.temp为null 导致丢失watcher实例
  // 因此要记录proxy对象 只有查不到时才创建新的
  function observerNew(obj, map = new Map()) {
      if (typeof obj !== 'object') {
          // 不是对象则返回原值
          return obj;
      } else {
          // 查询map中是否有存对应proxy对象
          let old_proxy = map.get(obj)
          if (old_proxy) {
              // 查到了直接返回记录值 不执行后续
              return old_proxy
          }
          let dep = new Dep() // 同observerOld
          // 与defineProperty不同的是 proxy代理会返回一个新对象 所以不需要用value闭包
          // Vue3 数据劫持是惰性的 因为Proxy的特性
          // 它不需要一开始就遍历对象的属性然后对每个属性进行劫持 而是以一个对象为整体
          // 当访问到该属性时再去进行劫持
          // 而defineProperty是对对象属性进行代理 只有读取对应属性才触发拦截
          let new_proxy = new Proxy(obj, {
              // target 被代理的对象 key 当前读取的属性名
              get(target, key) {
                  if (Dep.temp) {
                      // 同observerOld
                      dep.addSub(Dep.temp)
                  }
                  // 对子属性数据代理 将返回的proxy对象作为当前proxy对象属性值
                  return observerNew(target[key], map)
              },
              set(target, key, value) {
                  target[key] = value // 修改值
                  // 注意 这里和defineProperty的区别
                  // 因为proxy是在get中返回一个新proxy对象作为属性值
                  // 所以不需要在set时对新赋值的子属性进行代理
                  // 由dep通知watcher触发更新
                  dep.notify()
                  // proxy中内置了对数组修改的拦截 无需像Vue2重写数组方法
                  // 但是需要对正确修改的操作return ture
                  return true
              }
          })
          // 根据obj索引地址 作为key 记录新创建的proxy对象
          map.set(obj, new_proxy)
          // 再返回该proxy对象
          return new_proxy
      }
  }
  // 解析 替换DOM节点文本内容 生成虚拟dom树
  function compile(dom, vm) {
      // 在vue实例上添加$el属性 保存真实dom根节点
      vm.$el = document.querySelector(dom)
      // 创建空虚拟dom容器
      let fragment = document.createDocumentFragment()
      // 遍历根节点 将所有真实子dom添加到虚拟dom片段中
      let child = vm.$el.firstChild
      while(child) {
          // 注意 同一个dom只能存在于一处
          // 即如果被添加到虚拟dom中 真实dom树中该节点就会消失
          fragment.appendChild(child)
          // 从真实dom树中移除该节点后 vm.$el.firstChild就会移向下一个节点
          // 注 换行 空格也是文本节点 所以也会被添加到虚拟dom中
          child = vm.$el.firstChild
      }
      // dom节点解析替换内容方法
      function fragmentCompile(node) {
          // 以下只有 {{}}插值语法 v-model 解析替换节点内容的示例
          if(node.nodeType === 3) {
              // 解析插值
              // {}是特殊符号需要\转义 插值语法中可能有空格也要进行匹配
              // 用()包裹要替换匹配的字符 exec方法就能提取出()部分的内容
              let reg = /\{\{\s*(\S+)\s*\}\}/ // 过滤 换行 空格 节点
              let result = reg.exec(node.nodeValue) // 值为null 或 数组
              if(result) {
                  // 用闭包保存插值字符串 如{{xx}}
                  // 便于后面watcher回调函数替换节点内容
                  let str = node.nodeValue
                  // result数组中第一个元素是 完整匹配结果
                  // 往后是按顺序用()包裹的子匹配结果 所以取第2个元素
                  let key = result[1] // 'xx'
                  let keyList = path_list(key) // ['xx']
                  // 读取在data配置项中存的属性值
                  let value = keyList.reduce((pre, cur) => pre[cur], vm.$data)
                  // 首次渲染 将数据根据正则匹配 替换原dom内容
                  node.nodeValue = str.replace(reg, value) // <div>12</div>
                  // 关键点 创建watcher实例时 会触发$data中数据拦截
                  // 将当前watcher实例添加到闭包dep中 存在内存中不被释放
                  new Watcher(vm, keyList, newvalue => {
                      // 关联属性 值 发生变化 触发该回调方法
                      node.nodeValue = str.replace(reg, newvalue)
                  })
              }
          } else if(node.nodeType === 1 && node.nodeName === 'INPUT') {
              // input标签节点类型为1 节点名为INPUT
              // 遍历节点属性 找是否有v-model字段
              for(let val of node.attributes) {
                  if(val.nodeName === 'v-model') {
                      // 获取v-model后绑定的属性字段
                      // 不用正则 可以看出不同指令/语法解析逻辑是有区别的
                      let keyList = path_list(val.nodeValue)
                      let value = keyList.reduce((pre, cur) => pre[cur], vm.$data)
                      // 注意 这里修改input节点的value属性 而不是nodeValue
                      val.value = value
                      // 创建watcher实例 传入后续更新回调方法
                      new Watcher(vm, keyList, newvalue => {
                          node.value = newvalue
                      })
                      // 注意 直到上面new watcher为止 都是model到view的逻辑
                      // 接下来设置 view到model逻辑
                      // 要修改内存中属性值 需要找到父级对象索引
                      let parentKey = keyList.slice(0, keyList.length - 1)
                      let parent = parentKey.reduce((pre, cur) => pre[cur], vm.$data)
                      let childKey = keyList[keyList.length - 1]
                      // 添加input事件监听
                      // 这就是为什么说v-model是语法糖 还是要手动添加oninput事件
                      node.addEventListener('input', event => {
                          parent[childKey] = event.target.value
                      })
                      break
                  }
              }
          }
          // 递归 解析子节点
          for(let val of node.childNodes) {
              fragmentCompile(val)
          }
      }
      // 从根节点开始解析虚拟dom
      fragmentCompile(fragment)
      // 将编辑好的虚拟dom插入真实dom
      vm.$el.appendChild(fragment)
  }
  // 将取值路径字符串转换为数组
  function path_list(str) {
      // 先将字符串中[号换成 .
      let t = str.replace(/\[/g, '.')
      // 再将]号去掉
      let t2 = t.replace(/\]/g, '')
      // 最后以.进行分割 返回数组
      return t2.split('.')
  }
  // 观察者
  class Watcher {
      // 接收参数 vue实例 读取属性的key 如'a.b' 更新dom的回调方法
      constructor(vm, keyList, callback) {
          this.vm = vm
          this.keyList = keyList
          this.callback = callback
          // value属性用于对比新旧值 避免重复更新
          this.value = this.get()
      }
      // 只在创建实例时 调用一次
      get() {
          // 先将 当前watcher实例 添加到全局变量 临时存一下
          Dep.temp = this
          // 再读取vue实例身上的属性 触发属性getter 将watcher实例存到发布-订阅实例中
          let value = this.keyList.reduce((pre, cur) => pre[cur], this.vm.$data)
          // 读取完 就将全局变量释放
          Dep.temp = null
          return value
      }
      // 触发更新DOM方法
      update() {
          let newValue = this.keyList.reduce((pre, cur) => pre[cur], this.vm.$data)
          if(this.value !== newValue) {
              // 触发时 值发生变化才执行
              this.value = newValue // 更新value属性
              this.callback(newValue)
          }
      }
  }
  // 发布-订阅
  class Dep {
      constructor() {
          // 注意 这里是数组不是对象 因为由闭包触发更新 不需要知道是哪个事件
          this.subs = []
      }
      // 添加订阅
      addSub(watchObj) {
          // 将传入的观察者实例存起来
          this.subs.push(watchObj)
      }
      // 通知更新
      notify() {
          this.subs.forEach(obj => obj.update())
      }
  }
  ```
  

### 实现简单路由

- 用`hash`实现方式

  - `html`部分

  ```html
  <nav>  
      <a href="#/">Home</a> |  
      <a href="#/page1">About</a> |  
      <a href="#/page2">Contact</a>  
  </nav>  
    
  <div id="content"></div>
  ```

  - `js`部分

  ```js
  let route = {
      // 路由本质就是函数中实例化组件对象来替换目标dom节点内容
      // 其实函数名就是路径
      '/': function () {
          document.getElementById('content').textContent = 'Home Page'
      },
      '/page1': function () {
          document.getElementById('content').textContent = 'Page1'
      },
      '/page2': function () {
          document.getElementById('content').textContent = 'Page2'
      },
  }
  function init() {
      // 通过hash或history截取地址栏路径变化
      let hash = window.location.hash.substring(1)
      if (route[hash]) {
          // 匹配对应函数执行
          route[hash]()
      } else {
          route['/']()
      }
  }
  init()
  // 通过事件监听获取hash变化
  window.addEventListener('hashchange', function () {
      init()
  })
  ```

### 实现斐波那契数列

- 规则：每个数都是前两个数之和，都是正整数

  - `n`表示数列中第`n`个数
  - 递归实现
    - 直接，但是效率低，因为每个新数，都会重新计算之前的数

  ```js
  function fn(n) {
      if(n <= 1) {
          // 递归出口
          return n
      } else {
          // 从-1 -2开始一直递归到n<=1再出栈 最后返回相加值
          return fn(n-1) + fn(n-2)
      }
  }
  ```

  - 迭代实现

  ```js
  function fn(n) {
      if(n <= 1) {
          return n
      }
      let last // 指向新值
      let pre1 = 1 // 指向前1个值
      let pre2 = 0 // 指向前2个值
      for(let i = 2; i <= n; i++) {
          last = pre1 + pre2 // 先计算新值
          pre2 = pre1 // pre2移动到pre1
          pre1 = last // pre1移动到last
      }
      return
  }
  // 哈希表
  function fn(n) {
      // 数组形式的哈希表 第n个即数组长度为n+1
      let arr = new Array(n + 1).fill(0) // 默认填充0
      // 前两个数赋值
      arr[0] = 0
      arr[1] = 1
      for(let i = 2; i <= n; i++) {
          arr[i] = arr[i-1] + arr[i-2]
      }
      return arr[n]
  }
  ```


### 字符串出现的不重复最长长度

```js
// 思路
// 因为是无序字符 所以需要哈希表记录字符
// 用滑动窗口方法 以即将加入的下一个字符判断哈希表内是否出现重复
// 以此为条件 循环缩短窗口 直到窗口内哈希表不存在重复
// 再吸收字符 并判断结果值是否需要更新

function fn(source) {
    let max = 0 // 找最大值初始值就为0
    // 哈希表 记录滑动窗口内字符种类
    let map = new Set() // 因为不需要计数 用set就够了
    let start = 0 // 滑动窗口起始位置
    for (let end = 0; end < source.length; end++) {
        // 因为字符串不是按顺序排列 因此遇到重复的字符
        // 滑动窗口缩短不止一次 因此要用循环直到窗口内没有重复字符
        while (map.has(source[end])) {
            // 即将加入的字符在map中重复 则移动起始位置 缩短窗口
            // 因为要移动起始位置 因此原起始位置字符就要从map中移除
            map.delete(source[start])
            start++ // 移动起始位置
        }
        map.add(source[end]) // 将不重复的新字符添加到map
        if (max < end - start + 1) {
            // 当前窗口长度更长 更新max结果
            max = end - start + 1
        }
    }
    return max
}

// 验证
let str = "abcabcbb"
console.log('最长为' + fn(str)) // 3
```

### 使用setTimeout实现setInterval

- 用递归

  ```js
  function fn(callback, delay) {
      setTimeout(() => {
          fn(callback, delay)
          callback()
      }, delay)
  }
  fn(() => {
      console.log(111)
  }, 2000)
  ```

### 两数之和

- 见`算法.md`的`哈希表-数字之和-两数之和`
- 总结
  - 两数之和用到了哈希表记录另一半
  - 其实两数之和是将一个原数组分两次取用，先遍历一遍存到哈希表中，再遍历一遍用`target - num`匹配记录值，可以看作是两个数组中取值，所以`四数之和II`中从四个数组取值用的是和两数之和一个思路


### 三数之和

- 见`算法.md`的`哈希表-数字之和-三数之和`
- 总结
  - 三数之和没有用哈希表，是在第一层循环固定一个数后，第二层循环挑动另外两个数来组合三数之和
  - 用的是`if`判断来进行去重
  - 三数之和与四数之和都是从一个数组中取值，所以用同一个思路

### 找到字符串中第一个不重复字符的下标

```js
// 思路
// 先遍历字符串 用哈希表统计字符个数
// 再次遍历字符串 每遍历一个字符到哈希表中找对应个数
// 找到第一个个数为1的 返回其下标
function fn(str) {
    let map = {}
    for (let i = 0; i < str.length; i++) {
        let key = str[i]
        map[key] = (map[key] || 0) + 1
    }
    for (let i = 0; i < str.length; i++) {
        if(map[str[i]] === 1){
            return i
        }
    }
    return -1
}

// 验证
let str = 'abcabcbb'
console.log('第一个不重复字符下标：' + fn(str)) // -1
```

### 找到字符串所有排列组合

```js
// 思路
// 利用递归压栈出栈的顺序 每找到一个不重复字符
// 就递归找下一个可加入的字符 然后递归出栈到上一层 继续执行上一层的循环

function fn(str, arr = [], result = []) {
    // 递归出口 arr收集满了就添加到结果数组 返回上一层继续进行循环
    if (arr.length === str.length) {
        // 注意 这里要把arr转换成字符串
        // 否则arr作为闭包在整个过程中使用 最后都会清空
        result.push(arr.join(''))
        return
    }
    // 遍历str 寻找每个可加入arr的字符
    for (let i = 0; i < str.length; i++) {
        // 跳过重复字符
        if (arr.includes(str[i])) {
            continue
        }
        arr.push(str[i])
        // 填入字符 并继续递归遍历整个str 找可能的结果
        fn(str, arr, result)
        // 递归结束 出栈回来 则弹出当前arr.push进去的str[i]
        // 然后继续循环 找可能的字符
        arr.pop()
    }
    // 每一层递归结束 都向上返回result 直至最外层
    return result
}

// 验证
console.log('abc排列组合结果:' + fn('abc')) // abc,acb,bac,bca,cab,cba
```

### 冒泡排序

```js
// 思路
// 用两层循环 外层控制冒泡终点位置
// 因为每次冒泡完都会将最大/小值放到末尾 不用参与排序 因此排除在外
// 里层循环控制单趟排序 相邻元素两两对比交换

function fn(list) {
    let len = list.length
    // 注意 是<len-1 而不是<len 因为是当前元素和后一位对比 因此只取到末尾元素的前一个
    for (let j = 0; j < len - 1; j++) {
        for (let k = 0; k < len - 1 - j; k++) {
            if (list[k] > list[k + 1]) {
                [list[k], list[k + 1]] = [list[k + 1], list[k]]
            }
        }
    }
}

// 验证
let list = [34, 8, 64, 51, 32, 21]
fn(list)
console.log('冒泡排序：' + list) // 8,21,32,34,51,64
```

### 选择排序

```js
// 思路
// 形似冒泡排序 由两层循环组成
// 外层用来固定里层遍历的起始点 并且交换元素位置
// 里层找最小/大元素

function fn(list) {
    // 移动的是起始位置 所以循环终止条件都是数组末尾
    for (let j = 0; j < list.length; j++) {
        // 先设起始位置为最小值
        let minIndex = j
        for (let k = j + 1; k < list.length; k++) {
            if (list[minIndex] > list[k]) {
                // 找到更小的 更新索引
                minIndex = k
            }
        }
        // 里层循环遍历完 找到移动起始点到数组末尾的最小值 交换
        [list[j], list[minIndex]] = [list[minIndex], list[j]]
    }
}

// 验证
let list = [64, 25, 12, 22, 11]
fn(list)
console.log('选择排序：' + list) // [11,12,22,25,64]
```

### 快速排序

```js
// 思路
// 类似1~100累加的递归思路
// 将每层递归传入的数组切一半 小的放左边 大的放右边
// 直到递归传入的数组元素个数小于2 再一层一层向上返回
// 每层递归都将返回的数组降维 合并到当前层的数组
// 最后得到排序结果

function fn(list) {
    // 递归出口
    if (list.length < 2) {
        // 小于等于1 直接返回 因为已经是有序的
        return list
    }
    let mid = Math.floor(list.length / 2) // 中间位置
    let left = [] // 左数组
    let right = [] // 右数组
    for (let val of list) {
        // 注意 遍历时会取到中间值 必须要跳过 否则会死循环
        // 因为每次把中间值去掉 递归下去的数组才能越来越小
        if (val === list[mid]) {
            continue
        }
        if (val <= list[mid]) {
            left.push(val)
        } else {
            right.push(val)
        }
    }
    // 递归左右数组 将其结果合并成新数组
    return [...fn(left), list[mid], ...fn(right)]
}

// 验证
let list = [3, 6, 8, 10, 1, 2, 1]
console.log('快速排序：' + fn(list)) // [1,2,3,6,8,10]
```

### 插入排序

```js
// 思路
// 外层循环记录当前值 里层循环以当前值前一位开始
// 从后往前遍历 遇到比当前值大的 就往后移一位
// 直到前面的已经排好序 比当前值小 又因为大的往后移了
// 中间就出现空缺 就将当前值插到此处

function fn(list) {
    // 从第二个元素开始遍历 默认前面的已排序
    for (let j = 1; j < list.length; j++) {
        let current = list[j] // 记录当前值
        let pre = j - 1 // 前一个元素索引
        //  将当前元素与已排序部分的元素比较 找到合适的位置插入
        while (pre >= 0 && list[pre] > current) {
            list[pre + 1] = list[pre] // pre位置的值往后移
            pre-- // 往前移
        }
        // 此时小于current的没动 大于current的都往后移了一位
        // 中间空了 将current插到此处
        // 注意 此时pre因为最后pre-- 在目标位置前一位
        list[pre + 1] = current
    }
}

// 验证
let list = [4, 3, 2, 10, 12, 1, 5, 6]
fn(list)
console.log('插入排序：' + list) // [1,2,3,4,5,6,10,12]
```

### 树的深度优先搜索

- 见`算法.md`下`二叉树的递归遍历`

  ```js
  function fn(node, result = []) {
      if(node === null){
          // 递归出口
          return
      }
      result.push(node.value) // 中节点
      // 左右节点递归改为遍历子节点递归
      for(let val of node.children || []) {
          fn(val, result)
      }
      return result
  }
  ```

### 树的广度优先搜索

- 见`算法.md`下`二叉树的层序遍历`

  - 与深度搜索的区别在于，不用递归，要用队列

  ```js
  function fn(node, result = []) {
      let queue = []
      queue.push(node)
      // 用一个动态长度队列 一层一层取
      while (queue.length) {
          let size = queue.length
          let layer = [] // 记录每层节点值
          while (size--) {
              let n = queue.shift()
              layer.push(n.value)
              // 判断左右节点是否存在 改为 子节点是否存在 遍历入队列
              for (let val of n.children || []) {
                  queue.push(val)
              }
          }
          result.push(layer)
      }
      return result
  }
  ```

### 树节点过滤

- 后代节点符合条件，保留父节点

  ```js
  function fn(nodes, keyword) {
      function find(node) { // 找当前节点是否符合方法
          return node.label.indexOf(keyword) !== -1
      }
      let result = [] // 记录符合 条件 的节点
      if (!nodes || !nodes.length) {
          return result
      }
      for (let node of nodes) {
          // 先递归
          let child = fn(node.children, keyword)
          // 条件 子节点不为空 或 当前节点符合
          if (child.length || find(node)) {
              node.children = child // 不然到这改了children就丢失子节点了
              result.push(node)
          }
      }
      return result
  }
  ```

- 只保留符合的节点，不保留父节点

  ```js
  function fn(nodes, keyword) {
      function find(node) {
          return node.label.indexOf(keyword) !== -1
      }
      let result = []
      if (!nodes || !nodes.length) {
          return result
      }
      for (let node of nodes) {
          let child = fn(node.children, keyword)
          // 区别在这 不判断child是否为空 只看当前节点是否符合
          // 从而决定如何处理child
          if (find(node)) {
              // 符合 则保留层级结构
              node.children = child
              result.push(node)
          } else {
              // 不符合 则不管当前节点而是将其子节点展开 提升到当前层级
              result.concat(child)
          }
      }
      return result
  }
  ```

  
