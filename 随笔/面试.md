## 前端八股文

[文档](https://juejin.cn/post/7016593221815910408#heading-55)

[高级文档](https://juejin.cn/post/6941278592215515143?searchId=202406181750271102B44A611953C76546#heading-35)

### Vue底层实现原理

- 采用数据代理结合==发布者-订阅者模式==，当数据变动时，会触发监听对象的`setter`，==发布==消息给==订阅者==，触发相应的更新页面回调
- `Observer`数据监听器
  - 通过`Object.defineProperty`或`proxy`监听数据变动，定义`getter`和`setter`，当数据发生变化，就会触发`setter`，这时候监听器就会通知==订阅者==`Watcher`
- `Watcher`订阅者：作为==监听器==和==指令解析器==之间的桥梁，原理：
  1. 在自身实例化时，往订阅器里添加自己
  2. 每个订阅者身上都有`update`方法
  3. 当数据变化时，触发==指令解析器==中绑定的回调函数
- `Compile`指令解析器
  - 主要做的事是解析模板指令，将模板中变量替换成数据，然后==初始化渲染页面==，并将指令对应的节点==绑定更新函数==，添加订阅者，一旦数据有了变动，就会更新视图

### 谈谈对Vue生命周期的理解

- Vue实例在创建时，经过的一系列初始化过程，生命周期钩子就是某一阶段时触发的回调函数
  - `beforeCreate`：创建前，此时`data`和`methods`还未初始化
  - `created`：创建完毕，`data`初始化完成，但未挂载
  - `beforeMount`：挂载前，此时可以发请求获取数据
  - `mounted`：实例已经被挂载到真实DOM节点
  - `beforeUpdate`：当`data`中数据发生变化时，==触发==重新渲染==前==
  - `updated`：重新渲染完毕
  - `beforeDestory`：实例被销毁前，此时可以手动销毁一些方法
  - `destoryed`：实例销毁完毕
- 创建组件时的生命周期
  1. ==父组件==从创建(`beforeCreate`)到挂载到页面前(`beforeMount`)
  2. 然后再执行==子组件==从创建(`beforeCreate`)到挂载完成(`mounted`)
  3. 子组件==创建完毕后==，才继续执行父组件的挂载(`mounted`)
  4. 当子组件更新时，父组件会进入更新前(`beforeUpdate`)状态，在子组件更新周期完成后(`beforeupdate`和`updated`)，才执行父组件`updated`
  5. 当组件销毁时，父组件执行`beforeDestory`，才轮到子组件执行销毁周期(`beforeDestory`和`destoryed`)，然后父组件完成销毁(`destoryed`)

### 讲一下计算属性(`computed`)和监听属性(`watch`)

- 一般来说，`computed`和`watch`都能实现的功能，推荐用`computed`，因为`computed`有缓存功能，当其依赖的值发生变化时才会重新计算，而`watch`是只要触发了监听属性的`setter`就会执行，所以`watch`更适用于计算开销较大的操作

### 组件中的`data`为什么是一个函数

- 这主要是为了组件被复用时考虑，当存在多个同样的组件时，就会创建多个实例，如果`data`不是函数，而是对象的话，就会由于地址索引，影响到所有组件实例，为了保证组件之间==数据隔离==，`data`必须是一个函数的返回值

### 为什么`v-for`和`v-if`不建议一起使用

- 对于Vue2来说，`v-for`的优先级更高，这会导致每次循环时`v-if`都会执行，导致性能浪费

- 在Vue3中，`v-if`优先级更高，但还是建议避免这样使用，以免混淆

### `diff`算法核心原理

1. 对当前更新的节点同层级进行比较

2. 首先判断新旧节点是否完全一致，如果一致则退出

3. 否则判断新旧节点类型是否一致

   - 不一致
     1. 则将旧节点卸载并置为`null`
     2. 然后根据新节点类型调用不同处理方法
     3. 最后插入新节点

   - 一致
     1. 则更新节点内容

- (Vue`diff`算法比React更复杂，能够最大程度复用节点)

### React/Vue中key的作用

- 一是帮助`diff`算法执行时更快找到对应节点，高效更新虚拟DOM
  - Vue的`diff`算法中，会根据新节点`key`对比旧节点数组中的`key`，如果没找到则认为是新增节点
  - 如果没有`key`则会采用==遍历查找==找对应旧节点
- 二是数据变化时，避免==就地复用==带来的渲染错误

### Vue组件的通信方式

1. `props`父到子组件通信和`$emit`触发父组件监听方法
2. 全局事件总线
3. 父组件到后代组件的跨组件通信`provide`、`inject`

### 讲一下`nextTick`

- 执行时机
  - `updated`或`mounted`之后执行
- Vue更新是异步的，当数据发生变化，就会在事件循环中缓存数据变更操作，为避免不必要的操作和计算，`nextTick`会在队列中加入一个回调函数，并确保该函数在所有DOM操作完成后才调用

### 讲一下插槽

- 一种有三种插槽，默认插槽、具名插槽、作用域插槽

### 讲一下`keep-alive`

- 作用
  - 实现组件缓存，保持组件状态，避免因重复渲染导致性能问题
- 原理
  - Vue将真实DOM节点抽象成虚拟节点树，`keep-alive`就是基于虚拟节点，它将虚拟节点在`cache`对象中缓存起来，再在需要重新渲染时，将虚拟节点从`cache`对象中取出渲染

### 讲一下`mixins`

- 混入是当多个组件有重复逻辑时使用

### 讲一下你对Vuex的理解

- Vuex是专门为Vue开发的状态管理机，核心就是仓库`store`
- Vuex的状态存储是响应式的，仓库中状态发生变化，相应的组件也会更新
  1. 首先是通过`commit`触发`mutation`中定义的方法
  2. 然后对仓库中的状态进行更改

- 同时还存在`Module`，可以将单一仓库拆分为多个，并保持在单一状态树中

### 讲一下React中类组件和函数组件的区别

- 函数组件适用于简单组件，接收单个参数`props`，返回一个标签元素，并且没有`this`
- 而类组件继承`Component`类，可以设置`state`并直接使用`props`，可以实现复杂的组件

- 函数组件的重新渲染是返回新的标签元素，而类组件是创建一个新的实例

### hooks用过吗？

- 用过，`hooks`是为了让函数组件也可以使用`state`等React特性
- 分别有这么几个常用的：`useState`状态钩子、`useContext`共享状态钩子、`useReducer`action钩子、`useEffect`副作用钩子
  - ps：副作用指不直接与视图渲染相关的操作，如网络请求

### React组件通信方式

1. 父组件向子组件传值，用`props`
2. 子组件向父组件传值，父组件用`props`传入函数给子组件，子组件调用传入参数
3. 父组件向后代组件传值，用`context`，创建一个组件树的共享数据容器
4. 任意层级组件传值，通过消息订阅和发布

### setState是同步还是异步执行

- 在React事件中是==异步==，因为会将更新操作放到更新队列里，批量执行，而不是立即更新
- 但在DOM事件或定时器中是==同步==执行

### React生命周期

- 组件被创建时，执行`constructor`→`getDerivedStateFromProps`→`render`→`componentDidMount`
- 组件更新时：执行`getDerivedStateFromProps`→`shouldComponentUpdate`→`render()`→`getSnapshotBeforeUpdate`→`componentDidUpdate`
- 组件卸载时：执行`componentWillUnmount`

### 说一下react-filber

- 根据优先级对主线程中的执行任务进行调度

### React事件绑定原理

- 事件不是直接绑在DOM节点，而是对原生事件进行封装，然后绑定到==根组件==统一监听

### webpack做过那些优化？开发效率、打包策略等

#### 优化构建速度

1. 使用==多线程==，如`thread-loader`
   - 但仅限于特别耗时的，否则还不如直接构建速度快
2. 使用==热更新==，只对修改的模块进行打包，在程序运行时，删除、增加模块不会使页面重新刷新
   - 但是重新加载JS会使页面重新加载，因此需要手动设置规则只对某JS文件进行加载
3. 使用`oneof`，这样在匹配到第一个符合的规则时就会停止遍历
4. 缩小打包范围，使用`exclude/include`排除如`node_module`这样的包
5. 利用缓存`cache`，只对修改的文件进行检查，构建速度会有提升
6. 使用`babel`插件，因为`babel`编译时会为每个文件添加辅助代码，而这个插件可以使辅助代码作为独立模块==引入==
7. 使用`code split`，因为打包时会将所有JS文件打包成一个，用`code split`可以将其分割成多个JS文件，并按需引入

#### 优化打包体积

1. 使用静态图片压缩插件
2. 提取公共资源
3. 使用`Tree shaking`，去除无用的JS文件，不过是webpack默认开启的

### 简述一下Babel编译过程

- `babel`是一个工具链，将`ES6`语法编写为==向后兼容==的JS语法，是通过==抽象语法树==完成代码的转译

### http和https

#### 基本概念

- `http`是客户端和服务端应答的TCP协议，用于从服务端传输==超文本==到本地的传输协议
- `https`则是在`http`基础上增加`SSL`层，对==证书==、==密钥==、==数据完整性==进行验证

#### http和https区别和优缺点

- `http`是明文传输，`https`是==加密传输协议==，所以要更安全
- `http`端口默认`80`，`https`端口默认`443`
- `http`和`https`都属于==应用层==协议，且都是无状态的，只是在应用层横向加了个`SSL`协议
- `https`会使页面加载时间延长
- `https`缓存方面效能更低，如加密传输协议==无法直接缓存==，而是==重新建立连接==
  - 以及握手阶段，需要验证过程，而`http`只需向服务端发送请求，服务端就会返回数据

#### https协议工作原理

1. 客户端访问服务器时，会==要求==服务器建立`SSL`连接
2. 服务器收到请求后，会==将证书传给客户端==
3. 客户端和服务端协商`SSL`==安全等级==
4. 客户端和服务端通过协商一致的安全等级，==建立会话密钥==，然后通过==公钥==加密会话密钥，传给客户端
5. 服务器通过==私钥==解密会话密钥
6. 服务端通过==会话密钥==加密与客户端之间的通信

### 阐述TCP三次握手四次挥手

1. 第一次握手：建立连接时，客户端发送`syn包`到服务器，并进入`syn_sent`状态，==等待服务器确认==
   - `syn`：同步序列号
2. 第二次握手：服务器收到并确认客户端`syn包`，并回复`syn + ack包`，进入`syn_recv`状态
3. 第三次握手：客户端收到`syn + ack包`，并向服务器发送`ack包`，发送完进入==连接成功==状态

- 四次挥手：**客户端**发送==释放报文==(第一次)，**服务端**回复==确认报文==(第二次)，等发完最后的数据后，**服务端**发送==释放报文==(第三次)，**客户端**收到后回复==确认报文==(第四次)，并在稍后关闭连接，而服务端收到确认报文后是立即结束连接

### TCP/IP是如何保证数据包传输的可靠性

- 对数据流==分段并编号==，然后通过==ack回复==和==超时重发==两个机制保证
  1. 发送方把已发送的数据包保留在==缓冲区==
  2. 并为每个==已发送==的包设置一个==超时定时器==，定时器超时前收到应答的话，就会释放该数据包占用的缓冲区，否则重传，直到达到最大重试次数
  3. 接收方收到数据包后，先进行校验，如果数据正确则交给上层协议，然后回复一个累计应答包

### TCP和UDP的区别

- `TCP`==需要建立连接==，可靠性更强，而`UDP`是无需建立连接，直发数据
- `TCP`仅支持==单播传输==，`UDP`支持单播、多播、广播
- `UDP`传输效率更高，实时性好

### HTTP跨域问题

- 原理
  - 浏览器同源策略所致，当前网站不能执行其他网站==脚本==
- 解决方式
  - `jsonp`：通过`<script>`标签，发送请求
    - 缺点：只支持`get`请求
  - `postMessage`发送数据
  - `proxy`代理：服务器端设置代理
  - `CORS`：服务器设置`Access-Control-Allow-Origin`响应头，允许其他域名的访问

### Cookie、sessionStorage、localStorage之间的区别

- 相同点
  - 都存在客户端
- 区别
  - `cookie`数据不能超过4k，`session`和`local`要大得多
  - `cookie`在设置的过期时间之前一直有效，`local`==永久==存储，`session`在当前窗口关闭后自动清除
  - `cookie`数据会随请求带往服务器，`session`和`local`数据都存在本地

### TCP粘包问题

- 出现原因
  - 发送的若干数据包在接收时粘成一包，后一包数据头接前一包数据尾
- 解决方法
  1. TCP提供了强制传送的操作指令，不必等缓冲区满即会发送
     - 缺点：会降低网络发送效率
  2. 对于接收方，可以通过提高接收进程优先级，使其即时接收数据
     - 缺点：频率高时，还是可能会出现粘包
  3. 程序上控制，分多次接收，然后合并
     - 缺点：效率较低

### 从输入URL到页面加载的全过程

1. 浏览器根据URL查看缓存，是否存在该地址页面，如果有则显示
2. 如果缓存中没找到，则向DNS服务器发起请求，获得对应IP地址
   - DNS服务器就属于UDP
3. 根据IP地址，建立TCP连接
4. 客户端发起HTTP请求
5. 服务器返回请求结果
6. 当请求结束时，关闭TCP连接
7. 浏览器根据HTML内容，构建DOM树、根据CSS样式布局绘制页面，再进行JS解析

### JS数据类型如何检测

1. 用`typeof`
   - 缺点是不能对数组、对象和`null`进行区分
2. `instanceof`
   - 优点是可以区分数组、对象和函数，但是缺点是基本类型数据无法区分
3. `Object.prototype.toString.call(变量)`
   - 可以精准判断类型
   - 不过返回的是`[object String]`、`[object Array]`等，使用`Object`身上的`toString`方法最好是封装成函数
   - ==变量==自身带有内置的`toString`方法，是将自身转变为字符串，而`Object`原型身上的`toString`方法则是返回类型，==变量==的`toString`是对`Object`原型链上的覆写

### var、let、const之间的区别

- `var`定义的变量==没有块的概念，可以跨块访问==，但是不能跨函数
  - `var`可以==先使用后声明==，存在变量提升
  - `var`可以在作用域内声明重复变量，而`let`、`const`不行
- `let`定义的变量只能在块作用域内访问
  - `let`必须先声明后使用
- `const`定义的常量，使用时必须赋值，只能在块作用域内访问

### JS垃圾回收机制

- 回收机制会定期处理不再使用的变量，释放内存
- 常见的内存泄露有全局变量、闭包、DOM元素的引用、定时器

### 作用域和作用域链

- 作用域就是函数和变量可访问的范围，分全局作用域和函数作用域
- 作用域链就是变量在当前作用域下取值，如果找不到则向上查找，直到全局作用域，这个查找的过程即作用域链

### 闭包是什么？有什么作用？

- 闭包其实就是嵌套函数，内部函数引用了外部函数的变量
- 闭包的作用
  - 一是保护函数变量不被释放
  - 二是保护私有变量不被污染

### JS中this指向的问题

- 作为普通函数执行时，`this`指向`window`
- 作为对象的方法被调用时，指向该对象
- 在构造器中使用时，指向类实例化的对象
- 在箭头函数中，指向父函数调用者
- 使用`call`、`bind`等情况下，`this`指向传入的参数

### 请解释一下原型和原型链

- 原型是指定义的对象会包含一个预定的属性，`__proto__`或者`prototype`，指向它的原型对象
- 原型链指对象间都有指向其原型链接，这个原型又可以有自己的原型，形成一个链条
  - 访问一个对象的属性时，JS会沿着原型链向上搜索，直到找到属性或到达原型链末尾

### 请讲一下new运算符实现的原理

1. 首先创建一个==空对象==
2. 将对象的原型设置为函数的原型对象
3. 然后让函数的`this`指向这个对象，执行构造函数代码
4. 最后返回创建的对象

### 解释一下什么是事件循环

- 因为JS是单线程，为了防止单一函数执行时间过长，导致阻塞，会将异步执行的方法放到队列里面，等主线程执行完毕再执行队列中的任务
  - 队列又分为微任务队列和宏任务队列，微任务队列就比如`Promise.then`，宏任务队列就比如定时任务
- 简单来说经过以下几个步骤
  1. js执行，遇到同步代码就压入执行栈，遇到异步代码就丢给WebAPI，接着执行同步代码
  2. 此期间，webAPI会将异步代码的回调函数放入队列等待执行
  3. 执行栈为空后，事件循环会取出微任务执行，清空微任务后，再到宏任务队列取第一个任务执行，执行完毕，再查看微任务队列中是否有任务，如果有则执行清空微任务，再去宏任务找，如此循环，直到清空所有任务
- (一般不问)`node`运行环境下，事件循环还会添加一些I/O读写操作

### 介绍下Async/Await是如何实现同步执行异步操作

- 其实就是一个语法糖，本质是将`await`前后部分代码放入==生成器函数==，利用其特性将异步代码写成同步的形式，`await`的位置相当于`yield`，并对`await`后的`promise`对象添加一个`.then`然后执行`next()`方法，使得`prosmise`对象状态成功后才继续往下执行

### 介绍一下节流、防抖以及应用

- 节流
  - 指规定时间内，无论触发多少次，只调用一次
  - 应用
    - 需要高频点击或触发的时候
- 防抖
  - 无论触发多少次，等待时间过了，才会触发一次
  - 应用
    - 如搜索框搜索输入内容

### 浏览器重绘和重排的区别

- 重绘：元素外观发生改变
- 重排/回流：重新排列布局

### 如何触发重排和重绘

- 改变DOM的操作都会触发
  - 增删改DOM节点
  - `display:none`隐藏DOM节点
  - 移动DOM节点
  - 添加样式
  - 用户行为，如改变窗口大小

### 如何避免重绘或重排

- 元素定位改为`absolute`或`fixed`，即可脱离文档流，再修改样式就不会重排
- 集中改变样式，不要一条条修改DOM的样式

### Git常用命令有哪些

- `git branch`(查看/创建分支)、`git checkout`(切换分支)、`git merge`(合并分支)

### HTML5新特性、语义化

- 新增`header`、`footer`等标签，优点是即使没CSS样式，页面也有很好的结构效果，使代码结构更清晰易读

### CSS样式优先级

- `!important`>内联样式>ID选择器>类、属性、伪类选择器>元素、伪元素选择器>关系、通配符选择器

### Position属性值有哪些区别

- `fixed`：相对于浏览器窗口定位，脱离文档流
- `relative`：相对于元素自身定位，不会脱离文档流
- `absolute`：相对于最近的定位父元素定位，脱离文档流
- `sticky`：先按文档流定位，然后相对于==最近的块级父元素==定位，当元素位置在特殊阈值时，为固定定位

### 讲一下盒模型

- 盒模型是指由边距、边框、填充和内容组成的方盒
- 标准盒模型指`margin`、`border`、`padding`、`width`
- IE盒模型值`margin`、`width`，`width`包含了`padding`和`border`

### 讲一下BFC

- 是一个独立渲染区域，规定容器内部如何布局，并且容器内子元素不会影响到外面的元素
- `overflow`开启滚动显示或脱离文档流的定位方式即可开启BFC

## 手写代码题

### JS数组去重

#### 使用set

- `set`是JS内建对象，只允许存储唯一值

  - `set`只能用`for of`遍历，是一个可迭代对象

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  let t2 = [...new Set(t)] // [1, 2, 3, 4]
  ```

#### 使用filter

- 用`indexOf`找首个目标元素索引位置与当前元素索引位置是否相同决定是否返回该元素

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  let t2 = t.filter((ele, index) => t.indexOf(ele) === index)
  ```

#### 使用reduce

- `reduce`能用在所有归并一个结果的执行逻辑上

  - 需要用数组的`includes`方法

  ```js
  let t = [1, 2, 3, 4, 4, 3, 2, 1]
  // 初始值为[]空数组
  let t2 = t.reduce((pre,cur) => {
      // 判断当前元素在结果数组中是否存在
      if(!pre.includes(cur)) {
          // 不存在 则填入数组
          pre.push(cur)
      }
      // 记得要把结果数组返回 作为下一轮循环的pre参数
      return pre
  }, [])
  ```

### 将数字每千分位用逗号隔开

- 使用`toLocaleString`

  ```js
  let num = 1234567.89;  
  let string = num.toLocaleString()
  console.log(string);  // 输出 可能 是 "1,234,567.89"
  // 如果想不受本地化设置影响 可以传入参数
  let string2 = num.toLocaleString('en-US')
  ```

### 手写防抖/节流

#### 防抖

- 指事件触发后，N秒内只能执行==一次==，N秒内再次触发则重新计算执行时间

- 适用于==延迟触发==的场景

  ```js
  function delounce(func, delay) {
      let timer = null
      // 这里不要用箭头函数 为了保存它自身被调用时的this
      return function (...params) {
          // 注意接收参数
          clearTimeout(timer)
          // 触发后 delay后执行一次
          timer = setTimeout(() => {
              // 为保证func内的this指向 要用call方法
              func.apply(this, params)
          }, delay)
      }
  }
  ```

#### 节流

- ==连续触发==，但N秒内只执行一次

- 适用于==控制频率==的场景

  ```js
  function throttle(func, delay) {
      let timer = false
      return function (...params) {
          if(!timer){
              // 触发后 立即执行 但是delay内不能再次执行
              func.apply(this, params)
              // 执行后一段时间内就不能再触发 将标识置为true
              timer = true
              // 并设置定时器 一段时间后再将标识置为false
              setTimeout(() => {
                  timer = false
              }, delay)
          }
      }
  }
  ```

#### Vue中使用防抖/节流

- 因为绑定事件的方法必须是防抖/节流返回的函数，因此要用赋值的写法，先执行防抖节流函数将其返回值赋给响应式变量

  ```js
  new Vue({
      el: '#root',
      data: {
  		fn3: null, // 先声明变量
      },
      created(){
          // 将返回函数作为fn3值
          this.fn3 = this.fn1(this.fn2, 2000)
      },
      methods: {
          fn1(func, delay) {
              let timer = false
              return (...params) => {
                  if (!timer) {
                      func.apply(this, params)
                      timer = true
                      setTimeout(() => {
                          timer = false
                      }, delay)
                  }
              }
          },
          fn2() {
              console.log(111)
          },
          fn3: this.fn1(this.fn2, 1000), // 这种不行 因为此时还没有fn1 fn2
          fn3(){
              // 这种不行 必须是fn3本身是fn1返回值
              return this.fn1(this.fn2, 2000)
          }
      }
  })
  ```


### 手写Promise

- 简单来说`new Promise`传入的函数会==立即(同步)执行==，而形参的`resolve reject`是==异步==执行

  - `then`的工作就是往链式的==前一个==`promise对象`身上用==闭包==记录自己的回调函数、`resolve reject`，等自己的方法执行时，用==闭包保存==的`resolve/reject`==修改自身状态==

  ```js
  function Promise(callback){
      // 每个Promise对象都有的以下属性
      this.status = 'pending'
      this.value = null
      this.fulfilledCallback = [] // 成功回调
      this.rejectedCallback = [] // 失败回调
      const resolve = (value) => {
          setTimeout(() => { // resolve/reject是异步
              if(this.status !== 'pending'){
                  return
              }
              // 改变状态、赋值 并执行绑定在自身的下一级promise对象回调方法
              this.status = 'fulfilled'
              this.value = value
              for(let fn of this.fulfilledCallback){
                  fn()
              }
          })
      }
      const reject = (err) => {
          setTimeout(() => {
              if(this.status !== 'pending'){
                  return
              }
              this.status = 'rejected'
              this.value = err
              for(let fn of this.rejectedCallback){
                  fn()
              }
          })
      }
      // 每一步执行都要用try catch包裹
      try{
          callback(resolve, reject) // 创建promise对象的回调函数是立即执行
      } catch(err){
          reject(err)
      }
  }
  Promise.prototype.then = function (onFulfilled, onReject){
      // 在创建promise对象前 先处理未传入回调的情况
      if(typeof onFulfilled !== 'function'){
          onFulfilled = (value) => { return value }
      }
      if(typeof onReject !== 'function'){
          onReject = (err) => { throw err }
      }
      // 创建promise对象 传入特定回调函数逻辑
      return new Promise((resolve, reject) => {
          // 公共逻辑部分
          let common = (fn) => {
              setTimeout(() => {
                  try {
                      let result = fn(this.value)
                      if(result instanceof Promise){
                          result.then(value => {
                              resolve(value)
                          }, err => {
                              reject(err)
                          })
                      } else {
                          resolve(result)
                      }
                  } catch(err){
                      reject(err)
                  }
              })
          }
          // 注意 读取的是上一级promise对象属性
          if(this.status === 'fulfilled'){
              common(onFulfilled)
          } else if(this.status === 'rejected'){
              common(onReject)
          } else if(this.status === 'pending'){
              // 给上一级promise对象绑定当前promise对象回调
              this.fulfilledCallback.push(() => {
                  common(onFulfilled)
              })
              this.rejectedCallback.push(() => {
                  common(onReject)
              })
          }
      })
  }
  Promise.prototype.catch = function (callback) {
      // catch还是复用then 只不过catch传入的单个回调作为then的失败回调
      return this.then(null, callback)
  }
  Promise.all = function (promise_list) {
      // 还是返回promise对象
      return Promise((resolve, reject) => {
          // 处理传入参数不符合条件的情况
          if(!Array.isArray(promise_list)){
              throw '必须传入数组'
          }
          for(let val of promise_list){
              if(val instanceof Promise){
                  throw '必须传入promise对象'
              }
          }
          // 计数统计promise完成数量
          let count = 0
          let total = promise_list.length
          // 因为返回的值是成功后的数组 所以用数组记录结果
          let result = []
          // 这里要用for let i的形式遍历
          // 因为循环内部是异步 需要用索引记录在结果数组中第几位
          for(let i = 0; i < total; i++){
              // 通过then取值
              promise_list[i].then(value => {
                  count++ // 计数增加
                  result[i] = value // 对应位置填结果值
                  // 如果计数结束 将结果数组作为Promise.all返回值
                  if(count === total){
                      resolve(result)
                  }
              }, err => {
                  // 有一个promise对象执行失败 Promise.all返回报错信息
                  reject(err)
              })
          }
      })
  }
  ```

### 手写深拷贝

- 使用`JSON`API进行深拷贝，会有几个问题，无法拷贝属性值为`undefined`、`Date`对象、函数、正则

  ```js
  // 用哈希表记录遍历过的对象
  function deepClone(source, hash = new Map()){
      if(typeof source !== 'object'){
          // 基本数据类型 直接返回
          return source
      }
      // 如果是日期或正则对象则直接返回一个新对象
      if(source instanceof Date){
          return new Date(source)
      }
      if(source instanceof RegExp){
          return new RegExp(source)
      }
      if(hash.has(source)){
          // 哈希表中已经有同引用的对象 直接返回记录值 防止循环引用
          return hash.get(source)
      }
      // 准备一个容器装深拷贝结果
      let clone = Array.isArray(source)? [] : {}
      // 将当前对象存入哈希表 防止循环引用
      hash.set(source, clone)
      // 遍历 将元素/属性取出
      for(let key in source){
          // 判断是否是自身的属性 因为for in会取到原型链的属性
          if(source.hasOwnProperty(key)){
              // 递归拷贝每一个属性
              clone[key] = deepClone(source[key], hash)
          }
      }
      // 返回深拷贝后的结果
      return clone
  }
  ```


### 手写new操作符

```js
function myNew(constructor, ...params) {
    // 1、创建空对象
    let obj = new Object()
    // 2、将这个空对象原型指向构造函数原型
    obj.__proto__ = constructor.prototype
    // 3、以这个新对象作为构造函数的this执行
    let result = constructor.apply(obj, params)
    // 4、判断传入的构造函数是否返回了一个对象
    // 如果构造函数返回了一个对象 则以这个返回值为结果 其身上不一定有构造函数中的属性方法
    // 如果没有返回一个对象 则返回obj作为结果 obj经过构造函数 已经为其身上添加了属性方法
    return typeof result === 'object'? result : obj
}
```

### 函数柯里化

- 柯里化简单来说就是==返回值为函数==，并且应用==闭包、递归==将外层变量存下来进行传递

  - 注：`函数.length`是获得==函数的形参数量==

- 柯里化的几个题目，都是`fn(1)(3)(1,4)`这种形式

  1. 将一个函数柯里化

     ```js
     function target(a, b, c) {
         return a + b + c
     }
     function curry(fn) {
         if(typeof fn !== 'function') {
             throw '必须传入函数'
         }
         // 必须要用命名函数 因为要递归
         return function curried(...params) {
             // 递归就一定要有出口 比如本题递归出口就是参数数量
             if(params.length >= fn.length){
                 // 如果 累计 传入参数数量 大于等于 fn形参数 则传入fn返回结果
                 // 注意 改变fn的this指向
                 return fn.apply(this, params)
             } else {
                 // 传入参数数量不足 则返回一个新的函数 用来接收后续参数
                 // 主要是为了在未执行fn返回最终结果前 缓存 传入参数 然后在递归出口执行最终结果
                 return function (...params2) {
                     // 用了rest参数params是数组 将其合并params2新传入参数
                     // curried执行结果分 新函数 或 fn返回值
                     return curried.apply(this, params.concat(params2))
                 }
             }
         }
     }
     let fn = curry(target)
     console.log(fn(1, 2)(3)) // 6
     console.log(fn(1, 2)(3, 4)) // 6
     ```
     
  2. 实现`sum(1)(2)(3, 4)`
  
     ```js
     // 注意这里一定要用rest参数将其改编成数组 方便后面缓存参数
     function sum(...params) {
         // 这里不能直接返回函数 因为要以toString为递归出口
         function curried(...params2) {
             // 用外层params数组做闭包 缓存参数
             params.push(...params2)
             // 返回自身函数
             return curried
         }
         // 设置递归出口 被console.log输出时执行 覆写toString方法
         curried.toString = () => {
             // 取出缓存的参数 进行运算
             return params.reduce((pre, cur) => {
                 return pre + cur
             }, 0)
         }
         // 返回声明的函数
         return curried
     }
     console.log(sum(1, 2)(3)(4)) // 10
     
     // 另一种实现方式 递归出口为传入一个空函数 sum(1)(2)()
     function sum(...params) {
         function curried(...params2) {
             if(params2.length) {
                 // 参数不为空 则缓存参数
                 params.push(...params2)
                 return curried
             } else {
                 // 递归出口 参数为空 进行运算
                 return params.reduce((pre, cur) => {
                     return pre + cur
                 }, 0)
             }
         }
         return curried
     }
     console.log(sum(1)(2)(3, 4)()) // 10
     ```
     
     
