## 前端八股文

### webpack做过那些优化？开发效率、打包策略等

#### 优化构建速度

1. 使用==多线程==，如`thread-loader`
   - 但仅限于特别耗时的，否则还不如直接打包速度快
2. 使用==热更新==，只对修改的模块进行打包，在程序运行时，删除、增加模块不会使页面重新刷新
   - 但是重新加载JS会使页面重新加载，因此需要手动设置规则只对某JS文件进行加载
3. 使用`oneof`，这样在匹配到第一个符合的规则时就会停止遍历
4. 缩小打包范围，使用`exclude/include`排除如`node_module`这样的包
5. 利用缓存`cache`，只对修改的文件进行检查，打包速度会有提升
6. 使用`babel`插件，因为`babel`编译时会为每个文件添加辅助代码，而这个插件可以使辅助代码作为独立模块==引入==
7. 使用`code split`，因为打包时会将所有JS文件打包成一个，用`code split`可以将其分割成多个JS文件，并按需引入

#### 优化打包体积

1. 使用静态图片压缩插件
2. 提取公共资源
3. 使用`Tree shaking`，去除无用的JS文件，不过是webpack默认开启的

### 简述一下Babel编译过程

- `babel`是一个工具链，用`ES6`语法编写为==向后兼容==的JS语法，是通过==抽象语法树==完成代码的转译

### http和https

#### 基本概念

- `http`是客户端和服务端应答的TCP协议，用于从服务端传输==超文本==到本地的传输协议
- `https`则是在`http`基础上增加`SSL`层，对==证书==、==密钥==、==数据完整性==进行验证

#### http和https区别和优缺点

- `http`是明文传输，`https`是==加密传输协议==，所以要更安全
- `http`端口默认`80`，`https`端口默认`443`
- `http`和`https`都属于==应用层==协议，且都是无状态的，只是在应用层横向加了个`SSL`协议
- `https`会使页面加载时间延长
- `https`缓存方便效能更低，如加密传输协议==无法直接缓存==，而是==重新建立连接==
  - 以及握手阶段，需要验证过程，而`http`只需向服务端发送请求，服务端就会返回数据

#### https协议工作原理

1. 客户端访问服务器时，会==要求==服务器建立`SSL`连接
2. 服务器收到请求后，会==将证书传给客户端==
3. 客户端和服务端协商`SSL`==安全等级==
4. 客户端和服务端通过协商一致的安全等级，==建立会话密钥==，然后通过==公钥==加密会话密钥，传给客户端
5. 服务器通过==私钥==解密会话密钥
6. 服务端通过==会话密钥==加密与客户端之间的通信

### 阐述TCP三次握手四次挥手

1. 第一次握手：建立连接时，客户端发送`syn包`到服务器，并进入`syn_sent`状态，==等待服务器确认==
   - `syn`：同步序列号
2. 第二次握手：服务器收到并确认客户端`syn包`，并回复`syn + ack包`，进入`syn_recv`状态
3. 第三次握手：客户端收到`syn + ack包`，并向服务器发送`ack包`，发送完进入==连接成功==状态

- 四次挥手：**客户端**发送==释放报文==(第一次)，**服务端**回复==确认报文==(第二次)，等发完最后的数据后，**服务端**发送==释放报文==(第三次)，**客户端**收到后回复==确认报文==(第四次)，并在稍后关闭连接，而服务端收到确认报文后是立即结束连接

### TCP/IP是如何保证数据包传输的可靠性

- 对数据流==分段并编号==，然后通过==ack回复==和==超时重发==两个机制保证
  1. 发送方把已发送的数据包保留在==缓冲区==
  2. 并为每个==已发送==的包设置一个==超时定时器==，定时器超时前收到应答的话，就会释放该数据包占用的缓冲区，否则重传，直到达到最大重试次数
  3. 接收方收到数据包后，先进行校验，如果数据正确则交给上层协议，然后回复一个累计应答包

### TCP和UDP的区别

- `TCP`==需要建立连接==，可靠性更强，而`UDP`是无需建立连接，直发数据
- `TCP`仅支持==单播传输==，`UDP`支持单播、多播、广播
- `UDP`传输效率更高，实时性好

### HTTP跨域问题

- 原理
  - 浏览器同源策略所致，当前网站不能执行其他网站==脚本==
- 解决方式
  - `jsonp`：通过`<script>`标签，发送请求
    - 缺点：只支持`get`请求
  - `postMessage`发送数据
  - `proxy`代理：服务器端设置代理
  - `CORS`：服务器设置`Access-Control-Allow-Origin`响应头，允许其他域名的访问

### Cookie、sessionStorage、localStorage之间的区别

- 相同点
  - 都存在客户端
- 区别
  - `cookie`数据不能超过4k，`session`和`local`要大得多
  - `cookie`在设置的过期时间之前一直有效，`local`==永久==存储，`session`在当前窗口关闭后自动清除
  - `cookie`数据会随请求带往服务器，`session`和`local`数据都存在本地

### TCP粘包问题

- 出现原因
  - 发送的若干数据包在接收时粘成一包，后一包数据头接前一包数据尾
- 解决方法
  1. TCP提供了强制传送的操作指令，不必等缓冲区满即会发送
     - 缺点：会降低网络发送效率
  2. 对于接收方，可以通过提高接收进程优先级，使其即时接收数据
     - 缺点：频率高时，还是可能会出现粘包
  3. 对于接收方，可以人为控制分多次接收，然后合并
     - 缺点：效率较低

### 从输入URL到页面加载的全过程

1. 浏览器根据URL查看缓存，是否存在该地址页面，如果有则显示
2. 如果缓存中没找到，则向DNS服务器发起请求，获得对应IP地址
   - DNS服务器就属于UDP
3. 根据IP地址，建立TCP连接
4. 客户端发起HTTP请求
5. 服务器返回请求结果
6. 当请求结束时，关闭TCP连接
7. 浏览器根据HTML内容，构建DOM树、根据CSS样式布局绘制页面，再进行JS解析

### 浏览器重绘和重排的区别

- 重绘：元素外观发生改变
- 重排/回流：重新排列布局

### 如何触发重排和重绘

- 改变DOM的操作都会触发
  - 增删改DOM节点
  - `display:none`隐藏DOM节点
  - 移动DOM节点
  - 添加样式
  - 用户行为，如改变窗口大小

### 如何避免重绘或重排

- 元素定位改为`absolute`或`fixed`，即可脱离文档流，再修改样式就不会重排
- 集中改变样式，不要一条条修改DOM的样式

### Vue底层实现原理

- 采用数据代理结合==发布者-订阅者模式==，当数据变动时，会触发监听对象的`getter`和`setter`，==发布==消息给==订阅者==，触发相应的更新页面回调
- `Observer`数据监听器
  - 通过`Object.defineProperty`或`proxy`监听数据变动，定义`getter`和`setter`，当数据发生变化，就会触发`setter`，这时候监听器就会通知==订阅者==`Watcher`
- `Watcher`订阅者：作为==监听器==和==指令解析器==之间的桥梁，主要做：
  1. 在自身实例化时，往订阅器里添加自己
  2. 每个订阅者身上都有`update`方法
  3. 当数据变化时，订阅器调用订阅者身上的`update`方法，从而触发==指令解析器==中绑定的回调函数
- `Compile`指令解析器
  - 主要做的事是解析模板指令，将模板中变量替换成数据，然后==初始化渲染页面==，并将指令对应的节点==绑定更新函数==，添加监听数据的订阅者，一旦数据有了变动，就会更新视图