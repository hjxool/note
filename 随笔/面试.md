## 前端八股文

[文档](https://juejin.cn/post/7016593221815910408#heading-55)

### Vue底层实现原理

- 采用数据代理结合==发布者-订阅者模式==，当数据变动时，会触发监听对象的`getter`和`setter`，==发布==消息给==订阅者==，触发相应的更新页面回调
- `Observer`数据监听器
  - 通过`Object.defineProperty`或`proxy`监听数据变动，定义`getter`和`setter`，当数据发生变化，就会触发`setter`，这时候监听器就会通知==订阅者==`Watcher`
- `Watcher`订阅者：作为==监听器==和==指令解析器==之间的桥梁，主要做：
  1. 在自身实例化时，往订阅器里添加自己
  2. 每个订阅者身上都有`update`方法
  3. 当数据变化时，订阅器调用订阅者身上的`update`方法，从而触发==指令解析器==中绑定的回调函数
- `Compile`指令解析器
  - 主要做的事是解析模板指令，将模板中变量替换成数据，然后==初始化渲染页面==，并将指令对应的节点==绑定更新函数==，添加监听数据的订阅者，一旦数据有了变动，就会更新视图

### 谈谈对Vue生命周期的理解

- Vue实例在创建时，经过的一系列初始化过程，生命周期钩子就是某一阶段时触发的回调函数
  - `beforeCreate`：创建前，此时`data`和`methods`还未初始化
  - `created`：创建完毕，`data`初始化完成，但未挂载
  - `beforeMount`：挂载前，此时可以发请求获取数据
  - `mounted`：实例已经被挂载到真实DOM节点
  - `beforeUpdate`：当`data`中数据发生变化时，==触发==重新渲染==前==
  - `updated`：重新渲染完毕
  - `beforeDestory`：实例被销毁前，此时可以手动销毁一些方法
  - `destoryed`：实例销毁完毕
- 创建组件时的生命周期
  1. ==父组件==从创建(`beforeCreate`)到挂载到页面前(`beforeMount`)
  2. 然后再执行==子组件==从创建(`beforeCreate`)到挂载完成(`mounted`)
  3. 子组件==创建完毕后==，才继续执行父组件的挂载(`mounted`)
  4. 当子组件更新时，父组件会进入更新前(`beforeUpdate`)状态，在子组件更新周期完成后(`beforeupdate`和`updated`)，才执行父组件`updated`
  5. 当组件销毁时，父组件执行`beforeDestory`，才轮到子组件执行销毁周期(`beforeDestory`和`destoryed`)，然后父组件完成销毁(`destoryed`)

### 讲一下计算属性(`computed`)和监听属性(`watch`)

- 一般来说，`computed`和`watch`都能实现的功能，推荐用`computed`，因为`computed`有缓存功能，当其依赖的值发生变化时才会重新计算，而`watch`是只要触发了监听属性的`setter`就会执行，所以`watch`更适用于计算开销较大的操作

### 组件中的`data`为什么是一个函数

- 这主要是为了组件被复用时考虑，当存在多个同样的组件时，就会创建多个实例，如果`data`不是函数，而是对象的话，就会由于地址索引，影响到所有组件实例，为了保证组件之间==数据隔离==，`data`必须是一个函数的返回值

### 为什么`v-for`和`v-if`不建议一起使用

- 对于Vue2来说，`v-for`的优先级更高，这会导致每次循环时`v-if`都会执行，导致性能浪费

- 在Vue3中，`v-if`优先级更高，但还是建议避免这样使用，以免混淆

### `diff`算法核心原理

1. 对当前更新的节点同层级进行比较

2. 首先判断新旧节点是否完全一致，如果一致则退出

3. 否则判断新旧节点类型是否一致

   - 不一致
     1. 则将旧节点卸载并置为`null`
     2. 然后根据新节点类型调用不同处理方法
     3. 最后插入新节点

   - 一致
     1. 则更新节点内容

- (Vue`diff`算法比React更复杂，能够最大程度复用节点)

### React/Vue中key的作用

- 一是帮助`diff`算法执行时更快找到对应节点，高效更新虚拟DOM
  - Vue的`diff`算法中，会根据新节点`key`对比旧节点数组中的`key`，如果没找到则认为是新增节点
  - 如果没有`key`则会采用==遍历查找==找对应旧节点
- 二是数据变化时，避免==就地复用==带来的渲染错误

### Vue组件的通信方式

1. `props`父到子组件通信和`$emit`触发父组件监听方法
2. 全局事件总线
3. 父组件到后代组件的跨组件通信`provide`、`inject`

### 讲一下`nextTick`

- 执行时机
  - `updated`或`mounted`之后执行
- Vue更新是异步的，当数据发生变化，就会在事件循环中缓存数据变更操作，为避免不必要的操作和计算，`nextTick`会在队列中加入一个回调函数，并确保该函数在所有DOM操作完成后才调用

### 讲一下插槽

- 一种有三种插槽，默认插槽、具名插槽、作用域插槽

### 讲一下`keep-alive`

- 作用
  - 实现组件缓存，保持组件状态，避免因重复渲染导致性能问题
- 原理
  - Vue将真实DOM节点抽象成虚拟节点树，`keep-alive`就是基于虚拟节点，它将虚拟节点在`cache`对象中缓存起来，再在需要重新渲染时，将虚拟节点从`cache`对象中取出渲染

### 讲一下`mixins`

- 混入是当多个组件有重复逻辑时使用

### 讲一下你对Vuex的理解

- Vuex是专门为Vue开发的状态管理机，核心就是仓库`store`
- Vuex的状态存储是响应式的，仓库中状态发生变化，相应的组件也会更新
  1. 首先是通过`commit`触发`mutation`中定义的方法
  2. 然后对仓库中的状态进行更改

- 同时还存在`Module`，可以将单一仓库拆分为多个，并保持在单一状态树中

### 讲一下React中类组件和函数组件的区别

- 函数组件适用于简单组件，接收单个参数`props`，返回一个标签元素，并且没有`this`
- 而类组件继承`Component`类，可以设置`state`并直接使用`props`，可以实现复杂的组件

- 函数组件的重新渲染是返回新的标签元素，而类组件是创建一个新的实例

### hooks用过吗？

- 用过，`hooks`是为了让函数组件也可以使用`state`等React特性
- 分别有这么几个常用的：`useState`状态钩子、`useContext`共享状态钩子、`useReducer`action钩子、`useEffect`副作用钩子
  - ps：副作用指不直接与视图渲染相关的操作，如网络请求

### React组件通信方式

1. 父组件向子组件传值，用`props`
2. 子组件向父组件传值，父组件用`props`传入函数给子组件，子组件调用传入参数
3. 父组件向后代组件传值，用`context`，创建一个组件树的共享数据容器
4. 任意层级组件传值，通过消息订阅和发布

### setState是同步还是异步执行

- 在React事件中是==异步==，因为会将更新操作放到更新队列里，批量执行，而不是立即更新
- 但在DOM事件或定时器中是==同步==执行

### React生命周期

- 组件被创建时，执行`constructor`→`getDerivedStateFromProps`→`render`→`componentDidMount`
- 组件更新时：执行`getDerivedStateFromProps`→`shouldComponentUpdate`→`render()`→`getSnapshotBeforeUpdate`→`componentDidUpdate`
- 组件卸载时：执行`componentWillUnmount`

### 说一下react-filber

- 根据优先级对主线程中的执行任务进行调度

### React事件绑定原理

- 事件不是直接绑在DOM节点，而是对原生事件进行封装，然后绑定到==根组件==统一监听

### webpack做过那些优化？开发效率、打包策略等

#### 优化构建速度

1. 使用==多线程==，如`thread-loader`
   - 但仅限于特别耗时的，否则还不如直接打包速度快
2. 使用==热更新==，只对修改的模块进行打包，在程序运行时，删除、增加模块不会使页面重新刷新
   - 但是重新加载JS会使页面重新加载，因此需要手动设置规则只对某JS文件进行加载
3. 使用`oneof`，这样在匹配到第一个符合的规则时就会停止遍历
4. 缩小打包范围，使用`exclude/include`排除如`node_module`这样的包
5. 利用缓存`cache`，只对修改的文件进行检查，打包速度会有提升
6. 使用`babel`插件，因为`babel`编译时会为每个文件添加辅助代码，而这个插件可以使辅助代码作为独立模块==引入==
7. 使用`code split`，因为打包时会将所有JS文件打包成一个，用`code split`可以将其分割成多个JS文件，并按需引入

#### 优化打包体积

1. 使用静态图片压缩插件
2. 提取公共资源
3. 使用`Tree shaking`，去除无用的JS文件，不过是webpack默认开启的

### 简述一下Babel编译过程

- `babel`是一个工具链，用`ES6`语法编写为==向后兼容==的JS语法，是通过==抽象语法树==完成代码的转译

### http和https

#### 基本概念

- `http`是客户端和服务端应答的TCP协议，用于从服务端传输==超文本==到本地的传输协议
- `https`则是在`http`基础上增加`SSL`层，对==证书==、==密钥==、==数据完整性==进行验证

#### http和https区别和优缺点

- `http`是明文传输，`https`是==加密传输协议==，所以要更安全
- `http`端口默认`80`，`https`端口默认`443`
- `http`和`https`都属于==应用层==协议，且都是无状态的，只是在应用层横向加了个`SSL`协议
- `https`会使页面加载时间延长
- `https`缓存方便效能更低，如加密传输协议==无法直接缓存==，而是==重新建立连接==
  - 以及握手阶段，需要验证过程，而`http`只需向服务端发送请求，服务端就会返回数据

#### https协议工作原理

1. 客户端访问服务器时，会==要求==服务器建立`SSL`连接
2. 服务器收到请求后，会==将证书传给客户端==
3. 客户端和服务端协商`SSL`==安全等级==
4. 客户端和服务端通过协商一致的安全等级，==建立会话密钥==，然后通过==公钥==加密会话密钥，传给客户端
5. 服务器通过==私钥==解密会话密钥
6. 服务端通过==会话密钥==加密与客户端之间的通信

### 阐述TCP三次握手四次挥手

1. 第一次握手：建立连接时，客户端发送`syn包`到服务器，并进入`syn_sent`状态，==等待服务器确认==
   - `syn`：同步序列号
2. 第二次握手：服务器收到并确认客户端`syn包`，并回复`syn + ack包`，进入`syn_recv`状态
3. 第三次握手：客户端收到`syn + ack包`，并向服务器发送`ack包`，发送完进入==连接成功==状态

- 四次挥手：**客户端**发送==释放报文==(第一次)，**服务端**回复==确认报文==(第二次)，等发完最后的数据后，**服务端**发送==释放报文==(第三次)，**客户端**收到后回复==确认报文==(第四次)，并在稍后关闭连接，而服务端收到确认报文后是立即结束连接

### TCP/IP是如何保证数据包传输的可靠性

- 对数据流==分段并编号==，然后通过==ack回复==和==超时重发==两个机制保证
  1. 发送方把已发送的数据包保留在==缓冲区==
  2. 并为每个==已发送==的包设置一个==超时定时器==，定时器超时前收到应答的话，就会释放该数据包占用的缓冲区，否则重传，直到达到最大重试次数
  3. 接收方收到数据包后，先进行校验，如果数据正确则交给上层协议，然后回复一个累计应答包

### TCP和UDP的区别

- `TCP`==需要建立连接==，可靠性更强，而`UDP`是无需建立连接，直发数据
- `TCP`仅支持==单播传输==，`UDP`支持单播、多播、广播
- `UDP`传输效率更高，实时性好

### HTTP跨域问题

- 原理
  - 浏览器同源策略所致，当前网站不能执行其他网站==脚本==
- 解决方式
  - `jsonp`：通过`<script>`标签，发送请求
    - 缺点：只支持`get`请求
  - `postMessage`发送数据
  - `proxy`代理：服务器端设置代理
  - `CORS`：服务器设置`Access-Control-Allow-Origin`响应头，允许其他域名的访问

### Cookie、sessionStorage、localStorage之间的区别

- 相同点
  - 都存在客户端
- 区别
  - `cookie`数据不能超过4k，`session`和`local`要大得多
  - `cookie`在设置的过期时间之前一直有效，`local`==永久==存储，`session`在当前窗口关闭后自动清除
  - `cookie`数据会随请求带往服务器，`session`和`local`数据都存在本地

### TCP粘包问题

- 出现原因
  - 发送的若干数据包在接收时粘成一包，后一包数据头接前一包数据尾
- 解决方法
  1. TCP提供了强制传送的操作指令，不必等缓冲区满即会发送
     - 缺点：会降低网络发送效率
  2. 对于接收方，可以通过提高接收进程优先级，使其即时接收数据
     - 缺点：频率高时，还是可能会出现粘包
  3. 对于接收方，可以人为控制分多次接收，然后合并
     - 缺点：效率较低

### 从输入URL到页面加载的全过程

1. 浏览器根据URL查看缓存，是否存在该地址页面，如果有则显示
2. 如果缓存中没找到，则向DNS服务器发起请求，获得对应IP地址
   - DNS服务器就属于UDP
3. 根据IP地址，建立TCP连接
4. 客户端发起HTTP请求
5. 服务器返回请求结果
6. 当请求结束时，关闭TCP连接
7. 浏览器根据HTML内容，构建DOM树、根据CSS样式布局绘制页面，再进行JS解析

### JS数据类型如何检测

1. 用`typeof`
   - 缺点是不能对数组、对象和`null`进行区分
2. `instanceof`
   - 优点是可以区分数组、对象和函数，但是缺点是基本类型数据无法区分
3. `Object.prototype.toString.call(变量)`
   - 可以精准判断类型

### var、let、const之间的区别

- `var`定义的变量==没有块的概念，可以跨块访问==，但是不能跨函数
  - `var`可以==先使用后声明==，存在变量提升
  - `var`可以在作用域内声明重复变量，而`let`、`const`不行
- `let`定义的变量只能在块作用域内访问
  - `let`必须先声明后使用
- `const`定义的常量，使用时必须赋值，只能在块作用域内访问

### JS垃圾回收机制

- 回收机制会定期处理不再使用的变量，释放内存
- 常见的内存泄露有全局变量、闭包、DOM元素的引用、定时器

### 作用域和作用域链

- 作用域就是函数和变量可访问的范围，分全局作用域和函数作用域
- 作用域链就是变量在当前作用域下取值，如果找不到则向上查找，直到全局作用域，这个查找的过程即作用域链

### 闭包是什么？有什么作用？

- 闭包其实就是嵌套函数，内部函数引用了外部函数的变量
- 闭包的作用
  - 一是保护函数变量不被释放
  - 二是保护私有变量不被污染

### JS中this指向的问题

- 作为普通函数执行时，`this`指向`window`
- 作为对象的方法被调用时，指向该对象
- 在构造器中使用时，指向类实例化的对象
- 在箭头函数中，指向父函数调用者
- 使用`call`、`bind`等情况下，`this`指向传入的参数

### 请解释一下原型和原型链

- 原型是指定义的对象会包含一个预定的属性，`__proto__`或者`prototype`，指向它的原型对象
- 原型链指对象间都有指向其原型链接，这个原型又可以有自己的原型，形成一个链条
  - 访问一个对象的属性时，JS会沿着原型链向上搜索，直到找到属性或到达原型链末尾

### 请讲一下new运算符实现的原理

1. 首先创建一个==空对象==
2. 将对象的原型设置为函数的原型对象
3. 然后让函数的`this`指向这个对象，执行构造函数代码
4. 最后返回创建的对象

### 解释一下什么是事件循环

- 因为JS是单线程，为了防止单一函数执行时间过长，导致阻塞，会将异步执行的方法放到队列里面，等主线程执行完毕再执行队列中的任务
  - 队列又分为微任务队列和宏任务队列，微任务队列就比如`Promise.then`，宏任务队列就比如定时任务
- 简单来说经过以下几个步骤
  1. js执行，遇到同步代码就压入执行栈，遇到异步代码就丢给WebAPI，接着执行同步代码
  2. 此期间，webAPI会将异步代码的回调函数放入队列等待执行
  3. 执行栈为空后，事件循环会取出微任务执行，清空微任务后，再到宏任务队列取第一个任务执行，执行完毕，再查看微任务队列中是否有任务，如果有则执行清空微任务，再去宏任务找，如此循环，直到清空所有任务
- (一般不问)`node`运行环境下，事件循环还会添加一些I/O读写操作

### 介绍下Async/Await是如何实现同步执行异步操作

- 其实就是一个语法糖，本质是将`await`前后部分代码放入==生成器函数==，利用其特性将异步代码写成同步的形式，`await`的位置相当于`yield`，并对`await`后的`promise`对象添加一个`.then`然后执行`next()`方法，使得`prosmise`对象状态成功后才继续往下执行

### 介绍一下节流、防抖以及应用

- 节流
  - 指规定时间内，无论触发多少次，只调用一次
  - 应用
    - 需要高频点击或触发的时候
- 防抖
  - 无论触发多少次，等待时间过了，才会触发一次
  - 应用
    - 如搜索框搜索输入内容

### 浏览器重绘和重排的区别

- 重绘：元素外观发生改变
- 重排/回流：重新排列布局

### 如何触发重排和重绘

- 改变DOM的操作都会触发
  - 增删改DOM节点
  - `display:none`隐藏DOM节点
  - 移动DOM节点
  - 添加样式
  - 用户行为，如改变窗口大小

### 如何避免重绘或重排

- 元素定位改为`absolute`或`fixed`，即可脱离文档流，再修改样式就不会重排
- 集中改变样式，不要一条条修改DOM的样式

### Git常用命令有哪些

- `git branch`(查看/创建分支)、`git checkout`(切换分支)、`git merge`(合并分支)

### HTML5新特性、语义化

- 新增`header`、`footer`等标签，优点是即使没CSS样式，页面也有很好的结构效果，使代码结构更清晰易读

### CSS样式优先级

- `!important`>内联样式>ID选择器>类、属性、伪类选择器>元素、伪元素选择器>关系、通配符选择器

### Position属性值有哪些区别

- `fixed`：相对于浏览器窗口定位，脱离文档流
- `relative`：相对于元素自身定位，不会脱离文档流
- `absolute`：相对于最近的定位父元素定位，脱离文档流
- `sticky`：先按文档流定位，然后相对于==最近的块级父元素==定位，当元素位置在特殊阈值时，为固定定位

### 讲一下盒模型

- 盒模型是指由边距、边框、填充和内容组成的方盒
- 标准盒模型指`margin`、`border`、`padding`、`width`
- IE盒模型值`margin`、`width`，`width`包含了`padding`和`border`

### 讲一下BFC

- 是一个独立渲染区域，规定容器内部如何布局，并且容器内子元素不会影响到外面的元素
- `overflow`开启滚动显示或脱离文档流的定位方式即可开启BFC