- 按照如下类型来学习
  - `数组-> 链表-> 哈希表->字符串->栈与队列->树->回溯->贪心->动态规划->图论->高级数据结构`，从简单做起，做了几个类型题目之后，再慢慢做中等题目、困难题目

## 全排列

- 定义
  - 从**n**个不同元素中任取**m**（**m**≤**n**）个元素，按照一定的顺序排列起来，叫做从**n**个不同元素中取出**m**个元素的一个排列。当**m**=**n**时，所有的排列情况叫做全排列
  - 如：`abc`全排列的结果有`abc acb bac bca cab cba`

- (最简单)排序比较

  ```js
  function sort(str1, str2) {
      // 长度不相等 或 字符串完全相同
      if (str1.length !== str2.length || str1 === str2) {
          return false
      }
      let t1 = str1.split('').sort().toString()
      let t2 = str2.split('').sort().toString()
      return t1 === t2
  }
  console.log('排序比较 abc 和 acb', sort('abc', 'acb')) // true
  console.log('排序比较 acg 和 acg', sort('acg', 'acg')) // false
  ```

- 用`map`比较

  ```js
  function map(str1, str2) {
      if (str1.length !== str2.length || str1 === str2) {
          return false
      }
      let m = new Map()
      for (let val of str1) {
          m.set(val, '')
      }
      for (let val of str2) {
          if (!m.has(val)) {
              return false
          }
      }
      return true
  }
  console.log('map比较 abcd 和 acbd', map('abcd', 'acbd')) // true
  console.log('map比较 abcd 和 aebd', map('abcd', 'aebd')) // false

## 数组

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)

### 二分法

#### 二分查找

- [力扣704](https://leetcode.cn/problems/binary-search/description/)

  ```js
  // 时间复杂度：O(log n)
  // 空间复杂度：O(1)
  
  // 方式1 左闭右闭区间
  function fn1(list, target) {
      let left = 0 // 左闭[0, right)
      let right = list.length - 1 // 右闭[left, length-1]
      // 左右能够相等就是 左闭右闭
      while (left <= right) {
          // 每次循环计算中间位置索引和值
          // >> 是将值转换为10后向右移动 1位
          // 相当于Math.floor((right - left) / 2)
          let mid = left + ((right - left) >> 1)
          if (list[mid] > target) {
              // 区间内中间值比目标值大
              // 则缩小右区间(最大值)
              // 又因为是右闭合 且已知mid≠target 所以mid值可以排除
              // 因此右区间等于mid - 1 向内缩一格
              right = mid - 1
          } else if (list[mid] < target) {
              // 中间值比目标值小
              // 则加大左区间(最小值)
              // 又因为是左闭合 且已知mid≠target 所以mid值可以排除
              // 因此左区间等于mid + 1 向内缩一格
              left = mid + 1
          } else {
              // 中间值等于目标值 找到 直接返回
              return mid
          }
      }
      // 循环结束 都没有找到
      return -1
  }
  
  // 验证
  console.log(fn1([1, 2, 3, 4], 3)) // 2
  
  // 方式2 左闭右开区间
  function fn2(list, target) {
      let left = 0 // 依旧是左闭 同方法1
      let right = list.length // 右开[left, length)
      // 因为右边是开区间 所以左右必不可能相等
      while (left < right) {
          let mid = left + ((right - left) >> 1)
          if (list[mid] > target) {
              // 中间值比目标值大 则缩小最大值
              // 又因为右是开区间 所以不可能等于最大值
              // 因此不需要-1
              right = mid
          } else if (list[mid] < target) {
              // 同方法1
              left = mid + 1
          } else {
              return mid
          }
      }
      // 没有找到返回-1
      return -1
  }
  
  // 验证
  console.log(fn2([1, 6, 22, 44, 78], 22)) // 2

#### 搜索插入位置

- [力扣35](https://leetcode.cn/problems/search-insert-position/description/)

  ```js
  // 时间复杂度：O(log n)
  // 空间复杂度：O(1)
  
  // 搜索插入位置 本质就是找到临近目标值 第一个等于或小于目标值的位置
  
  // 以左闭右开区间方式为例
  function fn(list, target) {
      let left = 0
      let right = list.length - 1
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          // 因为是找第一个大于目标值的值
          // 等同于找循环结束后的右区间(最大值)
          // 且这个值不会和目标值相等
          // 因此判断条件为 大于时 和 小于等于时
          if (list[mid] > target) {
              right = mid - 1
          } else if (list[mid] < target) {
              left = mid + 1
          } else {
              // 此时已经找到第一个等于的值
              return mid
          }
      }
      // 没找到等于的值 但是循环已经结束 返回离目标值最近且大于它的值
      // 因为left<=right是循环条件 所以最后right<left
      // 因此right要加1
      return right + 1
  }
  
  // 验证
  console.log('目标值小于所有值时:' + fn([3, 4, 5, 6], 1)) // 0
  console.log('目标值大于所有值时:' + fn([3, 4, 5, 6], 10)) // 4
  console.log('目标值等于某一元素:' + fn([1, 4, 7, 15], 4)) // 1
  console.log('目标值在区间内且不等于任意值:' + fn([1, 4, 7, 15], 8)) // 3
  console.log('目标值等于某一连续元素:' + fn([1, 4, 4, 4, 7, 15], 4)) // 2
  
  // 简化fn方法
  function fn2(list, target) {
      let left = 0
      let right = list.length - 1
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          if (list[mid] < target) {
              left = mid + 1
          } else {
              // 因为要的是右区间或等于的值 所以把两者条件合并到一起
              right = mid - 1
          }
      }
      return right + 1
  }

#### 在排序数组中查找元素的第一个和最后一个位置

- [力扣34](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

  ```js
  // 思路
  // 用二分法分别找到
  // 目标值出现的第一个位置 即list[mid] >= target来不断移动右区间
  // 和目标值出现的最后一个位置 即list[mid] <= target来不断移动左区间
  // 情况1：不在数组范围内 返回{-1, -1}
  // 情况2：在范围内 但不存在 返回{-1, -1}
  // 情况3：在范围内 且存在 返回[left, right]左闭右闭区间
  
  class Fn {
      constructor(list, target) {
          this.left = this.getLeft(list, target)
          this.right = this.getRight(list, target)
          this.range = this.getRange()
      }
      getRight(list, target) {
          let left = 0
          let right = list.length - 1
          while (left <= right) {
              let mid = left + ((right - left) >> 1)
              // 注意
              // 因为是找目标值右边界 所以要让left不断移动 而不去动right
              // 当最后一次循环left == right后
              // 此时left > right 此时right就等于目标值最末尾的位置
              if (list[mid] <= target) {
                  left = mid + 1
              } else if (list[mid] > target) {
                  right = mid - 1
              }
          }
          // 因为要的是等于目标值的最末尾位置 所以不加1
          return right
      }
      getLeft(list, target) {
          let left = 0
          let right = list.length - 1
          while (left <= right) {
              let mid = left + ((right - left) >> 1)
              // 注意
              // 因为是找左边界 所以要让right不断移动 而不去动left
              // 当最后一次循环left == right后
              // 此时left > right 此时left就等于目标值第一次出现的位置
              if (list[mid] < target) {
                  left = mid + 1
              } else if (list[mid] >= target) {
                  right = mid - 1
              }
          }
          return left
      }
      getRange(left = this.left, right = this.right) {
          if (left > right) {
              // 说明 没有找到目标值 返回 -1
              return [-1, -1]
          } else {
              // left <= right 说明目标值存在且取到了左右边界
              return [left, right]
          }
      }
  }
  
  // 验证
  console.log('不在数组范围内', new Fn([1, 2, 3], 4)) // left:3 right:2 range:[-1, -1]
  console.log('在范围内但不存在', new Fn([1, 2, 3, 5], 4)) // left:3 right:2 range:[-1, -1]
  console.log('在范围内且存在', new Fn([1, 2, 2, 2, 3, 4], 2)) // left:1 right:3 range:[1, 3]
  console.log('在范围内且存在', new Fn([1, 2, 3, 4], 2)) // left:1 right:1 range:[1, 1]

#### x的平方根

- [力扣69](https://leetcode.cn/problems/sqrtx/description/)

  ```js
  // 二分法思路
  // 视数字为1到n的整数数组 不断求 中间值平方是否等于n
  // 如果等于则直接返回中间值
  // 如果没找到 以左闭右闭区间为例 最后一次循环 left == right
  // 执行完left > right 所以取right值为开根号后的整数值
  
  function fn(num) {
      // 0 和 1 的平方根等于自身
      if (num === 0 || num === 1) {
          return num
      }
      let left = 1
      let right = num
      // 左闭右闭区间
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          if (mid * mid > num) {
              // 中间值的平方大于目标值 自然要缩小中间值
              // 因此缩小最大值(右区间)
              right = mid - 1
          } else if (mid * mid < num) {
              // 中间值的平方小于目标值 自然要增大中间值
              // 因此增大最小值(左区间)
              left = mid + 1
          } else {
              // 找到平方根值
              return mid
          }
      }
      // 循环结束 没找到mid * mid == num
      // 此时left > right 取right值返回
      return right
  }
  
  // 验证 平方根只保留整数 舍弃小数位
  console.log('二分法4的平方根:' + fn(4)) // 2
  console.log('二分法8的平方根:' + fn(8)) // 2
  console.log('二分法15的平方根:' + fn(15)) // 3
  ```

#### 有效的完全平方数

- [力扣367](https://leetcode.cn/problems/valid-perfect-square/description/)

  ```js
  // 思路
  // 同力扣69的求平方根 只不过本题只求整数平方正好等于原值 其他算作false
  // 因此只需在力扣69的基础上将return right改为return false
  
  function fn(num) {
      if (num === 0 || num === 1) {
          return true
      }
      let left = 1
      let right = num
      // 以左闭右闭为例
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          if (mid * mid > num) {
              right = mid - 1
          } else if (mid * mid < num) {
              left = mid + 1
          } else {
              return true
          }
      }
      return false
  }
  
  // 验证
  console.log('4的有效平方数:' + fn(4)) // true
  console.log('8的有效平方数:' + fn(8)) // false
  console.log('15的有效平方数:' + fn(15)) // false

### 双指针

#### 移除元素

- [力扣27](https://leetcode.cn/problems/remove-element/description/)

  ```js
  // 思路
  // 数组删除元素在内存中本质上是将删除位置后面所有元素向前移动一格
  // 删除后数组长度在内存中其实没变 末尾元素其实还在内存里 只是不进行处理
  // 所谓的数组长度改变 只是通过编程语言封装的方法返回给你的结果
  // 以此为理论基础 就可以设置一个快指针 它必然可以遍历完原数组
  // 再设置一个慢指针 它表示删除元素后的新数组
  // 每遇到一个要删除的元素就停滞一下 从而跟快指针拉开距离
  // 并将快指针所在位置不同于删除元素的值赋值给慢指针当前位置
  // 因为慢指针赋值后会往前移动 慢指针位置索引 === 新数组.length
  
  // 时间复杂度：O(n)
  // 空间复杂度：O(1)
  
  function fn(target, source) {
      let slowIndex = 0
      for (let fastIndex = 0; fastIndex < source.length; fastIndex++) {
          // 快指针当前值不等于目标值 则将该值赋值给慢指针当前停留位置
          // 并移动慢指针
          if (source[fastIndex] !== target) {
              source[slowIndex] = source[fastIndex]
              slowIndex++
          }
      }
      return slowIndex
  }
  
  // 验证
  let list = [11, 4, 22, 3, 4, 3, 11, 3]
  console.log('删除3后数组长度:' + fn(3, list)) // 5

#### 删除排序数组中的重复项

- [力扣26](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

  ```js
  // 思路
  // 同力扣27 只不过目标值是动态的
  
  function fn(source) {
      let slow = 0
      // 因为是有序数组 因此重复元素是排在一起的
      // 设置target作为动态目标值
      let target
      let newList = [] // 慢指针作为新数组索引
      for (let fast = 0; fast < source.length; fast++) {
          // 第一次循环时 target 是undefined
          // 后续遍历时target每次只会等于不同的值
          // 就意味着会去重只将不同的值放入新数组
          if (source[fast] !== target) {
              // 第一次循环时赋初值
              target = source[fast]
              newList[slow++] = source[fast]
          }
      }
      return newList
  }
  
  // 验证
  let list = [0, 1, 1, 1, 2, 2, 3, 4, 4]
  console.log('去重结果', fn(list)) // [0, 1, 2, 3, 4]

#### 移动零

- [力扣283](https://leetcode.cn/problems/move-zeroes/description/)

  ```js
  // 思路
  // 同力扣27删除元素 只不过在删除目标值形成新数组后
  // 此时慢指针位置在超出新数组末尾后一格
  // 删除多少个元素 就在末尾补多少个同样的元素
  // 因此就可以从慢指针位置开始到原数组末尾覆盖为同样的值
  
  // 时间复杂度：O(n)
  // 空间复杂度：O(1)
  
  function fn(source, target) {
      let slow = 0
      // 第一遍遍历将非目标值往前移动
      for (let fast = 0; fast < source.length; fast++) {
          if (source[fast] !== target) {
              source[slow++] = source[fast]
          }
      }
      // 第二遍遍历 从慢指针索引位置开始用目标值覆盖数组后面的值
      for (let i = slow; i < source.length; i++) {
          source[i] = target
      }
      return source
  }
  
  // 验证
  let list = [0, 1, 0, 3, 0, 0, 1]
  console.log('移动0', fn(list, 0)) // [1, 3, 1, 0, 0, 0, 0]

#### 比较含退格的字符串

- [力扣844](https://leetcode.cn/problems/backspace-string-compare/description/)

  ```js
  // 重构字符串思路
  // 设一个新数组 将遇到的非#(退格)字符填入新数组
  // 当遇到#就对新数组执行出栈 最后对比新数组组成的字符串
  
  // 时间复杂度：O(N+M) N和M表示两个字符串个遍历一次
  // 空间复杂度：O(N+M)
  
  function fn(str1, str2) {
      let a1 = []
      let a2 = []
      for (let val of str1) {
          if (val != '#') {
              a1.push(val)
          } else if (val == '#') {
              a1.pop()
          }
      }
      for (let val of str2) {
          if (val != '#') {
              a2.push(val)
          } else if (val == '#') {
              a2.pop()
          }
      }
      return a1.join('') === a2.join('')
  }
  
  // 验证
  let t1 = 'ab#c'
  let t2 = 'ab##ac'
  console.log('重构字符串结果:' + fn(t1, t2)) // true
  
  // 双指针法思路
  // 因为#号会删除自身前一个非#号字符 且多个#号会累计删除字符数量
  // 因此指针因该从后往前遍历 这样在遇到#号时就累计 遇到非#号就减少累计
  // 两个指针分别指向两个数组末尾 然后放在同一个大循环中
  // 这样做的目的是为了让两个指针共同递减
  // 然后每一轮大循环中 执行各自的小循环
  // 小循环中一直累计和减少累计 直到累计为0 即当前指针所指向的值被保留就break
  // 然后在当前大循环中对比
  // 情况一 两个指针都没遍历完 且 两指针位置的保留字符不相同 这表示最终字符串一定不相同 return false
  // 情况二 情况一不符的条件下 任一指针没遍历完 这表示有一个指针已经遍历完 另一个没遍历完停在了保留字符
  // 即 最终字符串长度不同 也 return false
  // 情况一二都不符 说明两字符串还有相同的可能性 则对两指针同时递减 开启新一轮(大循环中的)小循环
  // 直到两指针都小于0 说明两字符串都遍历结束 结束大循环 进行到此时都没有触发情况一二
  // 说明字符串相等 return true
  
  function fn2(str1, str2) {
      let index1 = str1.length - 1 // 索引
      let count1 = 0 // #号累计(即要删除的字符数)
      let index2 = str2.length - 1
      let count2 = 0
      // >=0 是为了让两字符串都遍历完 再得出结果
      while (index1 >= 0 || index2 >= 0) {
          while (index1 >= 0) {
              if (str1[index1] === '#') {
                  // 如果遇到#号就累加
                  count1++
                  index1--
              } else if (count1 > 0) {
                  // 如果遇到非#号字符则减少累计
                  count1--
                  index1--
              } else {
                  // 没有累计 即不需要删除 就跳出循环准备对比
                  break
              }
          }
          while (index2 >= 0) {
              if (str2[index2] === '#') {
                  count2++
                  index2--
              } else if (count2 > 0) {
                  count2--
                  index2--
              } else {
                  break
              }
          }
          if (index1 >= 0 && index2 >= 0) {
              // 两字符串都没遍历完
              if (str1[index1] !== str2[index2]) {
                  // 保留字符不同 说明两字符串不同
                  return false
              }
          } else if (index1 >= 0 || index2 >= 0) {
              // 不满足前一个条件 说明有一个字符串已经遍历完
              // 即 字符串长度不相同
              return false
          }
          // 说明两字符串当前循环对比的字符相同 继续进入大循环
          // 或 两个字符串都遍历完了 跳出循环
          index1--
          index2--
      }
      return true
  }
  
  // 验证
  let str1 = 'a##ab#c'
  let str2 = '##ac#c'
  console.log('双指针验证结果:' + fn2(str1, str2)) // true

#### 有序数组平方

- [力扣977](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)

  ```js
  // 思路
  // 题目条件是升序排列数组 因为数组中有负数所以平方后负数可能会大于正数平方
  // 利用题目条件 先找到负数和正数的分界位置
  // 因为负数越小 平方越大 所以负数是从最小的负数开始递减遍历
  // 而正数索引则是从最小正整数开始递增遍历
  // 将这两者遍历放到一个循环中执行 每轮对比正数和负数的平方值大小
  // 将较小值填入新数组 直到一方遍历完 将另一方值依序填入新数组
  
  function fn(list) {
      let boundary // 记录分界位置
      // 注意是升序数组 如果起始位置不是负数 则跳过循环
      for (let i = 0; i < list.length; i++) {
          if (list[i] < 0) {
              boundary = i
          } else {
              break
          }
      }
      let j = boundary // 遍历负数索引
      let k = boundary + 1 // 遍历正数索引
      let newList = [] // 结果数组
      while (j >= 0 || k < list.length) {
          if (j < 0) {
              // 负数先遍历完
              // 则将正数按序填入
              newList.push(list[k] * list[k])
              k++
          } else if (k === list.length) {
              // 正数先遍历完
              // 将负数按序填入
              newList.push(list[j] * list[j])
              j--
          } else if (list[j] * list[j] < list[k] * list[k]) {
              // 负数的平方比正数小 则将负数平方填入新数组
              newList.push(list[j] * list[j])
              j--
          } else {
              // 负数平方比正数平方大 则将正数平方填入数组
              newList.push(list[k] * list[k])
              k++
          }
      }
      return newList
  }
  
  // 验证
  let list = [-4, -1, 0, 5, 10]
  console.log('平方数数组为', fn(list)) // [0, 1, 16, 25, 100]

### 滑动窗口

- 双指针的变体

#### 长度最小的子数组

- [力扣209](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

  ```js
  // 思路
  // 条件:子数组必须是连续的
  // 用快指针表示子数组末尾 慢指针表示子数组起始位置
  // 快指针用于遍历原数组 每移动一步进行累加
  // 每次累加后 判断当前累加值是否 >=目标值
  // 如果符合条件 则更新最短长度记录 并减去起始位置值
  // 然后移动起始位置 目的是缩短快慢指针之间的间距 求得满足条件的最短数组长度
  // 如果缩短(自减)后 依然满足 累加值>=目标值 则继续缩短
  // 所以要用while来作 条件判断 以及 递减循环
  // 直到快指针循环结束 return 最终结果值
  
  // 时间复杂度：O(n)
  // 空间复杂度：O(1)
  
  function fn(list, target) {
      let slow = 0 // 起始位置
      let result = list.length // 初始值为原数组长度 便于后面判断更新值
      let sum = 0 // 累计值
      for (let fast = 0; fast < list.length; fast++) {
          sum += list[fast]
          // 如果当前累计值>=目标值
          while (sum >= target) {
              // 求当前快慢指针间距
              let len = fast - slow + 1 // 这里都是索引 计算长度要+1
              result = result > len ? len : result // 对比 取最小长度作为结果
              sum -= list[slow] // 减去起始位置值后再进行判断
              slow++ // 移动起始位置
          }
      }
      return result
  }
  
  // 验证
  let list = [1, 2, 5, 1, 0, 5, 3]
  console.log('最小子数组长度:' + fn(list, 5)) // 1

#### 水果成篮

- [力扣904](https://leetcode.cn/problems/fruit-into-baskets/description/)

  ```js
  // 思路
  // 条件：子数组至多包含两种元素
  // 不同于力扣209找最短子数组 使用累计值作为判断条件来移动慢指针
  // 本题用哈希表来记录元素种类 并计数 用哈希表长度作为判断条件来移动慢指针
  
  // 时间复杂度：O(n)
  // 空间复杂度：O(1)
  
  function fn(source) {
      let slow = 0 // 起始位置的索引
      // 创建哈希表 利用其特性 确保同一元素只存在一个 并计数
      // 特性 同一key只会存在一个 后续添加同一key只会重新赋值
      let map = new Map()
      let result = 0 // 不同于力扣209找最短 此处是找最长 所以初始值为0
      for (let fast = 0; fast < source.length; fast++) {
          // 循环一开始先将末尾索引值添加到哈希表 并计数
          // 为了计数 所以要先用get读取对应key的值再+1 如果不存在对应key则初始化为0再+1
          map.set(source[fast], (map.get(source[fast]) || 0) + 1)
          // 然后判断哈希表长度 如果超过2说明slow到fast之间存在超过2个不同元素
          while (map.size > 2) {
              // 那么就要从起始位置开始删 并减少哈希表中存的对应元素的计数
              // 直到哈希表长度<=2 即slow到fast之间的元素种类<=2
              map.set(source[slow], map.get(source[slow]) - 1) // 能存到哈希表的最小值都是1
              if (map.get(source[slow]) === 0) {
                  // 判断当前元素在哈希表中计数是否已经归零
                  // 即该元素在slow到fast之间将不复存在 需要从哈希表中删除其记录
                  map.delete(source[slow])
              }
              // 只要当前slow到fast区间内元素种类数不符 就缩短slow到fast区间
              // 即从滑动窗口起始位置(slow)开始删除元素 直到map.size <= 2
              slow++
          }
          // 进行到此处说明滑动窗口内的元素种类已经符合条件
          // 则进行历史长度和当前长度对比 取最大值记录为历史值
          result = result < (fast - slow + 1) ? (fast - slow + 1) : result
      }
      return result
  }
  
  // 验证
  let list = [0, 1, 2, 2, 1, 1, 3, 4, 2]
  console.log('至多包含两种元素的最长子数组长度：' + fn(list)) // 5

#### 最小覆盖子串

- [力扣76](https://leetcode.cn/problems/minimum-window-substring/description/)

  ```js
  // 思路
  // 类似力扣904用哈希表记录元素种类
  // 本题则是在此基础上增加了一个纬度 对种类进行计数比较
  // 因此循环判断条件第一层为对比元素种类数量是否相同
  // 然后判断种类数量是否符合 不符合则继续扩充滑动窗口
  // 直到符合条件 则从滑动窗口起始位置开始缩短
  // 直到种类或计数不符 继续从滑动窗口结尾处伸长
  // 直到原字符串寻找完毕 返回记录的最短子串
  
  function fn(source, target) {
      // 先处理目标字符串 生成哈希表 对字符进行统计
      let t_map = new Map()
      for (let val of target) {
          t_map.set(val, (t_map.get(val) || 0) + 1)
      }
      let slow = 0 // 滑动窗口起始位置
      let fast = 0 // 滑动窗口结束位置
      // 记录最小子数组
      // 其length为判断是否更新条件
      let result = '' // 初始值为空 因为没找到返回空字符串
      // 创建一个哈希表 用于记录当前滑动窗口对应字符的个数
      // 用作判断是否缩短滑动窗口的依据
      let s_map = new Map()
      while (fast < source.length) {
          // 一进循环先判断快指针所指向的值是否符合目标字符串
          if (t_map.has(source[fast])) {
              // 如果符合 则将其填入s_map
              s_map.set(source[fast], (s_map.get(source[fast]) || 0) + 1)
          }
          // 判断s_map和t_map长度
          while (s_map.size === t_map.size) {
              // 相同 说明t_map中的字符种类s_map都包含了
              // 则继续进行下一步 对比s_map和t_map字符计数大小
              let flag = true
              for (let [key, val] of t_map) {
                  if (s_map.get(key) < val) {
                      // 如果滑动窗口字符计数小 说明还不满足t_map要求
                      // 则继续让快指针往后遍历 伸长滑动窗口
                      // 直到找到符合t_map的滑动窗口 再循环缩减滑动窗口 以找到最短子串
                      flag = false
                      break
                  }
              }
              if (!flag) {
                  // 不符合 跳出循环继续伸长滑动窗口
                  break
              }
              // 执行到此处说明已经找到了包含target的子串(不一定是最短)
              // 判断是否是较短子串
              // 空字符串则赋初值 或 较长时更新记录
              if (result === '' || result.length > (fast - slow + 1)) {
                  // 注意 substring截取字符串是左闭右开 因此快指针索引要+1 才是slow到fast区间字符串
                  result = source.substring(slow, fast + 1)
              }
              // 判断当前慢指针所指向的值是否在s_map中
              if (s_map.has(source[slow])) {
                  // 存在则计数-1 因为接下来要缩短滑动窗口
                  s_map.set(source[slow], s_map.get(source[slow]) - 1)
              }
              // 接着缩短滑动窗口 等再次进入循环看是s_map否依然满足t_map
              slow++
          }
          fast++
      }
      return result
  }
  
  // 验证
  let list = 'ADOBECODEBANC'
  let t = 'ABC'
  console.log('最小子串为', fn(list, t)) // BANC

### 模拟行为

#### 螺旋矩阵II

- [力扣59](https://leetcode.cn/problems/spiral-matrix-ii/description/)

  ```js
  // 思路
  // 模拟转圈的一个过程 需要注意的点
  // 1、要记录起始位置 一是作为for循环变量 二是作为一圈转完回到起始位置时的for循环结束条件
  // 2、奇数矩阵有别于偶数 有中心点 while循环处理的只有边 中心点要特殊处理
  // 3、如果要以上一条边的末尾作为下一条边的起始位置 就要采用左闭右开
  // 4、注意左边是最后一条边 因此只能用右开区间 因为起始位置已经取过值了
  
  // 时间复杂度 O(n^2)
  // 空间复杂度 O(1)
  
  function fn(num) {
      // 创建num x num空矩阵
      // 注意map方法会跳过为空的元素 而不修改其值 所以要先填充值
      let result = new Array(num).fill(0).map(() => new Array(num).fill(0))
      // 记录起始位置
      let startRow = 0
      let startCol = 0
      // 记录最大圈数 作为循环结束条件
      // 如果是奇数 中心处单独处理 循环只处理中心点外的四条边
      let maxLoop = Math.floor(num / 2)
      let curLoop = 1 // 当前圈数
      let current = 1 // 当前要赋的值
      while (curLoop <= maxLoop) {
          // 记录当前圈 起始位置 作为边的起始位置或循环结束条件
          let row = startRow
          let col = startCol
          // 以左闭右开区间为例
          // 即当前边 只修改到末尾元素前
          // 末尾位置作为下一条边起始位置 当前边不作修改
          // 因为是从外圈向内收缩
          // 所以一条边的末尾会随着圈数向前推移
          // 因此当前边结束条件是 < num - curLoop
          for (col; col < num - curLoop; col++) {
              // 修改上边 result[当前行][动态列] = 当前值
              result[row][col] = current
              // 赋值完一个数字递增1
              current++
          }
          // 顺时针 接着修改右边
          for (row; row < num - curLoop; row++) {
              // 当前 col 为上边的末尾位置
              result[row][col] = current++
          }
          // 修改下边
          // 注意 因为是顺时针过来的 所以下边是从末尾向头部遍历
          // 这时就要以记录的起始位置为结束条件
          for (col; col > startCol; col--) {
              // 当前 row 是右边的末尾位置
              result[row][col] = current++
          }
          // 修改左边
          // 同下边 是从末尾向前遍历
          for (row; row > startRow; row--) {
              // 当前 col 是下边的起始位置
              result[row][col] = current++
          }
          // 循环结束圈数+1 直到中心点 外圈遍历完
          curLoop++
          // 移动起始点位置 往右下角移一位
          startRow++
          startCol++
      }
      // 循环结束 所有 边 已修改 但是奇数矩阵会有中心点 进行特殊处理
      if (num % 2) {
          // while循环结束时 startRow 和 startCol自增了1 所以已经是中心点
          result[startRow][startCol] = current
      }
      return result
  }
  
  // 验证
  console.log('5*5矩阵数组', fn(5))
  console.log('4*4矩阵数组', fn(4))

#### 螺旋矩阵

- [力扣54](https://leetcode.cn/problems/spiral-matrix/description/)

  ```js
  // 思路
  // 同力扣59不同的是 本题不是正方形 因此可能会存在没有完整圈而是一条边的情况
  // 本题的关键在于 以起始位置对角处为对照 若在对角位置左上方
  // 说明有下和左两条边
  // 外层大循环是取上和右两条边
  // 因此外层大循环条件为 起始位置行和列都小于等于对角位置行列即可
  
  // 时间复杂度：O(mn) mn表示行和列数
  // 空间复杂度：O(1)
  
  function fn(source) {
      let list = []
      let startRow = 0
      let startCol = 0
      // 因为矩阵是 m x n 不是n x n正方形矩阵
      // 所以中心处不是完整的一圈
      // 不能以圈数为缩进和循环终止条件
      // 因此设置条件为对角位置行和列总数
      let totalRow = source.length - 1
      let totalCol = source[0].length - 1
      // 循环结束条件 起始行和末尾行在同一行或小于末尾行
      // 且起始列和末尾列在同一列或小于末尾列
      while (startCol <= totalCol && startRow <= totalRow) {
          // 先从上边开始 从左到右
          // 左闭右开区间 取到末尾前一个元素
          for (let col = startCol; col < totalCol; col++) {
              list.push(source[startRow][col])
          }
          // 接着右边 从上到下
          // 注意从上边的末尾元素开始 且 取到右边的末尾元素
          // 因为不是正方形 所以不一定还有下一条边 右边要取完
          // 所以是<=
          for (let row = startRow; row <= totalRow; row++) {
              list.push(source[row][totalCol])
          }
          // 重点来了
          // startRow表示当前行 startCol表示当前列
          // totalRow表示最下面的边 totalCol表示最右边的列
          // 因此只有当前起始位置均小于对角行和列 才表示还有对角边
          if (startRow < totalRow && startCol < totalCol) {
              // 有对角边 先从下边开始 从右到左
              // 注意右边已经取到末尾元素 因此从右边的前一个元素开始
              for (let col = totalCol - 1; col >= startCol; col--) {
                  list.push(source[totalRow][col])
              }
              // 接着左边 从下到上
              // 注意下边已经取到末尾 因此从左边的上一行开始
              // 左边只能是右开区间
              for (let row = totalRow - 1; row > startRow; row--) {
                  list.push(source[row][startCol])
              }
          }
  
          // 循环结束 起始位置 对角位置向内缩进向内缩进
          startCol++
          startRow++
          totalCol--
          totalRow--
      }
      return list
  }
  
  // 验证
  let list = [
      [1, 2, 3, 4, 5],
      [12, 13, 14, 15, 6],
      [11, 10, 9, 8, 7]
  ]
  console.log('矩阵值', fn(list))

## 链表

- 在JS中链表节点就是一个类的实例，由两个属性组成，一个表示节点值，一个表示下一个节点内存地址值

  ```js
  class Node{
      constructor(value, nextObj){
          this.value = value
          // 每一个next指向下一个关联的对象地址
          this.next = nextObj
      }
  }
  ```

- 链表末尾节点的`next`为`null`

- 链表在内存中并不是连续地址

- 链表操作

  - 删除

    - 原理

      - 非头部节点：将要删除的节点的前一个节点的`next`指向当前节点的`next`，可以理解为绕过要删除的节点，在JS中没有被引用的对象内存就会被回收，也就删除了
      - 头部节点：将头部节点置为其`next`节点，再将其`next`置为`null`
        - 为了将删除头部节点和普通节点操作同化，可以设置==虚拟头部节点==，其`next`指向头部节点，这样删除头部节点操作就同普通节点相同了，只要将虚拟头部节点的`next`指向头部节点的`next`

    - 示例

      ```js
      function removeNode(head, target){
      	// 创建虚拟头部节点 其实就是局部变量 每次调用删除都创建一个临时的
          // 因为是临时的 随便传个值进去就行 所以传了0
          // 其次将真实头部节点head传入 作为虚拟头部节点的next值
          let virtualHead = new Node(0, head)
          // 删除操作要先找到目标 所以要用while循环判断 找到后才执行删除操作
          // 设一个动态值 表示当前进行到的节点
          let current = virtualHead // 初始从虚拟头开始
          // 链表末尾是null 就结束循环
          while(current.next){
              // 此示例是单链表 即只有指向下一个节点 没有前一个节点的引用
              // 因此要在前一个节点就判断其next是否是目标节点
              if(current.next.value === target){
                  // 找到目标 将当前节点的next指向目标节点的next
                  current.next = current.next.next
                  // 找到后 必须用continue跳过后面的移动current操作
                  // 因为判断条件是取当前节点的next
                  // 如果删除后 接着移动到下一个节点就会跳过下一个节点的判断
                  continue
              }
              current = current.next // 移动当前节点到下一个节点
          }
          // 删除操作结束 返回虚拟节点后的真实节点列表
          return virtualHead.next
      }
  
  - 添加
  
    - 原理
  
      - 非头部节点：将添加的节点链接到目标位置节点，然后将目标位置前的一个节点断开原链接，将其重新连到新节点
      - 头部节点：新节点链接到头节点，然后将新节点作为头节点
        - 创建虚拟头节点可以同化添加头节点和非头节点操作
  
    - 示例
  
      ```js
      function addNode(head, index, newNode){
          let virtualHead = new Node(-1, head)
          // 位置索引index就相当于离目标节点的步数
          // 因为添加节点要找到目标位置的前一个节点 所以从虚拟头节点开始
          // 这样到index计数结束 正好是目标位置前一个节点
          let target = virtualHead
          while(index--){
              target = target.next
          }
          // 添加操作
          // 注意顺序 如果先修改目标位置前一个节点next 会导致丢失目标位置节点
          newNode.next = target.next
          target.next = newNode
      }

#### 移除链表元素

- [力扣203](https://leetcode.cn/problems/remove-linked-list-elements/description/)

  ```js
  // 思路
  // 链表的删除 就是将要删除节点的前一个节点的next指向删除节点的后一个节点
  // 通过current = current.next来移动节点
  
  class Node {
      constructor(value, nextObj) {
          // JS中链表节点就是一个类的实例 由两个属性组成
          // 一个表示节点值 一个表示下一个节点内存地址值
          this.value = value
          this.next = nextObj
      }
  }
  
  function removeNode(head, target) {
      // 创建虚拟头部节点 其实就是局部变量 每次调用删除都创建一个临时的
      // 因为是临时的 随便传个值进去就行 所以传了0
      // 其次将真实头部节点head传入 作为虚拟头部节点的next值
      let virtualHead = new Node(0, head)
      // 删除操作要先找到目标 所以要用while循环判断 找到后才执行删除操作
      // 设一个动态值 表示当前进行到的节点
      let current = virtualHead // 初始从虚拟头开始
      // 链表末尾是null 就结束循环
      while (current.next) {
          // 此示例是单链表 即只有指向下一个节点 没有前一个节点的引用
          // 因此要在前一个节点就判断其next是否是目标节点
          if (current.next.value === target) {
              // 找到目标 将当前节点的next指向目标节点的next
              current.next = current.next.next
              // 找到后 必须用continue跳过后面的移动current操作
              // 因为判断条件是取当前节点的next
              // 如果删除后 接着移动到下一个节点就会跳过下一个节点的判断
              continue
          }
          current = current.next // 移动当前节点到下一个节点
      }
      // 删除操作结束 返回虚拟节点后的真实节点列表
      return virtualHead.next
  }

#### 设计链表

- [力扣707](https://leetcode.cn/problems/design-linked-list/description/)

  ```js
  // 思路
  // 本题要求实现链表的基本操作即增删查
  // 增加节点：分为头部前增加、尾部增加、链表中间增加
  // 删除节点：任意位置处删除节点
  // 要点：
  // 1、需要设计头节点属性和尾节点属性
  // 为的是方便首尾增加节点时不用再把链表遍历一遍增加时间复杂度
  // 2、对节点的增删 一定 要注意边界情况 及时更新头尾节点属性
  
  class Node {
      constructor(val, next) {
          this.val = val
          this.next = next
      }
  }
  class NodeList {
      constructor() {
          // 链表属性 不是通过实例化时传入赋值
          // 而是在调用方法时修改属性 所以无需赋值
          this.size = 0 // 链表长度
          this.head = null // 链表头节点
          this.last = null // 链表尾节点
      }
  
      // 获取index位置节点 index从0开始
      getNode(index) {
          // 首先进行非法值判断
          if (index < 0 || index > this.size - 1) {
              // index只能是[0, size-1]的值
              return -1
          }
          // 设置虚拟头节点
          const virtualHead = new Node(0, this.head)
          // 因为是获取第index节点
          // 考虑极限条件比如index为0 那么就要返回头节点
          // 因此current要从virtualHead.next开始
          let current = virtualHead.next
          // 可以将index理解为找到目标节点的步数
          // 因此是index-- 每离目标进一步索引-1
          while (index) {
              current = current.next
              index--
          }
          return current
      }
  
      // 在链表最前面插入 一个 节点
      addAtHead(val) {
          // 根据传入值生成节点
          // 因为是添加到头节点前 因此新节点的next就是之前的头节点
          const node = new Node(val, this.head)
          // 更新头节点
          this.head = node
          // 首次添加节点时 还没有尾节点
          if (!this.last) {
              // 只有一个节点 当前节点既是头节点又是尾节点
              this.last = node
          }
          // 记得添加完节点size属性要增加
          this.size++
      }
  
      // 在链表末尾添加 一个 节点
      addAtLast(val) {
          const node = new Node(val, null)
          // 这里要分两种情况
          if (this.last) {
              // 有尾节点 说明链表里有节点
              // 那么将新节点添加到尾节点的next
              this.last.next = node
          } else {
              // 还没有尾节点 说明没添加过节点
              // 因为空链表里添加节点 必然会调用addAtHead 或 addAtLast
              // 即不存在有节点 尾节点还为空的情况
              // 那么将新节点作为头、尾节点
              this.head = node
          }
          // 更新尾节点
          this.last = node
          this.size++
      }
  
      // 在链表第index位置前插入节点
      addAtIndex(index, val) {
          // 首先进行边界判断
          // 1、当前链表没有节点 或 插入位置<=0 视作头部插入节点
          if (!this.size || index <= 0) {
              this.addAtHead(val)
              return
          }
          // 2、index大于size 说明在末尾插入节点 直接调用addAtLast
          if (index > this.size - 1) {
              this.addAtLast(val)
              return
          }
          // 这样就避免了空链表中间位置插入节点 导致的空指针问题
  
          // const node = new Node(val, null)
          // const virtualHead = new Node(0, this.head)
          // 首先要找到index位置前一个节点
          // 因为是修改其前一个节点的next来插入节点
          // 注意 这里是从虚拟头节点开始遍历查找
          // let current = virtualHead
          // while (index--) {
          //     current = current.next
          // }
          // 找到了目标位置的前一个节点
          // 注意 加入节点时断开链接和建立新连接的顺序
          // 如果先将virtualHead.next链接到node
          // 那么就会失去原本的virtualHead.next链接
          // 导致node.next不知道链到谁身上
          // node.next = current.next
          // current.next = node
  
          // 精简版
          let current = this.getNode(index - 1)
          const node = new Node(val, current.next)
          current.next = node
          this.size++
      }
  
      // 删除index位置节点
      deleteAtIndex(index) {
          // 首先进行边界判断
          // 1、无效index
          if (index < 0 || index > this.size - 1) {
              return
          }
          // 2、删除的是头节点
          if (index === 0) {
              // 则将当前头节点改为其下一个节点
              // 如果只有一个节点则是null
              this.head = this.head.next
              // 如果只有一个节点 删除后处理尾节点
              if (index === this.size - 1) {
                  this.last = null
              }
              this.size--
              return
          }
          // 首先找到目标位置前一个节点
          let current = this.getNode(index - 1)
          // 删除节点
          current.next = current.next.next
          // 3、如果删除的是尾节点
          if (index === this.size - 1) {
              // 则将目标位置前一个节点更新为尾节点
              this.last = current
          }
          this.size--
      }
  }

### 双指针

#### 反转链表

- [力扣206](https://leetcode.cn/problems/reverse-linked-list/description/)

  ```js
  // 思路
  // 利用单链表特性
  // 1、单链表每个节点保存了下一个节点地址 所以只能从头开始查
  // 2、用双指针将前后相邻的两个节点重新绑定next关系
  // 3、为了移动指针 解绑next前 要存临时变量
  
  function fn(head) {
      // 设置双指针 用于修改两指针所指向的两个节点关联关系
      let fast = head // 快指针从头节点开始
      let slow = null // 慢指针从头节点前的null开始
      // 首先要设置一个临时变量 保存fast节点的下一个节点
      // 否则反转完fast和slow节点 fast会丢失移动位置
      let temp = fast.next
      while (fast) {
          // 反转
          fast.next = slow
          // 然后先移动slow到fast位置
          slow = fast
          // 再移动fast到temp
          fast = temp
          // 最后更新temp
          temp = fast.next
      }
      // 循环结束 此时fast为null(原链表尾节点next) slow为新头节点
      // 因此要返回slow
      return slow
  }
  ```

#### 两两交换链表中的节点

- [力扣24](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

  ```js
  // 思路
  // 首先要在纸上模拟两两交换过程
  // 要点
  // 1、每次循环存储 被断开 的节点
  // 2、两两交换 所以每次循环要前进两步
  
  class Node {
      constructor(val, next) {
          this.val = val
          this.next = next
      }
  }
  
  function fn(head) {
      // 创建虚拟头节点 先让其指向头节点
      const virtualHead = new Node(-1, head)
      // 创建控制交换的指针 先将虚拟头节点作为起始位置
      let current = virtualHead
      // 因为是两两间进行交换 所以指针一次前进两步
      // 因此循环条件为 下一步 和 下下一步 不为空
      while (current.next && current.next.next) {
          // 有个先决条件
          // 被 断开的节点要先保存到临时变量
          // 否则被断节点的前一个节点改了next指向后会丢失被断节点
          // 因此存储本次循环中会 被 断开的节点
          // 首先是 指针 的下一个节点会 被 断开 因为要指向下下一个节点
          let temp1 = current.next
          // 其次是 指针 的下下一个节点会断开其身后的节点
          let temp2 = current.next.next.next
  
          // 开始交换节点位置
          // 首先是 指针 指向下下一个节点
          current.next = temp1.next
          // 然后交换前后相邻两节点指向
          temp1.next.next = temp1
          // 其次将交换后的末节点temp1的next指向下一次循环要交换的起始节点
          temp1.next = temp2
          // 最后指针移动 两步
          current = current.next.next
      }
      // 返回结果 新链表的头节点
      return virtualHead.next
  }

#### 删除链表的倒数第N个节点

- [力扣19](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

  ```js
  // 思路
  // 倒数第n个 等于 总长 - 目标节点索引(从0开始)
  // 因此让快指针先移动n步 再让快慢指针同时移动
  // 最后慢指针的位置就是 总长 - n 等于 目标节点位置
  // 要注意的是节点的删除 需取到目标节点前一个节点
  // 因此快指针要移动 n+1 步
  
  class Node {
      constructor(val, next) {
          this.val = val
          this.next = next
      }
  }
  function fn(head, n) {
      // 为了处理删除头节点情况 创建虚拟头节点
      const virtualHead = new Node(0, head)
      // 设置快慢指针 从虚拟头节点开始
      let fast = virtualHead
      let slow = virtualHead
      // 先将快指针移动 n+1步
      n = n + 1
      // 为防止n超过总长 出现空指针错误 限制fast不能为空
      while (n-- && fast) {
          fast = fast.next
      }
      // 开始移动快慢指针
      while (fast) {
          fast = fast.next
          slow = slow.next
      }
      // slow在删除节点的前一个节点
      // 执行删除操作
      slow.next = slow.next.next
      return head
  }

#### 链表相交

- [力扣160](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

  ```js
  // 思路
  // 还是经典双指针 各自遍历一个链表
  // 需要注意的是 链表长度不同 为了找到交汇处
  // 需要先将尾部对齐 即长的链表它的指针先走 长度差值的步数
  // 然后再同步移动两链表上的指针 找到完全相等的节点
  
  class Node {
      constructor(val, next) {
          this.val = val
          this.next = next
      }
  }
  function fn(head1, head2) {
      // 先求两个链表长度
      let len1 = 0
      let current = head1
      while (current) {
          current = current.next
          len1++
      }
      let len2 = 0
      current = head2
      while (current) {
          current = current.next
          len2++
      }
      // 然后比较两个链表长度
      let offset // 长度差
      let long // 长链表指针
      let short // 短链表指针
      if (len1 > len2) {
          offset = len1 - len2
          long = head1
          short = head2
      } else {
          offset = len2 - len1
          long = head2
          short = head1
      }
      // 长链表指针先移动offset量
      while (offset--) {
          long = long.next
      }
      // 找到相同节点就停止遍历
      while(long !== short){
          long = long.next
          short = short.next
      }
      // 遍历结束 如果没找到long和short就是null 找到了就返回long和short其一
      return long
  }
  ```

#### 环形链表II

- [力扣142](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

  ```js
  // 哈希表思路
  // 遍历链表 在其过程中遇到不存在于哈希表中的元素 就将其添加进去
  // 因为是每走一步就判断哈希表中是否存在对应的元素
  // 所以回到环入口第一时间就会发现入口位置
  
  function fn(head) {
      let map = new Map()
      let current = head
      // 正常遍历链表循环
      while (current) {
          // 判断哈希表中是否有对应元素
          if (map.has(current)) {
              // 找到入口了则直接返回结果
              return current
          }
          // 说明没找到相同元素 将其添加到哈希表中
          map.set(current, 1)
          // 继续向后遍历
          current = current.next
      }
      // while循环结束都没返回结果 说明没有形成环 返回null
      return null
  }
  
  // 双指针思路
  // 设置快慢指针 同时从头节点出发 快指针每次移动2步 慢指针只走1步
  // 那么快指针必然先进入环 等慢指针进入环 快指针可能已经跑了N圈
  // 且快指针是以1的速度 逼近 慢指针 所以必然慢指针在环中跑不完一圈
  // 就被追上
  // 这是需要一点数学推导 才能看出相遇点到环入口的距离与头节点到环入口距离的关系
  // 设快指针为A 慢指针为B
  // 已知：A前进速度为B的两倍 且 B每次只走一步
  // 设：
  // 起始点到环的入口位置距离为r
  // 从环入口到AB相遇位置距离为k
  // AB相遇位置到环入口剩余距离h
  // AB相遇时 A跑过的圈数n
  // 那么
  // A走过的距离为：r + k + n * (k + h)
  // B走过的距离为：r + k
  // 建立等式
  // 因为A的速度是B的两倍 所以路程也是两倍
  // 2 * (r + k) = r + k + n * (k + h)
  // 简化等式为
  // r = n * (k + h) - k
  // 再简化
  // r = (n - 1) * (k + h) + h
  // n大于等于1 即A最少也得跑了1圈后才会与B相遇
  // 当A跑过的圈数为1时
  // r = h 即相遇点到环入口的剩余距离 与 起始点到环入口的距离相等
  // 那么设另一个指针C从起始点开始走
  // B从相遇点向环入口方向走 两者同步移动 每次移动一步
  // 从等式 r = h 可以看出 C和B必定会在环入口相遇
  // 即使A跑过的圈数不为1 k + h也是整圈环的长度 不影响C和B最终在环入口处相遇
  
  function fn2(head) {
      // 设置快慢指针 都从头节点起始
      let fast = head
      let slow = head
      // 开始循环遍历
      // 快指针走得快 所以要判断快指针是否走到头
      // 如果走到头说明没有环
      while (fast && fast.next) {
          // 先移动 再判断是否相遇
          fast = fast.next.next
          slow = slow.next
          // 因为是从相遇点开始遍历 因此这里用if
          if(fast === slow){
              // 相遇了 设置从起始点开始的指针C
              let result = head
              // 开始循环遍历 直到C和慢指针相遇
              while(result !== slow){
                  result = result.next
                  slow = slow.next
              }
              return result
          }
      }
      return null
  }

## 哈希表

- 数组、`Set`、`Map`都是哈希结构

### 数组

- 用数组的前提是限制了范围，如`a~z`范围，且全是小写，那数组长度就是固定的26
  - 对于没有限制范围大小de ，就无法使用数组来做哈希表
  - 且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费

#### 有效的字母异位词(全排列)

- [力扣242](https://leetcode.cn/problems/valid-anagram/description/)

  ```js
  // 思路
  // 可以用哈希表set map但是set()方法时间复杂度较高
  // 本题数据构成的哈希值较小 用数组实现运行效率最高
  // map和数组思路相同 都是先遍历一个字符串进行计数
  // 然后在另一个字符串中自减 当有计数不为0
  // 说明字符串不符
  
  // map实现方式
  function fn(str1, str2) {
      // 首先过滤掉长度不相同的
      if (str1.length !== str2.length) {
          return false
      }
      let map = new Map()
      // 填入map并计数
      for (let val of str1) {
          map.set(val, (map.get(val) || 0) + 1)
      }
      // 遍历另一个字符串
      for (let val of str2) {
          // 如果str2中有字符不存在于map
          // 或对应字符已经为0 计数不能-1
          if (!map.get(val)) {
              // 说明不匹配
              return false
          }
          // 因为已经限制了字符长度相同
          // 所以有的字符计数减不到0也没事
          // 说明必然有不存在于str1中的字符
          // 就会被if (!map.get(val))条件拦截
          map.set(val, map.get(val) - 1)
      }
      // 进行到这步 说明对应字符计数都已归零 两字符串匹配
      return true
  }
  
  // 验证
  console.log('用map比较 aacd 和 acad', fn('aacd', 'acad')) // true
  console.log('用map比较 aaa 和 aad', fn('aaa', 'aad')) // false
  
  // 数组实现方式
  function fn2(str1, str2) {
      if (str1.length !== str2.length) {
          return false
      }
      // 注意本题全是小写字符 所以Unicode码是连续的 从a到z总共26位
      // 先创建长度为26的数组 并赋初值0
      let array = new Array(26).fill(0)
      // 以a为参照 记录a的Unicode码
      let base = 'a'.charCodeAt()
      // 遍历str1 并计数
      for (let i = 0; i < str1.length; i++) {
          // str1[i].charCodeAt() - base表示0~25的数组索引
          array[str1[i].charCodeAt() - base]++
      }
      // 遍历另一个字符串
      for (let val of str2) {
          // 如果str2中字符对应的数组索引 计数为0
          // 说明要么是本存在于str1
          // 要么对应字符数少于str1
          if (!array[val.charCodeAt() - base]) {
              // 不匹配
              return false
          }
          // 对应字符的计数大于0 计数-1
          array[val.charCodeAt() - base]--
      }
      return true
  }
  
  // 验证
  console.log('用数组比较 aacd 和 acad', fn2('aacd', 'acad')) // true
  console.log('用数组比较 aaa 和 aad', fn2('aaa', 'aad')) // false

#### 赎金信

- [力扣383](https://leetcode.cn/problems/ransom-note/description/)

  ````js
  // 思路
  // 同力扣242 只不过本题不要求两个字符串元素计数完全相同
  // 而是一个字符串是另一个字符串的子集就行
  
  // 以数组方式为例
  function fn(source, target) {
      // 因为是小写字符 即a~z 在Unicode码上是连续的
      // 因此创建长度26的数组 并填充0
      let array = new Array(26).fill(0)
      // 以a为参照 记录Unicode码
      let base = 'a'.charCodeAt()
      // 遍历source 统计字符
      for (let val of source) {
          // a~z 以a为参照 对应数组0~25索引
          array[val.charCodeAt() - base]++
      }
      // 遍历target
      for (let val of target) {
          // 当前字符在source统计数组中为0
          // 说明不存在于source中
          // 或source中对应字符用完了
          if (!array[val.charCodeAt() - base]) {
              return false
          }
          array[val.charCodeAt() - base]--
      }
      return true
  }
  
  // 验证
  console.log('从ab中取aa', fn('ab', 'aa')) // false
  console.log('从ab中取aa', fn('aab', 'aa')) // true

#### 字母异位词分组

- [力扣49](https://leetcode.cn/problems/group-anagrams/description/)

  ```js
  // 排序方法思路
  // 首先明确一点 符合字母异位的字符串 排序后一定是相等的
  // 利用这点 在遍历字符串数组时 将每个字符串转换成数组
  // 然后排序 为了对比再转换成字符串
  // 然后在map中找是否有这个字符串 没有则创建一个数组
  // 以数组转的字符串作为key 创建的数组作为value 填入map中
  // 后续遍历时 遇到排序后的字符串在map中出现 则取其value将对应字符串填入value中
  
  function fn(list) {
      // 先创建哈希表
      let map = new Map()
      for (let val of list) {
          // 将当前字符串转换成数组
          let arr = Array.from(val)
          // 根据Unicode对字符排序
          arr.sort()
          // 将排序后的数组转换成字符串 如 "a,b,c"
          let str = arr.toString()
          // 判断哈希表中是否存在
          // 存在则将原数组取出
          // 不存在则创建新数组
          let list = map.get(str) ? map.get(str) : new Array()
          // 将当前字符串填入该数组
          list.push(val)
          // 排序后的字符串作为key list作为value
          map.set(str, list)
      }
      // 返回一个由map的value组成的新数组
      return Array.from(map.values())
  }
  
  // 验证
  let list = ["eat", "tea", "tan", "ate", "nat", "bat"]
  console.log('排序法', fn(list)) // [["eat","tea","ate"],["tan","nat"],["bat"]]
  
  // 计数思路
  // 同排序方法 只不过是将数组中每一项的字符计数转换成字符串存在对象中作为唯一key
  
  function fn2(list) {
      // 先创建表 不止哈希表 用对象也可
      let map = {}
      for (let val of list) {
          // 因为是全小写字符 即a~z共26个 在Unicode上是连续的 因此创建长度26的初始数组
          let arr = new Array(26).fill(0)
          // 以a为参照 映射到数组中的索引
          let base = 'a'.charCodeAt()
          // 对当前字符串中的字符计数
          for (let str of val) {
              arr[str.charCodeAt() - base]++
          }
          // 转换成字符串
          let key = arr.toString()
          // 判断是否已经存在同样的key
          // 存在则取key对应的value填入当前字符串
          // 不存在则创建新value
          // map[key] ? map[key].push(val) : map[key] = [val]
          let list = map[key] ? map[key] : new Array()
          list.push(val)
          map[key] = list
      }
      return Array.from(Object.values(map))
  }
  
  // 验证
  let list2 = ["eat", "tea", "tan", "ate", "nat", "bat"]
  console.log('计数法', fn2(list2)) // [["eat","tea","ate"],["tan","nat"],["bat"]]

#### 找到字符串中所有字母异位词

- [力扣438](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

  ```js
  // 思路
  // 用滑动窗口的思想 保持窗口长度等于目标字符串长度
  // 丢到判断异位词的方法中进行判断 如果找到了就填入结果数组
  
  function fn(source, target) {
      let result = []
      // 特殊情况 source比target短 那必不可能有异位词
      if (source.length < target.length) {
          return result
      }
      // 识别是否是异位词
      function isAccord(str1, str2) {
          if (str1.length !== str2.length) {
              return false
          }
          let arr = new Array(26).fill(0)
          let base = 'a'.charCodeAt()
          for (let val of str1) {
              arr[val.charCodeAt() - base]++
          }
          for (let val of str2) {
              if (!arr[val.charCodeAt() - base]) {
                  return false
              }
              arr[val.charCodeAt() - base]--
          }
          return true
      }
  
      // 先得到目标字符串长度 因为找异位词必然长度要相同
      let len = target.length
      // 设置快慢指针 形成滑动窗口
      let slow = 0
      let fast = len - 1
      for (fast; fast < source.length; fast++) {
          // 先将滑动窗口内的字符拼成字符串
          let str = []
          for (let i = slow; i <= fast; i++) {
              str.push(source[i])
          }
          str = str.join('')
          // 如果符合 将当前slow索引填入结果数组
          if (isAccord(str, target)) {
              result.push(slow)
          }
          slow++
      }
      return result
  }
  
  // 验证
  let source = "cbaebabacd"
  let target = "abc"
  console.log(fn(source, target)) // [0, 6]
  
  // 简化思路
  // 让滑动窗口内的字符计数是加过的
  // 从滑动窗口起始位置前一个一个清除计数
  // 从而达到只有滑动窗口内的字符有计数 外部没有计数
  
  function fn2(source, target) {
      let result = []
      if (source.length < target.length) {
          return result
      }
      let source_map = new Array(26).fill(0)
      let target_map = new Array(26).fill(0)
      let base = 'a'.charCodeAt()
      // 因为后续滑动窗口遍历时 窗口长度固定 且从source第二个字符开始遍历
      // 所以需要先对起始点进行特殊处理
      // 先根据目标字符串长度对source和target进行计数
      // 因为异位词必然长度相同
      for (let i = 0; i < target.length; i++) {
          source_map[source[i].charCodeAt() - base]++
          target_map[target[i].charCodeAt() - base]++
      }
      // 然后判断两者头部是否符合异位词
      if (source_map.toString() === target_map.toString()) {
          // 头部符合 则填入结果数组
          result.push(0)
      }
      // 滑动窗口开始移动
      let slow = 0
      // 注意 fast初始值是目标字符串长度
      // 因为要保持与target长度相同的滑动窗口
      // 而这个窗口起始位置是 slow后 结束位置是 fast
      // 即是从source第二个位置开始才是滑动窗口
      // 这样设置的原因是要从slow处一个一个清除计数
      // 保持仅有滑动窗口内的计数存在
      for (let fast = target.length; fast < source.length; fast++) {
          // 清除slow位置处的计数
          source_map[source[slow].charCodeAt() - base]--
          // 对当前fast位置 也就是滑动窗口末尾位置计数
          source_map[source[fast].charCodeAt() - base]++
          // 判断当前滑动窗口是否符合异位词
          if (source_map.toString() === target_map.toString()) {
              // 注意！slow是清除计数位置 slow后一位才是滑动窗口起始位置
              result.push(slow + 1)
          }
          slow++
      }
      return result
  }
  
  // 验证
  let source2 = "cbaebabacd"
  let target2 = "abc"
  console.log('简化版', fn2(source2, target2)) // [0, 6]

### Set、Map

#### 两个数组的交集

- [力扣349](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

  ```js
  // 思路
  // 求交集本质是遍历一个数组 取每个值到另一个数组中找是否存在
  // 所以最主要的是如何去除重复的值 所以用Set或Map
  
  function fn(list1, list2) {
      // 根据数组大小交换操作的数组
      if (list1.length < list2.length) {
          let t = list1
          list1 = list2
          list2 = t
      }
      // 用哈希表存结果 利用set可以去重的特性
      let result = new Set()
      // 用长的数组list1构造哈希表
      let list1Set = new Set(list1)
      for (let val of list2) {
          if (list1Set.has(val)) {
              result.add(val)
          }
      }
      return Array.from(result)
  }
  
  // 简化版
  function fn2(list1, list2) {
      // 遍历list1 在list2中找有没有相同的值
      // 初筛的交集会有重复值 再用Set去重
      return Array.from(new Set(list1.filter(item => list2.includes(item))))
  }
  
  // 验证
  let nums1 = [4, 9, 5]
  let nums2 = [9, 4, 9, 8, 4]
  console.log('fn结果：' + fn(nums1, nums2))
  console.log('fn2结果：' + fn(nums1, nums2))

#### 两个数组的交集 II

- [力扣350](https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/)

  ```js
  // 哈希表思路
  // 遍历较短的数组 用哈希表进行计数
  // 再遍历较长的数组 将其每个值放到哈希表中的找
  // 找到对应元素 则将其添加到结果数组 并将哈希表中计数-1
  // 如果哈希表中计数已经为0 则将其从哈希表中剔除
  // 这样就可以实现取较短数组交集
  
  
  // 双指针思路
  // 先排序 然后设置两个指针分别遍历两个数组
  // 哪边小就移动哪边指针 直到找到相同元素
  // 然后同时移动两边指针 交集数组达到最短
  
  function fn(list1, list2) {
      // 首先对两个数组排序
      list1 = list1.sort()
      list2 = list2.sort()
      // 设两个指针 分别遍历两个数组
      let l1 = 0
      let l2 = 0
      let result = []
      // 题目要求取交集次数最少的作为结果 因此当较短数组遍历完就停止
      while (l1 < list1.length && l2 < list2.length) {
          switch (true) {
              // 因为是排过序的 哪一边小则移动那一边
              // 直到找到相同的
              case list1[l1] < list2[l2]:
                  l1++
                  break
              case list1[l1] > list2[l2]:
                  l2++
                  break
              case list1[l1] === list2[l2]:
                  // 说明找到了 将其添加到结果中
                  // 并同时移动两边指针
                  result.push(list1[l1])
                  l1++
                  l2++
                  break
          }
      }
      return result
  }
  
  // 验证
  let nums1 = [4, 9, 5]
  let nums2 = [9, 4, 9, 8, 4]
  console.log('排序后求交集' + fn(nums1, nums2)) // [4, 9]

#### 快乐数

- [力扣202](https://leetcode.cn/problems/happy-number/description/)

  ```js
  // 思路
  // 求和可以通过取余 以及除以10来从各位一级一级取值累计平方和
  // 将求平方和结果存到哈希表中 如果出现重复值说明进入无限循环
  // 说明此时要么是1(快乐数) 要么不符合快乐数
  
  function fn(num) {
      // 求和方法
      function getSum(n) {
          let sum = 0
          // 思路就是用取余操作取个位数计算
          // 然后每次循环除以10舍弃个位
          while (n) {
              sum += (n % 10) ** 2
              n = Math.floor(n / 10)
          }
          return sum
      }
  
      // 设置哈希表 记录每次平方和结果
      let map = new Set()
      // 循环条件是 数字没有变为1 且 哈希表中没有重复的结果
      // 哈希表中有重复的平方和结果 说明无限循环了
      while (num !== 1 && !map.has(num)) {
          map.add(num)
          num = getSum(num)
      }
      // 此时循环结束 有可能num不为1 说明无限循环 且不是快乐数
      // 也可能num为1 说明符合条件
      return num === 1
  }
  
  // 验证
  console.log('19是快乐数吗？' + fn(19)) // true

### 数字之和

#### 两数之和

- [力扣1](https://leetcode.cn/problems/two-sum/description/)

  ```js
  // 思路
  // 使用哈希表存遍历过的元素 每遍历到一个元素 求它的另一半值
  // 再到遍历过的表中去找 找到就直接返回结果
  // 这样就只用遍历一遍数组
  
  function fn(source, target) {
      // 设置哈希表 记录 遍历过 的元素
      // 因为要存元素及元素对应的下标 组成key value的形式
      // 而Set只能存key 数组做哈希表范围太大不适合 所以用Map 
      let map = new Map()
      for (let i = 0; i < source.length; i++) {
          // 本题是找到 两个值 和为target
          // 根据source中当前值 求另一个值大小
          let num = target - source[i]
          // 到哈希表中找 是否存在
          if (map.has(num)) {
              // 找到 说明已经遍历过
              return [map.get(num), i]
          }
          // 没找到 则将当前值存到哈希表
          map.set(source[i], i)
      }
      // 循环结束 没找到符合条件的值
      return []
  }
  
  // 验证
  let nums = [2, 11, 15, 7]
  let target = 9
  console.log('和为9的两值索引为：' + fn(nums, target)) // [0, 3]
  ```

#### 四数相加II

- [力扣454](https://leetcode.cn/problems/4sum-ii/description/)

  ```js
  // 思路
  // 四数之和可以拆成 两个两数之和
  // 先将前两个数组中所有可能的两数和放在哈希表中做一个统计
  // 在后两个数组两层循环求和时 用两数之和的思想 求另一半的值
  // 到哈希表中去找 找到则累加其统计值
  // 统计值表示有多少种可能合成另一半的值
  
  function fn(A, B, C, D, target) {
      // 设置哈希表 统计两数和有多少种可能
      let map = new Map()
      // 先统计前两个数组
      for (let a of A) {
          for (let b of B) {
              let n = a + b
              map.set(n, (map.get(n) || 0) + 1)
          }
      }
      // 记录有多少种可能
      let count = 0
      // 再到另外两个数组中 求另一半的和
      for (let c of C) {
          for (let d of D) {
              let n = c + d
              let n2 = target - n
              if (map.has(n2)) {
                  // 另一半的值 有多少种组合 就进行累加
                  count += map.get(n2)
              }
          }
      }
      return count
  }
  
  // 验证
  let A = [1, 2]
  let B = [-2, -1]
  let C = [-1, 2]
  let D = [0, 2]
  let target = 0
  console.log('四数之和得到0有 ' + fn(A, B, C, D, target) + ' 种可能') // 2

#### 三数之和

- [力扣15](https://leetcode.cn/problems/3sum/)

  ```js
  // 双指针思路
  // 关键点1 数组先进行排序
  // 将三数之和拆成 双数和 与 单数
  // 设两层循环 第一层为单数值 第二层为双数和
  // 题目要求不能有重复的结果 因此要对 单数 和 双数 去重
  // 第一层每次循环固定单数值
  // 关键点2 单数值去重 因为排过序 所以相同值是挨着的
  // 数组中只取第一个不同值
  // 又因数组排过序 应用二分法思想 第二层循环 在左右两端设置指针
  // 双数和与单数之和小于目标值 则移动左指针放大
  // 大于目标值 则移动右指针缩小
  // 关键点3 双数去重 思路还是只取第一个不同的值
  
  function fn(nums, target) {
      // 关键点1 先对数组排序
      nums.sort()
      let result = []
  
      for (let c = 0; c < nums.length; c++) {
          let cNum = nums[c]
          // 每次循环先判断当前数是否大于目标值
          if (cNum > target) {
              // 排过序的数组 如果当前值大于目标值
              // 后续双指针的值只会大于目标值
              // 不可能得到三数和等于目标值
              // 注：只适用于target为正数 负数是越加越小的
              return result
          }
          // 关键点2 已经取过的值就要跳过
          // 但此处不能向后比较 因为向后比较是三元组内的数去重
          // 比如cNum = -3 左指针 = -3 右指针 = 6
          // 三元组允许[-3, -3. 6]作为结果值 但不允许有多个相同结果值
          // 如果nums[c] == nums[c + 1]就跳过 那么[-3, -3. 6]的结果值就会被跳过
          // 因此要向前比较
          if (c > 0 && nums[c] === nums[c - 1]) {
              // 如果当前数与前一个数相同 则跳过当前循环
              continue
          }
          // 设置左右指针 分别置于数组前后位置
          let a = c + 1 // 从c后一位开始向后遍历
          let b = nums.length - 1 // 从数组末尾向前遍历
          // 注意 a == b 不能进循环 因为是三数之和 a == b说明左右指针到一个位置
          while (a < b) {
              let aNum = nums[a]
              let bNum = nums[b]
              let sum = cNum + aNum + bNum
              if (sum < target) {
                  // 如果三数和小于目标值 说明在第一层循环中 要调大左边界的值
                  a++
              } else if (sum > target) {
                  // 如果大于目标值 说明要调小右边界的值
                  b--
              } else {
                  // 关键点3 对a和b的值进行去重
  
                  // 方式1 向内比较
                  // 找到结果值了 
                  result.push([cNum, aNum, bNum])
                  while (nums[a] === nums[a + 1]) {
                      // 循环找到最后一个相同值的位置 后面还会a++ 就会找到不同值
                      a++
                  }
                  while (nums[b] === nums[b - 1]) {
                      // 右指针已经是数组末尾了 就要向前找 后面还有b--
                      b--
                  }
                  // 找到结果值后 因为第二层循环中c是固定值
                  // 因此要找不同三元组就必须同时移动左右指针
                  a++
                  b--
  
                  // 方式2 向外比较
                  // if (a > c + 1) {
                  //     // a b循环找到第一个不同的值
                  //     while (nums[a] === nums[a - 1]) {
                  //         a++
                  //     }
                  //     while (nums[b] === nums[b + 1]) {
                  //         b--
                  //     }
                  //     aNum = nums[a]
                  //     bNum = nums[b]
                  //     sum = cNum + aNum + bNum
                  //     if (sum < target) {
                  //         a++
                  //     } else if (sum > target) {
                  //         b--
                  //     } else {
                  //         result.push([cNum, aNum, bNum])
                  //         a++
                  //         b--
                  //     }
                  // } else {
                  //     // a == c + 1
                  //     // 因为左指针刚开始是在c后一位 所以要特殊处理
                  //     result.push([cNum, aNum, bNum])
                  //     a++
                  //     b--
                  // }
  
                  // 对比方式1 2 可以看出 while (a < b)循环中
                  // 最好把循环遍历找到的第一个不同的值留给下一次while (a < b)循环去处理
                  // 当前while (a < b)循环只找到不同值的上一位即可 不然会多很多冗余代码
                  // 这也是为什么nums[c] === nums[c - 1]和上一位数比较 来去重
                  // 而nums[a] === nums[a + 1]是向自身下一位数比较 来去重
              }
          }
      }
  
      return result
  }
  
  // 验证
  let nums = [-1, 0, 1, 2, -1, -4]
  let target = 0
  console.log('三数之和有多少种结果？', fn(nums, target)) // [[-1,-1,2],[-1,0,1]]
  nums = [0,1,1]
  console.log('三数之和有多少种结果？', fn(nums, target)) // []
  nums = [0,0,0]
  console.log('三数之和有多少种结果？', fn(nums, target)) // [[0,0,0]]

#### 四数之和

- [力扣18](https://leetcode.cn/problems/4sum/description/)

  ```js
  // 思路
  // 四数之和 同 三数之和思路 将其拆成 单数 + 单数 + 双数
  // 只是在三数之和的基础上加了层循环
  // 三数 四数 五数之和都是同理 将暴力解法的时间复杂度降低一个量级
  // 如三数之和是将n^3的复杂度降低为n^2 两数之和将n^2降低为n
  // 本题与三数之和不同点在于 三数之和target为正数
  // 而本题四数之和可以是任意值 而负数是越加越小的
  // 所以不能用 nums[i] > target来剪枝
  // 而得用 nums[i] > target && nums[i] > 0来剪枝
  // 撇去正数且大于target的 因为是升序数组
  // 比target大且为正数 后续数相加必定比target大 不再循环遍历
  
  function fn(list, target) {
      list.sort()
      let result = []
  
      for (let a = 0; a < list.length; a++) {
          // 单数进行剪枝操作
          // 当前值大于目标值 后续值之和也会大于目标值
          if (list[a] > target && list[a] >= 0) {
              break
          }
          // 对排序数组中的数进行去重
          if (a > 0 && list[a] === list[a - 1]) {
              continue
          }
          // 注意 是从第一层单数的后一位开始遍历
          for (let b = a + 1; b < list.length; b++) {
              // 剪枝
              // 注意 本题所求为和 所以以和大于目标值进行剪枝
              // 因为本题target为任意值 所以不能单以当前单数大于目标值进行剪枝
              // 如target = -10 a = -10 b = -3 b虽然大于target 但是a+b其实是小于目标值的
              if (list[b] + list[a] > target && list[b] + list[a] >= 0) {
                  break
              }
              // 去重
              // 注意 如果是刚开始循环 前一位是a不进行去重判断
              // b > a + 1很重要 不然会导致如[2,2,2,2] target = 8无法得到结果
              if (b > a + 1 && list[b] === list[b - 1]) {
                  continue
              }
  
              // 双数
              let c = b + 1 // 左指针 以第二层循环后一位开始
              let d = list.length - 1 // 右指针 数组末尾开始
              while (c < d) {
                  let sum = list[a] + list[b] + list[c] + list[d]
                  if (sum < target) {
                      // 和小于目标值 增大左指针
                      c++
                  } else if (sum > target) {
                      // 和大于目标值 缩小右指针
                      d--
                  } else {
                      // 找到了 先将结果填入数组
                      result.push([list[a], list[b], list[c], list[d]])
                      // 再进行双数去重
                      while (list[c] === list[c + 1]) {
                          // 左指针与后一位相等 则往后走一格
                          c++
                      }
                      while (list[d] === list[d - 1]) {
                          // 右指针与前一位相等 则往前走一格
                          d--
                      }
                      // 找到目标值 向内收缩左右指针
                      c++
                      d--
                  }
              }
          }
      }
  
      return result
  }
  
  // 验证
  let nums = [1, 0, -1, 0, -2, 2]
  let target = 0
  console.log('四数之和有多少种结果？', fn(nums, target)) // [[-1, -2, 1, 2], [-1, 0, 0, 1], [-2, 0, 0, 2]]
  nums = [2, 2, 2, 2, 2]
  target = 8
  console.log('四数之和有多少种结果？', fn(nums, target)) // [[2, 2, 2, 2]]