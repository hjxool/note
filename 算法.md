- 按照如下类型来学习
  - `数组-> 链表-> 哈希表->字符串->栈与队列->树->回溯->贪心->动态规划->图论->高级数据结构`，从简单做起，做了几个类型题目之后，再慢慢做中等题目、困难题目

## 全排列

- 定义
  - 从**n**个不同元素中任取**m**（**m**≤**n**）个元素，按照一定的顺序排列起来，叫做从**n**个不同元素中取出**m**个元素的一个排列。当**m**=**n**时，所有的排列情况叫做全排列
  - 如：`abc`全排列的结果有`abc acb bac bca cab cba`

- (最简单)排序比较

  ```js
  function sort(str1, str2) {
      // 长度不相等 或 字符串完全相同
      if (str1.length !== str2.length || str1 === str2) {
          return false
      }
      let t1 = str1.split('').sort().toString()
      let t2 = str2.split('').sort().toString()
      return t1 === t2
  }
  console.log('排序比较 abc 和 acb', sort('abc', 'acb')) // true
  console.log('排序比较 acg 和 acg', sort('acg', 'acg')) // false
  ```

- 用`map`比较

  ```js
  // 思路
  // 先统计str1出现字符及个数
  // 再遍历str2 遇到str1中未出现字符说明不符
  // 遇到存在的字符则-1 如果已经为0且还需要-1说明对应字符少了 返回false
  // 注意 因为已经过滤了两字符串长度不相等的情况 所以字符个数如果不同
  // 必然会有一个多 有一个少 只要计数已经为0 还需要-1说明不符
  function map(str1, str2) {
      if (str1.length !== str2.length || str1 === str2) {
          // 长度不等 或 完全相等 都不符合
          return false
      }
      let m = new Map()
      // 遍历统计出现字符及个数
      for (let val of str1) {
          m.set(val, (m.get(val) || 0) + 1)
      }
      for (let val of str2) {
          let count = m.get(val) // 值为0或undefined
          if(count){
              // 存在对应字符 则-1
              m.set(val, count - 1)
          } else {
              // 有str1中没出现的字符 或 字符个数不符
              return false
          }
      }
      return true
  }
  console.log('用map比较 abcd 和 accd', map('abcd', 'accd')) // false
  console.log('map比较 abcd 和 aebd', map('abcd', 'aebd')) // false

## 数组

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)

### 二分法

#### 二分查找

- [力扣704](https://leetcode.cn/problems/binary-search/description/)

  ```js
  // 时间复杂度：O(log n)
  // 空间复杂度：O(1)
  
  // 方式1 左闭右闭区间
  function fn1(list, target) {
      let left = 0 // 左闭[0, right)
      let right = list.length - 1 // 右闭[left, length-1]
      // 左右能够相等就是 左闭右闭
      while (left <= right) {
          // 每次循环计算中间位置索引和值
          // >> 是将值转换为10后向右移动 1位
          // 相当于Math.floor((right - left) / 2)
          let mid = left + ((right - left) >> 1)
          if (list[mid] > target) {
              // 区间内中间值比目标值大
              // 则缩小右区间(最大值)
              // 又因为是右闭合 且已知mid≠target 所以mid值可以排除
              // 因此右区间等于mid - 1 向内缩一格
              right = mid - 1
          } else if (list[mid] < target) {
              // 中间值比目标值小
              // 则加大左区间(最小值)
              // 又因为是左闭合 且已知mid≠target 所以mid值可以排除
              // 因此左区间等于mid + 1 向内缩一格
              left = mid + 1
          } else {
              // 中间值等于目标值 找到 直接返回
              return mid
          }
      }
      // 循环结束 都没有找到
      return -1
  }
  
  // 验证
  console.log(fn1([1, 2, 3, 4], 3)) // 2
  
  // 方式2 左闭右开区间
  function fn2(list, target) {
      let left = 0 // 依旧是左闭 同方法1
      let right = list.length // 右开[left, length)
      // 因为右边是开区间 所以左右必不可能相等
      while (left < right) {
          let mid = left + ((right - left) >> 1)
          if (list[mid] > target) {
              // 中间值比目标值大 则缩小最大值
              // 又因为右是开区间 所以不可能等于最大值
              // 因此不需要-1
              right = mid
          } else if (list[mid] < target) {
              // 同方法1
              left = mid + 1
          } else {
              return mid
          }
      }
      // 没有找到返回-1
      return -1
  }
  
  // 验证
  console.log(fn2([1, 6, 22, 44, 78], 22)) // 2

#### 搜索插入位置

- [力扣35](https://leetcode.cn/problems/search-insert-position/description/)

  ```js
  // 时间复杂度：O(log n)
  // 空间复杂度：O(1)
  
  // 搜索插入位置 本质就是找到临近目标值 第一个等于或小于目标值的位置
  
  // 以左闭右开区间方式为例
  function fn(list, target) {
      let left = 0
      let right = list.length - 1
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          // 因为是找第一个大于目标值的值
          // 等同于找循环结束后的右区间(最大值)
          // 且这个值不会和目标值相等
          // 因此判断条件为 大于时 和 小于等于时
          if (list[mid] > target) {
              right = mid - 1
          } else if (list[mid] < target) {
              left = mid + 1
          } else {
              // 此时已经找到第一个等于的值
              return mid
          }
      }
      // 没找到等于的值 但是循环已经结束 返回离目标值最近且大于它的值
      // 因为left<=right是循环条件 所以最后right<left
      // 因此right要加1
      return right + 1
  }
  
  // 验证
  console.log('目标值小于所有值时:' + fn([3, 4, 5, 6], 1)) // 0
  console.log('目标值大于所有值时:' + fn([3, 4, 5, 6], 10)) // 4
  console.log('目标值等于某一元素:' + fn([1, 4, 7, 15], 4)) // 1
  console.log('目标值在区间内且不等于任意值:' + fn([1, 4, 7, 15], 8)) // 3
  console.log('目标值等于某一连续元素:' + fn([1, 4, 4, 4, 7, 15], 4)) // 2
  
  // 简化fn方法
  function fn2(list, target) {
      let left = 0
      let right = list.length - 1
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          if (list[mid] < target) {
              left = mid + 1
          } else {
              // 因为要的是右区间或等于的值 所以把两者条件合并到一起
              right = mid - 1
          }
      }
      return right + 1
  }

#### 在排序数组中查找元素的第一个和最后一个位置

- [力扣34](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

  ```js
  // 思路
  // 用二分法分别找到
  // 目标值出现的第一个位置 即list[mid] >= target来不断移动右区间
  // 和目标值出现的最后一个位置 即list[mid] <= target来不断移动左区间
  // 情况1：不在数组范围内 返回{-1, -1}
  // 情况2：在范围内 但不存在 返回{-1, -1}
  // 情况3：在范围内 且存在 返回[left, right]左闭右闭区间
  
  class Fn {
      constructor(list, target) {
          this.left = this.getLeft(list, target)
          this.right = this.getRight(list, target)
          this.range = this.getRange()
      }
      getRight(list, target) {
          let left = 0
          let right = list.length - 1
          while (left <= right) {
              let mid = left + ((right - left) >> 1)
              // 注意
              // 因为是找目标值右边界 所以要让left不断移动 而不去动right
              // 当最后一次循环left == right后
              // 此时left > right 此时right就等于目标值最末尾的位置
              if (list[mid] <= target) {
                  left = mid + 1
              } else if (list[mid] > target) {
                  right = mid - 1
              }
          }
          // 因为要的是等于目标值的最末尾位置 所以不加1
          return right
      }
      getLeft(list, target) {
          let left = 0
          let right = list.length - 1
          while (left <= right) {
              let mid = left + ((right - left) >> 1)
              // 注意
              // 因为是找左边界 所以要让right不断移动 而不去动left
              // 当最后一次循环left == right后
              // 此时left > right 此时left就等于目标值第一次出现的位置
              if (list[mid] < target) {
                  left = mid + 1
              } else if (list[mid] >= target) {
                  right = mid - 1
              }
          }
          return left
      }
      getRange(left = this.left, right = this.right) {
          if (left > right) {
              // 说明 没有找到目标值 返回 -1
              return [-1, -1]
          } else {
              // left <= right 说明目标值存在且取到了左右边界
              return [left, right]
          }
      }
  }
  
  // 验证
  console.log('不在数组范围内', new Fn([1, 2, 3], 4)) // left:3 right:2 range:[-1, -1]
  console.log('在范围内但不存在', new Fn([1, 2, 3, 5], 4)) // left:3 right:2 range:[-1, -1]
  console.log('在范围内且存在', new Fn([1, 2, 2, 2, 3, 4], 2)) // left:1 right:3 range:[1, 3]
  console.log('在范围内且存在', new Fn([1, 2, 3, 4], 2)) // left:1 right:1 range:[1, 1]

#### x的平方根

- [力扣69](https://leetcode.cn/problems/sqrtx/description/)

  ```js
  // 二分法思路
  // 视数字为1到n的整数数组 不断求 中间值平方是否等于n
  // 如果等于则直接返回中间值
  // 如果没找到 以左闭右闭区间为例 最后一次循环 left == right
  // 执行完left > right 所以取right值为开根号后的整数值
  
  function fn(num) {
      // 0 和 1 的平方根等于自身
      if (num === 0 || num === 1) {
          return num
      }
      let left = 1
      let right = num
      // 左闭右闭区间
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          if (mid * mid > num) {
              // 中间值的平方大于目标值 自然要缩小中间值
              // 因此缩小最大值(右区间)
              right = mid - 1
          } else if (mid * mid < num) {
              // 中间值的平方小于目标值 自然要增大中间值
              // 因此增大最小值(左区间)
              left = mid + 1
          } else {
              // 找到平方根值
              return mid
          }
      }
      // 循环结束 没找到mid * mid == num
      // 此时left > right 取right值返回
      return right
  }
  
  // 验证 平方根只保留整数 舍弃小数位
  console.log('二分法4的平方根:' + fn(4)) // 2
  console.log('二分法8的平方根:' + fn(8)) // 2
  console.log('二分法15的平方根:' + fn(15)) // 3
  ```

#### 有效的完全平方数

- [力扣367](https://leetcode.cn/problems/valid-perfect-square/description/)

  ```js
  // 思路
  // 同力扣69的求平方根 只不过本题只求整数平方正好等于原值 其他算作false
  // 因此只需在力扣69的基础上将return right改为return false
  
  function fn(num) {
      if (num === 0 || num === 1) {
          return true
      }
      let left = 1
      let right = num
      // 以左闭右闭为例
      while (left <= right) {
          let mid = left + ((right - left) >> 1)
          if (mid * mid > num) {
              right = mid - 1
          } else if (mid * mid < num) {
              left = mid + 1
          } else {
              return true
          }
      }
      return false
  }
  
  // 验证
  console.log('4的有效平方数:' + fn(4)) // true
  console.log('8的有效平方数:' + fn(8)) // false
  console.log('15的有效平方数:' + fn(15)) // false

### 双指针

#### 移除元素

- [力扣27](https://leetcode.cn/problems/remove-element/description/)

  ```js
  // 思路
  // 数组删除元素在内存中本质上是将删除位置后面所有元素向前移动一格
  // 删除后数组长度在内存中其实没变 末尾元素其实还在内存里 只是不进行处理
  // 所谓的数组长度改变 只是通过编程语言封装的方法返回给你的结果
  // 以此为理论基础 就可以设置一个快指针 它必然可以遍历完原数组
  // 再设置一个慢指针 它表示删除元素后的新数组
  // 每遇到一个要删除的元素就停滞一下 从而跟快指针拉开距离
  // 并将快指针所在位置不同于删除元素的值赋值给慢指针当前位置
  // 因为慢指针赋值后会往前移动 慢指针位置索引 === 新数组.length
  
  // 时间复杂度：O(n)
  // 空间复杂度：O(1)
  
  function fn(target, source) {
      let slowIndex = 0
      for (let fastIndex = 0; fastIndex < source.length; fastIndex++) {
          // 快指针当前值不等于目标值 则将该值赋值给慢指针当前停留位置
          // 并移动慢指针
          if (source[fastIndex] !== target) {
              source[slowIndex] = source[fastIndex]
              slowIndex++
          }
      }
      return slowIndex
  }
  
  // 验证
  let list = [11, 4, 22, 3, 4, 3, 11, 3]
  console.log('删除3后数组长度:' + fn(3, list)) // 5

#### 删除排序数组中的重复项

- [力扣26](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

  ```js
  // 思路
  // 同力扣27 只不过目标值是动态的
  
  function fn(source) {
      let slow = 0
      // 因为是有序数组 因此重复元素是排在一起的
      // 设置target作为动态目标值
      let target
      let newList = [] // 慢指针作为新数组索引
      for (let fast = 0; fast < source.length; fast++) {
          // 第一次循环时 target 是undefined
          // 后续遍历时target每次只会等于不同的值
          // 就意味着会去重只将不同的值放入新数组
          if (source[fast] !== target) {
              // 第一次循环时赋初值
              target = source[fast]
              newList[slow++] = source[fast]
          }
      }
      return newList
  }
  
  // 验证
  let list = [0, 1, 1, 1, 2, 2, 3, 4, 4]
  console.log('去重结果', fn(list)) // [0, 1, 2, 3, 4]

#### 移动零

- [力扣283](https://leetcode.cn/problems/move-zeroes/description/)

  ```js
  // 思路
  // 同力扣27删除元素 只不过在删除目标值形成新数组后
  // 此时慢指针位置在超出新数组末尾后一格
  // 删除多少个元素 就在末尾补多少个同样的元素
  // 因此就可以从慢指针位置开始到原数组末尾覆盖为同样的值
  
  // 时间复杂度：O(n)
  // 空间复杂度：O(1)
  
  function fn(source, target) {
      let slow = 0
      // 第一遍遍历将非目标值往前移动
      for (let fast = 0; fast < source.length; fast++) {
          if (source[fast] !== target) {
              source[slow++] = source[fast]
          }
      }
      // 第二遍遍历 从慢指针索引位置开始用目标值覆盖数组后面的值
      for (let i = slow; i < source.length; i++) {
          source[i] = target
      }
      return source
  }
  
  // 验证
  let list = [0, 1, 0, 3, 0, 0, 1]
  console.log('移动0', fn(list, 0)) // [1, 3, 1, 0, 0, 0, 0]

#### 比较含退格的字符串

- [力扣844](https://leetcode.cn/problems/backspace-string-compare/description/)

  ```js
  // 重构字符串思路
  // 设一个新数组 将遇到的非#(退格)字符填入新数组
  // 当遇到#就对新数组执行出栈 最后对比新数组组成的字符串
  
  // 时间复杂度：O(N+M) N和M表示两个字符串个遍历一次
  // 空间复杂度：O(N+M)
  
  function fn(str1, str2) {
      let a1 = []
      let a2 = []
      for (let val of str1) {
          if (val != '#') {
              a1.push(val)
          } else if (val == '#') {
              a1.pop()
          }
      }
      for (let val of str2) {
          if (val != '#') {
              a2.push(val)
          } else if (val == '#') {
              a2.pop()
          }
      }
      return a1.join('') === a2.join('')
  }
  
  // 验证
  let t1 = 'ab#c'
  let t2 = 'ab##ac'
  console.log('重构字符串结果:' + fn(t1, t2)) // true
  
  // 双指针法思路
  // 因为#号会删除自身前一个非#号字符 且多个#号会累计删除字符数量
  // 因此指针因该从后往前遍历 这样在遇到#号时就累计 遇到非#号就减少累计
  // 两个指针分别指向两个数组末尾 然后放在同一个大循环中
  // 这样做的目的是为了让两个指针共同递减
  // 然后每一轮大循环中 执行各自的小循环
  // 小循环中一直累计和减少累计 直到累计为0 即当前指针所指向的值被保留就break
  // 然后在当前大循环中对比
  // 情况一 两个指针都没遍历完 且 两指针位置的保留字符不相同 这表示最终字符串一定不相同 return false
  // 情况二 情况一不符的条件下 任一指针没遍历完 这表示有一个指针已经遍历完 另一个没遍历完停在了保留字符
  // 即 最终字符串长度不同 也 return false
  // 情况一二都不符 说明两字符串还有相同的可能性 则对两指针同时递减 开启新一轮(大循环中的)小循环
  // 直到两指针都小于0 说明两字符串都遍历结束 结束大循环 进行到此时都没有触发情况一二
  // 说明字符串相等 return true
  
  function fn2(str1, str2) {
      let index1 = str1.length - 1 // 索引
      let count1 = 0 // #号累计(即要删除的字符数)
      let index2 = str2.length - 1
      let count2 = 0
      // >=0 是为了让两字符串都遍历完 再得出结果
      while (index1 >= 0 || index2 >= 0) {
          while (index1 >= 0) {
              if (str1[index1] === '#') {
                  // 如果遇到#号就累加
                  count1++
                  index1--
              } else if (count1 > 0) {
                  // 如果遇到非#号字符则减少累计
                  count1--
                  index1--
              } else {
                  // 没有累计 即不需要删除 就跳出循环准备对比
                  break
              }
          }
          while (index2 >= 0) {
              if (str2[index2] === '#') {
                  count2++
                  index2--
              } else if (count2 > 0) {
                  count2--
                  index2--
              } else {
                  break
              }
          }
          if (index1 >= 0 && index2 >= 0) {
              // 两字符串都没遍历完
              if (str1[index1] !== str2[index2]) {
                  // 保留字符不同 说明两字符串不同
                  return false
              }
          } else if (index1 >= 0 || index2 >= 0) {
              // 不满足前一个条件 说明有一个字符串已经遍历完
              // 即 字符串长度不相同
              return false
          }
          // 说明两字符串当前循环对比的字符相同 继续进入大循环
          // 或 两个字符串都遍历完了 跳出循环
          index1--
          index2--
      }
      return true
  }
  
  // 验证
  let str1 = 'a##ab#c'
  let str2 = '##ac#c'
  console.log('双指针验证结果:' + fn2(str1, str2)) // true

#### 有序数组平方

- [力扣977](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)

  ```js
  // 思路
  // 题目条件是升序排列数组 因为数组中有负数所以平方后负数可能会大于正数平方
  // 利用题目条件 先找到负数和正数的分界位置
  // 因为负数越小 平方越大 所以负数是从最小的负数开始递减遍历
  // 而正数索引则是从最小正整数开始递增遍历
  // 将这两者遍历放到一个循环中执行 每轮对比正数和负数的平方值大小
  // 将较小值填入新数组 直到一方遍历完 将另一方值依序填入新数组
  
  function fn(list) {
      let boundary // 记录分界位置
      // 注意是升序数组 如果起始位置不是负数 则跳过循环
      for (let i = 0; i < list.length; i++) {
          if (list[i] < 0) {
              boundary = i
          } else {
              break
          }
      }
      let j = boundary // 遍历负数索引
      let k = boundary + 1 // 遍历正数索引
      let newList = [] // 结果数组
      while (j >= 0 || k < list.length) {
          if (j < 0) {
              // 负数先遍历完
              // 则将正数按序填入
              newList.push(list[k] * list[k])
              k++
          } else if (k === list.length) {
              // 正数先遍历完
              // 将负数按序填入
              newList.push(list[j] * list[j])
              j--
          } else if (list[j] * list[j] < list[k] * list[k]) {
              // 负数的平方比正数小 则将负数平方填入新数组
              newList.push(list[j] * list[j])
              j--
          } else {
              // 负数平方比正数平方大 则将正数平方填入数组
              newList.push(list[k] * list[k])
              k++
          }
      }
      return newList
  }
  
  // 验证
  let list = [-4, -1, 0, 5, 10]
  console.log('平方数数组为', fn(list)) // [0, 1, 16, 25, 100]

### 滑动窗口

- 双指针的变体

#### 长度最小的子数组

- [力扣209](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

  ```js
  // 思路
  // 条件:子数组必须是连续的
  // 用快指针表示子数组末尾 慢指针表示子数组起始位置
  // 快指针用于遍历原数组 每移动一步进行累加
  // 每次累加后 判断当前累加值是否 >=目标值
  // 如果符合条件 则更新最短长度记录 并减去起始位置值
  // 然后移动起始位置 目的是缩短快慢指针之间的间距 求得满足条件的最短数组长度
  // 如果缩短(自减)后 依然满足 累加值>=目标值 则继续缩短
  // 所以要用while来作 条件判断 以及 递减循环
  // 直到快指针循环结束 return 最终结果值
  
  // 时间复杂度：O(n)
  // 空间复杂度：O(1)
  
  function fn(list, target) {
      let slow = 0 // 起始位置
      let result = list.length // 初始值为原数组长度 便于后面判断更新值
      let sum = 0 // 累计值
      for (let fast = 0; fast < list.length; fast++) {
          sum += list[fast]
          // 如果当前累计值>=目标值
          while (sum >= target) {
              // 求当前快慢指针间距
              let len = fast - slow + 1 // 这里都是索引 计算长度要+1
              result = result > len ? len : result // 对比 取最小长度作为结果
              sum -= list[slow] // 减去起始位置值后再进行判断
              slow++ // 移动起始位置
          }
      }
      return result
  }
  
  // 验证
  let list = [1, 2, 5, 1, 0, 5, 3]
  console.log('最小子数组长度:' + fn(list, 5)) // 1

#### 水果成篮

- [力扣904](https://leetcode.cn/problems/fruit-into-baskets/description/)

  ```js
  // 思路
  // 条件：子数组至多包含两种元素
  // 不同于力扣209找最短子数组 使用累计值作为判断条件来移动慢指针
  // 本题用哈希表来记录元素种类 并计数 用哈希表长度作为判断条件来移动慢指针
  
  // 时间复杂度：O(n)
  // 空间复杂度：O(1)
  
  function fn(source) {
      let slow = 0 // 起始位置的索引
      // 创建哈希表 利用其特性 确保同一元素只存在一个 并计数
      // 特性 同一key只会存在一个 后续添加同一key只会重新赋值
      let map = new Map()
      let result = 0 // 不同于力扣209找最短 此处是找最长 所以初始值为0
      for (let fast = 0; fast < source.length; fast++) {
          // 循环一开始先将末尾索引值添加到哈希表 并计数
          // 为了计数 所以要先用get读取对应key的值再+1 如果不存在对应key则初始化为0再+1
          map.set(source[fast], (map.get(source[fast]) || 0) + 1)
          // 然后判断哈希表长度 如果超过2说明slow到fast之间存在超过2个不同元素
          while (map.size > 2) {
              // 那么就要从起始位置开始删 并减少哈希表中存的对应元素的计数
              // 直到哈希表长度<=2 即slow到fast之间的元素种类<=2
              map.set(source[slow], map.get(source[slow]) - 1) // 能存到哈希表的最小值都是1
              if (map.get(source[slow]) === 0) {
                  // 判断当前元素在哈希表中计数是否已经归零
                  // 即该元素在slow到fast之间将不复存在 需要从哈希表中删除其记录
                  map.delete(source[slow])
              }
              // 只要当前slow到fast区间内元素种类数不符 就缩短slow到fast区间
              // 即从滑动窗口起始位置(slow)开始删除元素 直到map.size <= 2
              slow++
          }
          // 进行到此处说明滑动窗口内的元素种类已经符合条件
          // 则进行历史长度和当前长度对比 取最大值记录为历史值
          result = result < (fast - slow + 1) ? (fast - slow + 1) : result
      }
      return result
  }
  
  // 验证
  let list = [0, 1, 2, 2, 1, 1, 3, 4, 2]
  console.log('至多包含两种元素的最长子数组长度：' + fn(list)) // 5

#### 最小覆盖子串

- [力扣76](https://leetcode.cn/problems/minimum-window-substring/description/)

  ```js
  // 思路
  // 类似力扣904用哈希表记录元素种类
  // 本题则是在此基础上增加了一个纬度 对种类进行计数比较
  // 因此循环判断条件第一层为对比元素种类数量是否相同
  // 然后判断种类数量是否符合 不符合则继续扩充滑动窗口
  // 直到符合条件 则从滑动窗口起始位置开始缩短
  // 直到种类或计数不符 继续从滑动窗口结尾处伸长
  // 直到原字符串寻找完毕 返回记录的最短子串
  
  function fn(source, target) {
      // 先处理目标字符串 生成哈希表 对字符进行统计
      let t_map = new Map()
      for (let val of target) {
          t_map.set(val, (t_map.get(val) || 0) + 1)
      }
      let slow = 0 // 滑动窗口起始位置
      let fast = 0 // 滑动窗口结束位置
      // 记录最小子数组
      // 其length为判断是否更新条件
      let result = '' // 初始值为空 因为没找到返回空字符串
      // 创建一个哈希表 用于记录当前滑动窗口对应字符的个数
      // 用作判断是否缩短滑动窗口的依据
      let s_map = new Map()
      while (fast < source.length) {
          // 一进循环先判断快指针所指向的值是否符合目标字符串
          if (t_map.has(source[fast])) {
              // 如果符合 则将其填入s_map
              s_map.set(source[fast], (s_map.get(source[fast]) || 0) + 1)
          }
          // 判断s_map和t_map长度
          while (s_map.size === t_map.size) {
              // 相同 说明t_map中的字符种类s_map都包含了
              // 则继续进行下一步 对比s_map和t_map字符计数大小
              let flag = true
              for (let [key, val] of t_map) {
                  if (s_map.get(key) < val) {
                      // 如果滑动窗口字符计数小 说明还不满足t_map要求
                      // 则继续让快指针往后遍历 伸长滑动窗口
                      // 直到找到符合t_map的滑动窗口 再循环缩减滑动窗口 以找到最短子串
                      flag = false
                      break
                  }
              }
              if (!flag) {
                  // 不符合 跳出循环继续伸长滑动窗口
                  break
              }
              // 执行到此处说明已经找到了包含target的子串(不一定是最短)
              // 判断是否是较短子串
              // 空字符串则赋初值 或 较长时更新记录
              if (result === '' || result.length > (fast - slow + 1)) {
                  // 注意 substring截取字符串是左闭右开 因此快指针索引要+1 才是slow到fast区间字符串
                  result = source.substring(slow, fast + 1)
              }
              // 判断当前慢指针所指向的值是否在s_map中
              if (s_map.has(source[slow])) {
                  // 存在则计数-1 因为接下来要缩短滑动窗口
                  s_map.set(source[slow], s_map.get(source[slow]) - 1)
              }
              // 接着缩短滑动窗口 等再次进入循环看是s_map否依然满足t_map
              slow++
          }
          fast++
      }
      return result
  }
  
  // 验证
  let list = 'ADOBECODEBANC'
  let t = 'ABC'
  console.log('最小子串为', fn(list, t)) // BANC

### 模拟行为

#### 螺旋矩阵II

- [力扣59](https://leetcode.cn/problems/spiral-matrix-ii/description/)

  ```js
  // 思路
  // 模拟转圈的一个过程 需要注意的点
  // 1、要记录起始位置 一是作为for循环变量 二是作为一圈转完回到起始位置时的for循环结束条件
  // 2、奇数矩阵有别于偶数 有中心点 while循环处理的只有边 中心点要特殊处理
  // 3、如果要以上一条边的末尾作为下一条边的起始位置 就要采用左闭右开
  // 4、注意左边是最后一条边 因此只能用右开区间 因为起始位置已经取过值了
  
  // 时间复杂度 O(n^2)
  // 空间复杂度 O(1)
  
  function fn(num) {
      // 创建num x num空矩阵
      // 注意map方法会跳过为空的元素 而不修改其值 所以要先填充值
      let result = new Array(num).fill(0).map(() => new Array(num).fill(0))
      // 记录起始位置
      let startRow = 0
      let startCol = 0
      // 记录最大圈数 作为循环结束条件
      // 如果是奇数 中心处单独处理 循环只处理中心点外的四条边
      let maxLoop = Math.floor(num / 2)
      let curLoop = 1 // 当前圈数
      let current = 1 // 当前要赋的值
      while (curLoop <= maxLoop) {
          // 记录当前圈 起始位置 作为边的起始位置或循环结束条件
          let row = startRow
          let col = startCol
          // 以左闭右开区间为例
          // 即当前边 只修改到末尾元素前
          // 末尾位置作为下一条边起始位置 当前边不作修改
          // 因为是从外圈向内收缩
          // 所以一条边的末尾会随着圈数向前推移
          // 因此当前边结束条件是 < num - curLoop
          for (col; col < num - curLoop; col++) {
              // 修改上边 result[当前行][动态列] = 当前值
              result[row][col] = current
              // 赋值完一个数字递增1
              current++
          }
          // 顺时针 接着修改右边
          for (row; row < num - curLoop; row++) {
              // 当前 col 为上边的末尾位置
              result[row][col] = current++
          }
          // 修改下边
          // 注意 因为是顺时针过来的 所以下边是从末尾向头部遍历
          // 这时就要以记录的起始位置为结束条件
          for (col; col > startCol; col--) {
              // 当前 row 是右边的末尾位置
              result[row][col] = current++
          }
          // 修改左边
          // 同下边 是从末尾向前遍历
          for (row; row > startRow; row--) {
              // 当前 col 是下边的起始位置
              result[row][col] = current++
          }
          // 循环结束圈数+1 直到中心点 外圈遍历完
          curLoop++
          // 移动起始点位置 往右下角移一位
          startRow++
          startCol++
      }
      // 循环结束 所有 边 已修改 但是奇数矩阵会有中心点 进行特殊处理
      if (num % 2) {
          // while循环结束时 startRow 和 startCol自增了1 所以已经是中心点
          result[startRow][startCol] = current
      }
      return result
  }
  
  // 验证
  console.log('5*5矩阵数组', fn(5))
  console.log('4*4矩阵数组', fn(4))

#### 螺旋矩阵

- [力扣54](https://leetcode.cn/problems/spiral-matrix/description/)

  ```js
  // 思路
  // 同力扣59不同的是 本题不是正方形 因此可能会存在没有完整圈而是一条边的情况
  // 本题的关键在于 以起始位置对角处为对照 若在对角位置左上方
  // 说明有下和左两条边
  // 外层大循环是取上和右两条边
  // 因此外层大循环条件为 起始位置行和列都小于等于对角位置行列即可
  
  // 时间复杂度：O(mn) mn表示行和列数
  // 空间复杂度：O(1)
  
  function fn(source) {
      let list = []
      let startRow = 0
      let startCol = 0
      // 因为矩阵是 m x n 不是n x n正方形矩阵
      // 所以中心处不是完整的一圈
      // 不能以圈数为缩进和循环终止条件
      // 因此设置条件为对角位置行和列总数
      let totalRow = source.length - 1
      let totalCol = source[0].length - 1
      // 循环结束条件 起始行和末尾行在同一行或小于末尾行
      // 且起始列和末尾列在同一列或小于末尾列
      while (startCol <= totalCol && startRow <= totalRow) {
          // 先从上边开始 从左到右
          // 左闭右开区间 取到末尾前一个元素
          for (let col = startCol; col < totalCol; col++) {
              list.push(source[startRow][col])
          }
          // 接着右边 从上到下
          // 注意从上边的末尾元素开始 且 取到右边的末尾元素
          // 因为不是正方形 所以不一定还有下一条边 右边要取完
          // 所以是<=
          for (let row = startRow; row <= totalRow; row++) {
              list.push(source[row][totalCol])
          }
          // 重点来了
          // startRow表示当前行 startCol表示当前列
          // totalRow表示最下面的边 totalCol表示最右边的列
          // 因此只有当前起始位置均小于对角行和列 才表示还有对角边
          if (startRow < totalRow && startCol < totalCol) {
              // 有对角边 先从下边开始 从右到左
              // 注意右边已经取到末尾元素 因此从右边的前一个元素开始
              for (let col = totalCol - 1; col >= startCol; col--) {
                  list.push(source[totalRow][col])
              }
              // 接着左边 从下到上
              // 注意下边已经取到末尾 因此从左边的上一行开始
              // 左边只能是右开区间
              for (let row = totalRow - 1; row > startRow; row--) {
                  list.push(source[row][startCol])
              }
          }
  
          // 循环结束 起始位置 对角位置向内缩进向内缩进
          startCol++
          startRow++
          totalCol--
          totalRow--
      }
      return list
  }
  
  // 验证
  let list = [
      [1, 2, 3, 4, 5],
      [12, 13, 14, 15, 6],
      [11, 10, 9, 8, 7]
  ]
  console.log('矩阵值', fn(list))

## 链表

- 在JS中链表节点就是一个类的实例，由两个属性组成，一个表示节点值，一个表示下一个节点内存地址值

  ```js
  class Node{
      constructor(value, nextObj){
          this.value = value
          // 每一个next指向下一个关联的对象地址
          this.next = nextObj
      }
  }
  ```

- 链表末尾节点的`next`为`null`

- 链表在内存中并不是连续地址

- 链表操作

  - 删除

    - 原理

      - 非头部节点：将要删除的节点的前一个节点的`next`指向当前节点的`next`，可以理解为绕过要删除的节点，在JS中没有被引用的对象内存就会被回收，也就删除了
      - 头部节点：将头部节点置为其`next`节点，再将其`next`置为`null`
        - 为了将删除头部节点和普通节点操作同化，可以设置==虚拟头部节点==，其`next`指向头部节点，这样删除头部节点操作就同普通节点相同了，只要将虚拟头部节点的`next`指向头部节点的`next`

    - 示例

      ```js
      function removeNode(head, target){
      	// 创建虚拟头部节点 其实就是局部变量 每次调用删除都创建一个临时的
          // 因为是临时的 随便传个值进去就行 所以传了0
          // 其次将真实头部节点head传入 作为虚拟头部节点的next值
          let virtualHead = new Node(0, head)
          // 删除操作要先找到目标 所以要用while循环判断 找到后才执行删除操作
          // 设一个动态值 表示当前进行到的节点
          let current = virtualHead // 初始从虚拟头开始
          // 链表末尾是null 就结束循环
          while(current.next){
              // 此示例是单链表 即只有指向下一个节点 没有前一个节点的引用
              // 因此要在前一个节点就判断其next是否是目标节点
              if(current.next.value === target){
                  // 找到目标 将当前节点的next指向目标节点的next
                  current.next = current.next.next
                  // 找到后 必须用continue跳过后面的移动current操作
                  // 因为判断条件是取当前节点的next
                  // 如果删除后 接着移动到下一个节点就会跳过下一个节点的判断
                  continue
              }
              current = current.next // 移动当前节点到下一个节点
          }
          // 删除操作结束 返回虚拟节点后的真实节点列表
          return virtualHead.next
      }
  
  - 添加
  
    - 原理
  
      - 非头部节点：将添加的节点链接到目标位置节点，然后将目标位置前的一个节点断开原链接，将其重新连到新节点
      - 头部节点：新节点链接到头节点，然后将新节点作为头节点
        - 创建虚拟头节点可以同化添加头节点和非头节点操作
  
    - 示例
  
      ```js
      function addNode(head, index, newNode){
          let virtualHead = new Node(-1, head)
          // 位置索引index就相当于离目标节点的步数
          // 因为添加节点要找到目标位置的前一个节点 所以从虚拟头节点开始
          // 这样到index计数结束 正好是目标位置前一个节点
          let target = virtualHead
          while(index--){
              target = target.next
          }
          // 添加操作
          // 注意顺序 如果先修改目标位置前一个节点next 会导致丢失目标位置节点
          newNode.next = target.next
          target.next = newNode
      }

#### 移除链表元素

- [力扣203](https://leetcode.cn/problems/remove-linked-list-elements/description/)

  ```js
  // 思路
  // 链表的删除 就是将要删除节点的前一个节点的next指向删除节点的后一个节点
  // 通过current = current.next来移动节点
  
  class Node {
      constructor(value, nextObj) {
          // JS中链表节点就是一个类的实例 由两个属性组成
          // 一个表示节点值 一个表示下一个节点内存地址值
          this.value = value
          this.next = nextObj
      }
  }
  
  function removeNode(head, target) {
      // 创建虚拟头部节点 其实就是局部变量 每次调用删除都创建一个临时的
      // 因为是临时的 随便传个值进去就行 所以传了0
      // 其次将真实头部节点head传入 作为虚拟头部节点的next值
      let virtualHead = new Node(0, head)
      // 删除操作要先找到目标 所以要用while循环判断 找到后才执行删除操作
      // 设一个动态值 表示当前进行到的节点
      let current = virtualHead // 初始从虚拟头开始
      // 链表末尾是null 就结束循环
      while (current.next) {
          // 此示例是单链表 即只有指向下一个节点 没有前一个节点的引用
          // 因此要在前一个节点就判断其next是否是目标节点
          if (current.next.value === target) {
              // 找到目标 将当前节点的next指向目标节点的next
              current.next = current.next.next
              // 找到后 必须用continue跳过后面的移动current操作
              // 因为判断条件是取当前节点的next
              // 如果删除后 接着移动到下一个节点就会跳过下一个节点的判断
              continue
          }
          current = current.next // 移动当前节点到下一个节点
      }
      // 删除操作结束 返回虚拟节点后的真实节点列表
      return virtualHead.next
  }

#### 设计链表

- [力扣707](https://leetcode.cn/problems/design-linked-list/description/)

  ```js
  // 思路
  // 本题要求实现链表的基本操作即增删查
  // 增加节点：分为头部前增加、尾部增加、链表中间增加
  // 删除节点：任意位置处删除节点
  // 要点：
  // 1、需要设计头节点属性和尾节点属性
  // 为的是方便首尾增加节点时不用再把链表遍历一遍增加时间复杂度
  // 2、对节点的增删 一定 要注意边界情况 及时更新头尾节点属性
  
  class Node {
      constructor(val, next) {
          this.val = val
          this.next = next
      }
  }
  class NodeList {
      constructor() {
          // 链表属性 不是通过实例化时传入赋值
          // 而是在调用方法时修改属性 所以无需赋值
          this.size = 0 // 链表长度
          this.head = null // 链表头节点
          this.last = null // 链表尾节点
      }
  
      // 获取index位置节点 index从0开始
      getNode(index) {
          // 首先进行非法值判断
          if (index < 0 || index > this.size - 1) {
              // index只能是[0, size-1]的值
              return -1
          }
          // 设置虚拟头节点
          const virtualHead = new Node(0, this.head)
          // 因为是获取第index节点
          // 考虑极限条件比如index为0 那么就要返回头节点
          // 因此current要从virtualHead.next开始
          let current = virtualHead.next
          // 可以将index理解为找到目标节点的步数
          // 因此是index-- 每离目标进一步索引-1
          while (index) {
              current = current.next
              index--
          }
          return current
      }
  
      // 在链表最前面插入 一个 节点
      addAtHead(val) {
          // 根据传入值生成节点
          // 因为是添加到头节点前 因此新节点的next就是之前的头节点
          const node = new Node(val, this.head)
          // 更新头节点
          this.head = node
          // 首次添加节点时 还没有尾节点
          if (!this.last) {
              // 只有一个节点 当前节点既是头节点又是尾节点
              this.last = node
          }
          // 记得添加完节点size属性要增加
          this.size++
      }
  
      // 在链表末尾添加 一个 节点
      addAtLast(val) {
          const node = new Node(val, null)
          // 这里要分两种情况
          if (this.last) {
              // 有尾节点 说明链表里有节点
              // 那么将新节点添加到尾节点的next
              this.last.next = node
          } else {
              // 还没有尾节点 说明没添加过节点
              // 因为空链表里添加节点 必然会调用addAtHead 或 addAtLast
              // 即不存在有节点 尾节点还为空的情况
              // 那么将新节点作为头、尾节点
              this.head = node
          }
          // 更新尾节点
          this.last = node
          this.size++
      }
  
      // 在链表第index位置前插入节点
      addAtIndex(index, val) {
          // 首先进行边界判断
          // 1、当前链表没有节点 或 插入位置<=0 视作头部插入节点
          if (!this.size || index <= 0) {
              this.addAtHead(val)
              return
          }
          // 2、index大于size 说明在末尾插入节点 直接调用addAtLast
          if (index > this.size - 1) {
              this.addAtLast(val)
              return
          }
          // 这样就避免了空链表中间位置插入节点 导致的空指针问题
  
          // const node = new Node(val, null)
          // const virtualHead = new Node(0, this.head)
          // 首先要找到index位置前一个节点
          // 因为是修改其前一个节点的next来插入节点
          // 注意 这里是从虚拟头节点开始遍历查找
          // let current = virtualHead
          // while (index--) {
          //     current = current.next
          // }
          // 找到了目标位置的前一个节点
          // 注意 加入节点时断开链接和建立新连接的顺序
          // 如果先将virtualHead.next链接到node
          // 那么就会失去原本的virtualHead.next链接
          // 导致node.next不知道链到谁身上
          // node.next = current.next
          // current.next = node
  
          // 精简版
          let current = this.getNode(index - 1)
          const node = new Node(val, current.next)
          current.next = node
          this.size++
      }
  
      // 删除index位置节点
      deleteAtIndex(index) {
          // 首先进行边界判断
          // 1、无效index
          if (index < 0 || index > this.size - 1) {
              return
          }
          // 2、删除的是头节点
          if (index === 0) {
              // 则将当前头节点改为其下一个节点
              // 如果只有一个节点则是null
              this.head = this.head.next
              // 如果只有一个节点 删除后处理尾节点
              if (index === this.size - 1) {
                  this.last = null
              }
              this.size--
              return
          }
          // 首先找到目标位置前一个节点
          let current = this.getNode(index - 1)
          // 删除节点
          current.next = current.next.next
          // 3、如果删除的是尾节点
          if (index === this.size - 1) {
              // 则将目标位置前一个节点更新为尾节点
              this.last = current
          }
          this.size--
      }
  }

### 双指针

#### 反转链表

- [力扣206](https://leetcode.cn/problems/reverse-linked-list/description/)

  ```js
  // 思路
  // 利用单链表特性
  // 1、单链表每个节点保存了下一个节点地址 所以只能从头开始查
  // 2、用双指针将前后相邻的两个节点重新绑定next关系
  // 3、为了移动指针 解绑next前 要存临时变量
  
  function fn(head) {
      // 设置双指针 用于修改两指针所指向的两个节点关联关系
      let fast = head // 快指针从头节点开始
      let slow = null // 慢指针从头节点前的null开始
      // 首先要设置一个临时变量 保存fast节点的下一个节点
      // 否则反转完fast和slow节点 fast会丢失移动位置
      let temp = fast.next
      while (fast) {
          // 反转
          fast.next = slow
          // 然后先移动slow到fast位置
          slow = fast
          // 再移动fast到temp
          fast = temp
          // 最后更新temp
          temp = fast.next
      }
      // 循环结束 此时fast为null(原链表尾节点next) slow为新头节点
      // 因此要返回slow
      return slow
  }
  ```

#### 两两交换链表中的节点

- [力扣24](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

  ```js
  // 思路
  // 首先要在纸上模拟两两交换过程
  // 要点
  // 1、每次循环存储 被断开 的节点
  // 2、两两交换 所以每次循环要前进两步
  
  class Node {
      constructor(val, next) {
          this.val = val
          this.next = next
      }
  }
  
  function fn(head) {
      // 创建虚拟头节点 先让其指向头节点
      const virtualHead = new Node(-1, head)
      // 创建控制交换的指针 先将虚拟头节点作为起始位置
      let current = virtualHead
      // 因为是两两间进行交换 所以指针一次前进两步
      // 因此循环条件为 下一步 和 下下一步 不为空
      while (current.next && current.next.next) {
          // 有个先决条件
          // 被 断开的节点要先保存到临时变量
          // 否则被断节点的前一个节点改了next指向后会丢失被断节点
          // 因此存储本次循环中会 被 断开的节点
          // 首先是 指针 的下一个节点会 被 断开 因为要指向下下一个节点
          let temp1 = current.next
          // 其次是 指针 的下下一个节点会断开其身后的节点
          let temp2 = current.next.next.next
  
          // 开始交换节点位置
          // 首先是 指针 指向下下一个节点
          current.next = temp1.next
          // 然后交换前后相邻两节点指向
          temp1.next.next = temp1
          // 其次将交换后的末节点temp1的next指向下一次循环要交换的起始节点
          temp1.next = temp2
          // 最后指针移动 两步
          current = current.next.next
      }
      // 返回结果 新链表的头节点
      return virtualHead.next
  }

#### 删除链表的倒数第N个节点

- [力扣19](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

  ```js
  // 思路
  // 倒数第n个 等于 总长 - 目标节点索引(从0开始)
  // 因此让快指针先移动n步 再让快慢指针同时移动
  // 最后慢指针的位置就是 总长 - n 等于 目标节点位置
  // 要注意的是节点的删除 需取到目标节点前一个节点
  // 因此快指针要移动 n+1 步
  
  class Node {
      constructor(val, next) {
          this.val = val
          this.next = next
      }
  }
  function fn(head, n) {
      // 为了处理删除头节点情况 创建虚拟头节点
      const virtualHead = new Node(0, head)
      // 设置快慢指针 从虚拟头节点开始
      let fast = virtualHead
      let slow = virtualHead
      // 先将快指针移动 n+1步
      n = n + 1
      // 为防止n超过总长 出现空指针错误 限制fast不能为空
      while (n-- && fast) {
          fast = fast.next
      }
      // 开始移动快慢指针
      while (fast) {
          fast = fast.next
          slow = slow.next
      }
      // slow在删除节点的前一个节点
      // 执行删除操作
      slow.next = slow.next.next
      return head
  }

#### 链表相交

- [力扣160](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

  ```js
  // 思路
  // 还是经典双指针 各自遍历一个链表
  // 需要注意的是 链表长度不同 为了找到交汇处
  // 需要先将尾部对齐 即长的链表它的指针先走 长度差值的步数
  // 然后再同步移动两链表上的指针 找到完全相等的节点
  
  class Node {
      constructor(val, next) {
          this.val = val
          this.next = next
      }
  }
  function fn(head1, head2) {
      // 先求两个链表长度
      let len1 = 0
      let current = head1
      while (current) {
          current = current.next
          len1++
      }
      let len2 = 0
      current = head2
      while (current) {
          current = current.next
          len2++
      }
      // 然后比较两个链表长度
      let offset // 长度差
      let long // 长链表指针
      let short // 短链表指针
      if (len1 > len2) {
          offset = len1 - len2
          long = head1
          short = head2
      } else {
          offset = len2 - len1
          long = head2
          short = head1
      }
      // 长链表指针先移动offset量
      while (offset--) {
          long = long.next
      }
      // 找到相同节点就停止遍历
      while(long !== short){
          long = long.next
          short = short.next
      }
      // 遍历结束 如果没找到long和short就是null 找到了就返回long和short其一
      return long
  }
  ```

#### 环形链表II

- [力扣142](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

  ```js
  // 哈希表思路
  // 遍历链表 在其过程中遇到不存在于哈希表中的元素 就将其添加进去
  // 因为是每走一步就判断哈希表中是否存在对应的元素
  // 所以回到环入口第一时间就会发现入口位置
  
  function fn(head) {
      let map = new Map()
      let current = head
      // 正常遍历链表循环
      while (current) {
          // 判断哈希表中是否有对应元素
          if (map.has(current)) {
              // 找到入口了则直接返回结果
              return current
          }
          // 说明没找到相同元素 将其添加到哈希表中
          map.set(current, 1)
          // 继续向后遍历
          current = current.next
      }
      // while循环结束都没返回结果 说明没有形成环 返回null
      return null
  }
  
  // 双指针思路
  // 设置快慢指针 同时从头节点出发 快指针每次移动2步 慢指针只走1步
  // 那么快指针必然先进入环 等慢指针进入环 快指针可能已经跑了N圈
  // 且快指针是以1的速度 逼近 慢指针 所以必然慢指针在环中跑不完一圈
  // 就被追上
  // 这是需要一点数学推导 才能看出相遇点到环入口的距离与头节点到环入口距离的关系
  // 设快指针为A 慢指针为B
  // 已知：A前进速度为B的两倍 且 B每次只走一步
  // 设：
  // 起始点到环的入口位置距离为r
  // 从环入口到AB相遇位置距离为k
  // AB相遇位置到环入口剩余距离h
  // AB相遇时 A跑过的圈数n
  // 那么
  // A走过的距离为：r + k + n * (k + h)
  // B走过的距离为：r + k
  // 建立等式
  // 因为A的速度是B的两倍 所以路程也是两倍
  // 2 * (r + k) = r + k + n * (k + h)
  // 简化等式为
  // r = n * (k + h) - k
  // 再简化
  // r = (n - 1) * (k + h) + h
  // n大于等于1 即A最少也得跑了1圈后才会与B相遇
  // 当A跑过的圈数为1时
  // r = h 即相遇点到环入口的剩余距离 与 起始点到环入口的距离相等
  // 那么设另一个指针C从起始点开始走
  // B从相遇点向环入口方向走 两者同步移动 每次移动一步
  // 从等式 r = h 可以看出 C和B必定会在环入口相遇
  // 即使A跑过的圈数不为1 k + h也是整圈环的长度 不影响C和B最终在环入口处相遇
  
  function fn2(head) {
      // 设置快慢指针 都从头节点起始
      let fast = head
      let slow = head
      // 开始循环遍历
      // 快指针走得快 所以要判断快指针是否走到头
      // 如果走到头说明没有环
      while (fast && fast.next) {
          // 先移动 再判断是否相遇
          fast = fast.next.next
          slow = slow.next
          // 因为是从相遇点开始遍历 因此这里用if
          if(fast === slow){
              // 相遇了 设置从起始点开始的指针C
              let result = head
              // 开始循环遍历 直到C和慢指针相遇
              while(result !== slow){
                  result = result.next
                  slow = slow.next
              }
              return result
          }
      }
      return null
  }

## 哈希表

- 数组、`Set`、`Map`都是哈希结构

### 数组

- 用数组的前提是限制了范围，如`a~z`范围，且全是小写，那数组长度就是固定的26
  - 对于没有限制范围大小de ，就无法使用数组来做哈希表
  - 且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费

#### 有效的字母异位词(全排列)

- [力扣242](https://leetcode.cn/problems/valid-anagram/description/)

  ```js
  // 思路
  // 可以用哈希表set map但是set()方法时间复杂度较高
  // 本题数据构成的哈希值较小 用数组实现运行效率最高
  // map和数组思路相同 都是先遍历一个字符串进行计数
  // 然后在另一个字符串中自减 当有计数不为0
  // 说明字符串不符
  
  // map实现方式
  function fn(str1, str2) {
      // 首先过滤掉长度不相同的
      if (str1.length !== str2.length) {
          return false
      }
      let map = new Map()
      // 填入map并计数
      for (let val of str1) {
          map.set(val, (map.get(val) || 0) + 1)
      }
      // 遍历另一个字符串
      for (let val of str2) {
          // 如果str2中有字符不存在于map
          // 或对应字符已经为0 计数不能-1
          if (!map.get(val)) {
              // 说明不匹配
              return false
          }
          // 因为已经限制了字符长度相同
          // 所以有的字符计数减不到0也没事
          // 说明必然有不存在于str1中的字符
          // 就会被if (!map.get(val))条件拦截
          map.set(val, map.get(val) - 1)
      }
      // 进行到这步 说明对应字符计数都已归零 两字符串匹配
      return true
  }
  
  // 验证
  console.log('用map比较 aacd 和 acad', fn('aacd', 'acad')) // true
  console.log('用map比较 aaa 和 aad', fn('aaa', 'aad')) // false
  
  // 数组实现方式
  function fn2(str1, str2) {
      if (str1.length !== str2.length) {
          return false
      }
      // 注意本题全是小写字符 所以Unicode码是连续的 从a到z总共26位
      // 先创建长度为26的数组 并赋初值0
      let array = new Array(26).fill(0)
      // 以a为参照 记录a的Unicode码
      let base = 'a'.charCodeAt()
      // 遍历str1 并计数
      for (let i = 0; i < str1.length; i++) {
          // str1[i].charCodeAt() - base表示0~25的数组索引
          array[str1[i].charCodeAt() - base]++
      }
      // 遍历另一个字符串
      for (let val of str2) {
          // 如果str2中字符对应的数组索引 计数为0
          // 说明要么是本存在于str1
          // 要么对应字符数少于str1
          if (!array[val.charCodeAt() - base]) {
              // 不匹配
              return false
          }
          // 对应字符的计数大于0 计数-1
          array[val.charCodeAt() - base]--
      }
      return true
  }
  
  // 验证
  console.log('用数组比较 aacd 和 acad', fn2('aacd', 'acad')) // true
  console.log('用数组比较 aaa 和 aad', fn2('aaa', 'aad')) // false

#### 赎金信

- [力扣383](https://leetcode.cn/problems/ransom-note/description/)

  ````js
  // 思路
  // 同力扣242 只不过本题不要求两个字符串元素计数完全相同
  // 而是一个字符串是另一个字符串的子集就行
  
  // 以数组方式为例
  function fn(source, target) {
      // 因为是小写字符 即a~z 在Unicode码上是连续的
      // 因此创建长度26的数组 并填充0
      let array = new Array(26).fill(0)
      // 以a为参照 记录Unicode码
      let base = 'a'.charCodeAt()
      // 遍历source 统计字符
      for (let val of source) {
          // a~z 以a为参照 对应数组0~25索引
          array[val.charCodeAt() - base]++
      }
      // 遍历target
      for (let val of target) {
          // 当前字符在source统计数组中为0
          // 说明不存在于source中
          // 或source中对应字符用完了
          if (!array[val.charCodeAt() - base]) {
              return false
          }
          array[val.charCodeAt() - base]--
      }
      return true
  }
  
  // 验证
  console.log('从ab中取aa', fn('ab', 'aa')) // false
  console.log('从ab中取aa', fn('aab', 'aa')) // true

#### 字母异位词分组

- [力扣49](https://leetcode.cn/problems/group-anagrams/description/)

  ```js
  // 排序方法思路
  // 首先明确一点 符合字母异位的字符串 排序后一定是相等的
  // 利用这点 在遍历字符串数组时 将每个字符串转换成数组
  // 然后排序 为了对比再转换成字符串
  // 然后在map中找是否有这个字符串 没有则创建一个数组
  // 以数组转的字符串作为key 创建的数组作为value 填入map中
  // 后续遍历时 遇到排序后的字符串在map中出现 则取其value将对应字符串填入value中
  
  function fn(list) {
      // 先创建哈希表
      let map = new Map()
      for (let val of list) {
          // 将当前字符串转换成数组
          let arr = Array.from(val)
          // 根据Unicode对字符排序
          arr.sort()
          // 将排序后的数组转换成字符串 如 "a,b,c"
          let str = arr.toString()
          // 判断哈希表中是否存在
          // 存在则将原数组取出
          // 不存在则创建新数组
          let list = map.get(str) ? map.get(str) : new Array()
          // 将当前字符串填入该数组
          list.push(val)
          // 排序后的字符串作为key list作为value
          map.set(str, list)
      }
      // 返回一个由map的value组成的新数组
      return Array.from(map.values())
  }
  
  // 验证
  let list = ["eat", "tea", "tan", "ate", "nat", "bat"]
  console.log('排序法', fn(list)) // [["eat","tea","ate"],["tan","nat"],["bat"]]
  
  // 计数思路
  // 同排序方法 只不过是将数组中每一项的字符计数转换成字符串存在对象中作为唯一key
  
  function fn2(list) {
      // 先创建表 不止哈希表 用对象也可
      let map = {}
      for (let val of list) {
          // 因为是全小写字符 即a~z共26个 在Unicode上是连续的 因此创建长度26的初始数组
          let arr = new Array(26).fill(0)
          // 以a为参照 映射到数组中的索引
          let base = 'a'.charCodeAt()
          // 对当前字符串中的字符计数
          for (let str of val) {
              arr[str.charCodeAt() - base]++
          }
          // 转换成字符串
          let key = arr.toString()
          // 判断是否已经存在同样的key
          // 存在则取key对应的value填入当前字符串
          // 不存在则创建新value
          // map[key] ? map[key].push(val) : map[key] = [val]
          let list = map[key] ? map[key] : new Array()
          list.push(val)
          map[key] = list
      }
      return Array.from(Object.values(map))
  }
  
  // 验证
  let list2 = ["eat", "tea", "tan", "ate", "nat", "bat"]
  console.log('计数法', fn2(list2)) // [["eat","tea","ate"],["tan","nat"],["bat"]]

#### 找到字符串中所有字母异位词

- [力扣438](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

  ```js
  // 思路
  // 用滑动窗口的思想 保持窗口长度等于目标字符串长度
  // 丢到判断异位词的方法中进行判断 如果找到了就填入结果数组
  
  function fn(source, target) {
      let result = []
      // 特殊情况 source比target短 那必不可能有异位词
      if (source.length < target.length) {
          return result
      }
      // 识别是否是异位词
      function isAccord(str1, str2) {
          if (str1.length !== str2.length) {
              return false
          }
          let arr = new Array(26).fill(0)
          let base = 'a'.charCodeAt()
          for (let val of str1) {
              arr[val.charCodeAt() - base]++
          }
          for (let val of str2) {
              if (!arr[val.charCodeAt() - base]) {
                  return false
              }
              arr[val.charCodeAt() - base]--
          }
          return true
      }
  
      // 先得到目标字符串长度 因为找异位词必然长度要相同
      let len = target.length
      // 设置快慢指针 形成滑动窗口
      let slow = 0
      let fast = len - 1
      for (fast; fast < source.length; fast++) {
          // 先将滑动窗口内的字符拼成字符串
          let str = []
          for (let i = slow; i <= fast; i++) {
              str.push(source[i])
          }
          str = str.join('')
          // 如果符合 将当前slow索引填入结果数组
          if (isAccord(str, target)) {
              result.push(slow)
          }
          slow++
      }
      return result
  }
  
  // 验证
  let source = "cbaebabacd"
  let target = "abc"
  console.log(fn(source, target)) // [0, 6]
  
  // 简化思路
  // 让滑动窗口内的字符计数是加过的
  // 从滑动窗口起始位置前一个一个清除计数
  // 从而达到只有滑动窗口内的字符有计数 外部没有计数
  
  function fn2(source, target) {
      let result = []
      if (source.length < target.length) {
          return result
      }
      let source_map = new Array(26).fill(0)
      let target_map = new Array(26).fill(0)
      let base = 'a'.charCodeAt()
      // 因为后续滑动窗口遍历时 窗口长度固定 且从source第二个字符开始遍历
      // 所以需要先对起始点进行特殊处理
      // 先根据目标字符串长度对source和target进行计数
      // 因为异位词必然长度相同
      for (let i = 0; i < target.length; i++) {
          source_map[source[i].charCodeAt() - base]++
          target_map[target[i].charCodeAt() - base]++
      }
      // 然后判断两者头部是否符合异位词
      if (source_map.toString() === target_map.toString()) {
          // 头部符合 则填入结果数组
          result.push(0)
      }
      // 滑动窗口开始移动
      let slow = 0
      // 注意 fast初始值是目标字符串长度
      // 因为要保持与target长度相同的滑动窗口
      // 而这个窗口起始位置是 slow后 结束位置是 fast
      // 即是从source第二个位置开始才是滑动窗口
      // 这样设置的原因是要从slow处一个一个清除计数
      // 保持仅有滑动窗口内的计数存在
      for (let fast = target.length; fast < source.length; fast++) {
          // 清除slow位置处的计数
          source_map[source[slow].charCodeAt() - base]--
          // 对当前fast位置 也就是滑动窗口末尾位置计数
          source_map[source[fast].charCodeAt() - base]++
          // 判断当前滑动窗口是否符合异位词
          if (source_map.toString() === target_map.toString()) {
              // 注意！slow是清除计数位置 slow后一位才是滑动窗口起始位置
              result.push(slow + 1)
          }
          slow++
      }
      return result
  }
  
  // 验证
  let source2 = "cbaebabacd"
  let target2 = "abc"
  console.log('简化版', fn2(source2, target2)) // [0, 6]

### Set、Map

#### 两个数组的交集

- [力扣349](https://leetcode.cn/problems/intersection-of-two-arrays/description/)

  ```js
  // 思路
  // 求交集本质是遍历一个数组 取每个值到另一个数组中找是否存在
  // 所以最主要的是如何去除重复的值 所以用Set或Map
  
  function fn(list1, list2) {
      // 根据数组大小交换操作的数组
      if (list1.length < list2.length) {
          let t = list1
          list1 = list2
          list2 = t
      }
      // 用哈希表存结果 利用set可以去重的特性
      let result = new Set()
      // 用长的数组list1构造哈希表
      let list1Set = new Set(list1)
      for (let val of list2) {
          if (list1Set.has(val)) {
              result.add(val)
          }
      }
      return Array.from(result)
  }
  
  // 简化版
  function fn2(list1, list2) {
      // 遍历list1 在list2中找有没有相同的值
      // 初筛的交集会有重复值 再用Set去重
      return Array.from(new Set(list1.filter(item => list2.includes(item))))
  }
  
  // 验证
  let nums1 = [4, 9, 5]
  let nums2 = [9, 4, 9, 8, 4]
  console.log('fn结果：' + fn(nums1, nums2))
  console.log('fn2结果：' + fn(nums1, nums2))

#### 两个数组的交集 II

- [力扣350](https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/)

  ```js
  // 哈希表思路
  // 遍历较短的数组 用哈希表进行计数
  // 再遍历较长的数组 将其每个值放到哈希表中的找
  // 找到对应元素 则将其添加到结果数组 并将哈希表中计数-1
  // 如果哈希表中计数已经为0 则将其从哈希表中剔除
  // 这样就可以实现取较短数组交集
  
  
  // 双指针思路
  // 先排序 然后设置两个指针分别遍历两个数组
  // 哪边小就移动哪边指针 直到找到相同元素
  // 然后同时移动两边指针 交集数组达到最短
  
  function fn(list1, list2) {
      // 首先对两个数组排序
      list1 = list1.sort()
      list2 = list2.sort()
      // 设两个指针 分别遍历两个数组
      let l1 = 0
      let l2 = 0
      let result = []
      // 题目要求取交集次数最少的作为结果 因此当较短数组遍历完就停止
      while (l1 < list1.length && l2 < list2.length) {
          switch (true) {
              // 因为是排过序的 哪一边小则移动那一边
              // 直到找到相同的
              case list1[l1] < list2[l2]:
                  l1++
                  break
              case list1[l1] > list2[l2]:
                  l2++
                  break
              case list1[l1] === list2[l2]:
                  // 说明找到了 将其添加到结果中
                  // 并同时移动两边指针
                  result.push(list1[l1])
                  l1++
                  l2++
                  break
          }
      }
      return result
  }
  
  // 验证
  let nums1 = [4, 9, 5]
  let nums2 = [9, 4, 9, 8, 4]
  console.log('排序后求交集' + fn(nums1, nums2)) // [4, 9]

#### 快乐数

- [力扣202](https://leetcode.cn/problems/happy-number/description/)

  ```js
  // 思路
  // 求和可以通过取余 以及除以10来从各位一级一级取值累计平方和
  // 将求平方和结果存到哈希表中 如果出现重复值说明进入无限循环
  // 说明此时要么是1(快乐数) 要么不符合快乐数
  
  function fn(num) {
      // 求和方法
      function getSum(n) {
          let sum = 0
          // 思路就是用取余操作取个位数计算
          // 然后每次循环除以10舍弃个位
          while (n) {
              sum += (n % 10) ** 2
              n = Math.floor(n / 10)
          }
          return sum
      }
  
      // 设置哈希表 记录每次平方和结果
      let map = new Set()
      // 循环条件是 数字没有变为1 且 哈希表中没有重复的结果
      // 哈希表中有重复的平方和结果 说明无限循环了
      while (num !== 1 && !map.has(num)) {
          map.add(num)
          num = getSum(num)
      }
      // 此时循环结束 有可能num不为1 说明无限循环 且不是快乐数
      // 也可能num为1 说明符合条件
      return num === 1
  }
  
  // 验证
  console.log('19是快乐数吗？' + fn(19)) // true

### 数字之和

#### 两数之和

- [力扣1](https://leetcode.cn/problems/two-sum/description/)

  ```js
  // 思路
  // 使用哈希表存遍历过的元素 每遍历到一个元素 求它的另一半值
  // 再到遍历过的表中去找 找到就直接返回结果
  // 这样就只用遍历一遍数组
  
  function fn(source, target) {
      // 设置哈希表 记录 遍历过 的元素
      // 因为要存元素及元素对应的下标 组成key value的形式
      // 而Set只能存key 数组做哈希表范围太大不适合 所以用Map 
      let map = new Map()
      for (let i = 0; i < source.length; i++) {
          // 本题是找到 两个值 和为target
          // 根据source中当前值 求另一个值大小
          let num = target - source[i]
          // 到哈希表中找 是否存在
          if (map.has(num)) {
              // 找到 说明已经遍历过
              return [map.get(num), i]
          }
          // 没找到 则将当前值存到哈希表
          map.set(source[i], i)
      }
      // 循环结束 没找到符合条件的值
      return []
  }
  
  // 验证
  let nums = [2, 11, 15, 7]
  let target = 9
  console.log('和为9的两值索引为：' + fn(nums, target)) // [0, 3]
  ```

#### 四数相加II

- [力扣454](https://leetcode.cn/problems/4sum-ii/description/)

  ```js
  // 思路
  // 四数之和可以拆成 两个两数之和
  // 先将前两个数组中所有可能的两数和放在哈希表中做一个统计
  // 在后两个数组两层循环求和时 用两数之和的思想 求另一半的值
  // 到哈希表中去找 找到则累加其统计值
  // 统计值表示有多少种可能合成另一半的值
  
  function fn(A, B, C, D, target) {
      // 设置哈希表 统计两数和有多少种可能
      let map = new Map()
      // 先统计前两个数组
      for (let a of A) {
          for (let b of B) {
              let n = a + b
              map.set(n, (map.get(n) || 0) + 1)
          }
      }
      // 记录有多少种可能
      let count = 0
      // 再到另外两个数组中 求另一半的和
      for (let c of C) {
          for (let d of D) {
              let n = c + d
              let n2 = target - n
              if (map.has(n2)) {
                  // 另一半的值 有多少种组合 就进行累加
                  count += map.get(n2)
              }
          }
      }
      return count
  }
  
  // 验证
  let A = [1, 2]
  let B = [-2, -1]
  let C = [-1, 2]
  let D = [0, 2]
  let target = 0
  console.log('四数之和得到0有 ' + fn(A, B, C, D, target) + ' 种可能') // 2

#### 三数之和

- [力扣15](https://leetcode.cn/problems/3sum/)

  ```js
  // 双指针思路
  // 关键点1 数组先进行排序
  // 将三数之和拆成 双数和 与 单数
  // 设两层循环 第一层为单数值 第二层为双数和
  // 题目要求不能有重复的结果 因此要对 单数 和 双数 去重
  // 第一层每次循环固定单数值
  // 关键点2 单数值去重 因为排过序 所以相同值是挨着的
  // 数组中只取第一个不同值
  // 又因数组排过序 应用二分法思想 第二层循环 在左右两端设置指针
  // 双数和与单数之和小于目标值 则移动左指针放大
  // 大于目标值 则移动右指针缩小
  // 关键点3 双数去重 思路还是只取第一个不同的值
  
  function fn(nums, target) {
      // 关键点1 先对数组排序
      nums.sort()
      let result = []
  
      for (let c = 0; c < nums.length; c++) {
          let cNum = nums[c]
          // 每次循环先判断当前数是否大于目标值
          if (cNum > target) {
              // 排过序的数组 如果当前值大于目标值
              // 后续双指针的值只会大于目标值
              // 不可能得到三数和等于目标值
              // 注：只适用于target为正数 负数是越加越小的
              return result
          }
          // 关键点2 已经取过的值就要跳过
          // 但此处不能向后比较 因为向后比较是三元组内的数去重
          // 比如cNum = -3 左指针 = -3 右指针 = 6
          // 三元组允许[-3, -3. 6]作为结果值 但不允许有多个相同结果值
          // 如果nums[c] == nums[c + 1]就跳过 那么[-3, -3. 6]的结果值就会被跳过
          // 因此要向前比较
          if (c > 0 && nums[c] === nums[c - 1]) {
              // 如果当前数与前一个数相同 则跳过当前循环
              continue
          }
          // 设置左右指针 分别置于数组前后位置
          let a = c + 1 // 从c后一位开始向后遍历
          let b = nums.length - 1 // 从数组末尾向前遍历
          // 注意 a == b 不能进循环 因为是三数之和 a == b说明左右指针到一个位置
          while (a < b) {
              let aNum = nums[a]
              let bNum = nums[b]
              let sum = cNum + aNum + bNum
              if (sum < target) {
                  // 如果三数和小于目标值 说明在第一层循环中 要调大左边界的值
                  a++
              } else if (sum > target) {
                  // 如果大于目标值 说明要调小右边界的值
                  b--
              } else {
                  // 关键点3 对a和b的值进行去重
  
                  // 方式1 向内比较
                  // 找到结果值了 
                  result.push([cNum, aNum, bNum])
                  while (nums[a] === nums[a + 1]) {
                      // 循环找到最后一个相同值的位置 后面还会a++ 就会找到不同值
                      a++
                  }
                  while (nums[b] === nums[b - 1]) {
                      // 右指针已经是数组末尾了 就要向前找 后面还有b--
                      b--
                  }
                  // 找到结果值后 因为第二层循环中c是固定值
                  // 因此要找不同三元组就必须同时移动左右指针
                  a++
                  b--
  
                  // 方式2 向外比较
                  // if (a > c + 1) {
                  //     // a b循环找到第一个不同的值
                  //     while (nums[a] === nums[a - 1]) {
                  //         a++
                  //     }
                  //     while (nums[b] === nums[b + 1]) {
                  //         b--
                  //     }
                  //     aNum = nums[a]
                  //     bNum = nums[b]
                  //     sum = cNum + aNum + bNum
                  //     if (sum < target) {
                  //         a++
                  //     } else if (sum > target) {
                  //         b--
                  //     } else {
                  //         result.push([cNum, aNum, bNum])
                  //         a++
                  //         b--
                  //     }
                  // } else {
                  //     // a == c + 1
                  //     // 因为左指针刚开始是在c后一位 所以要特殊处理
                  //     result.push([cNum, aNum, bNum])
                  //     a++
                  //     b--
                  // }
  
                  // 对比方式1 2 可以看出 while (a < b)循环中
                  // 最好把循环遍历找到的第一个不同的值留给下一次while (a < b)循环去处理
                  // 当前while (a < b)循环只找到不同值的上一位即可 不然会多很多冗余代码
                  // 这也是为什么nums[c] === nums[c - 1]和上一位数比较 来去重
                  // 而nums[a] === nums[a + 1]是向自身下一位数比较 来去重
              }
          }
      }
  
      return result
  }
  
  // 验证
  let nums = [-1, 0, 1, 2, -1, -4]
  let target = 0
  console.log('三数之和有多少种结果？', fn(nums, target)) // [[-1,-1,2],[-1,0,1]]
  nums = [0,1,1]
  console.log('三数之和有多少种结果？', fn(nums, target)) // []
  nums = [0,0,0]
  console.log('三数之和有多少种结果？', fn(nums, target)) // [[0,0,0]]

#### 四数之和

- [力扣18](https://leetcode.cn/problems/4sum/description/)

  ```js
  // 思路
  // 四数之和 同 三数之和思路 将其拆成 单数 + 单数 + 双数
  // 只是在三数之和的基础上加了层循环
  // 三数 四数 五数之和都是同理 将暴力解法的时间复杂度降低一个量级
  // 如三数之和是将n^3的复杂度降低为n^2 两数之和将n^2降低为n
  // 本题与三数之和不同点在于 三数之和target为正数
  // 而本题四数之和可以是任意值 而负数是越加越小的
  // 所以不能用 nums[i] > target来剪枝
  // 而得用 nums[i] > target && nums[i] > 0来剪枝
  // 撇去正数且大于target的 因为是升序数组
  // 比target大且为正数 后续数相加必定比target大 不再循环遍历
  
  function fn(list, target) {
      list.sort()
      let result = []
  
      for (let a = 0; a < list.length; a++) {
          // 单数进行剪枝操作
          // 当前值大于目标值 后续值之和也会大于目标值
          if (list[a] > target && list[a] >= 0) {
              break
          }
          // 对排序数组中的数进行去重
          if (a > 0 && list[a] === list[a - 1]) {
              continue
          }
          // 注意 是从第一层单数的后一位开始遍历
          for (let b = a + 1; b < list.length; b++) {
              // 剪枝
              // 注意 本题所求为和 所以以和大于目标值进行剪枝
              // 因为本题target为任意值 所以不能单以当前单数大于目标值进行剪枝
              // 如target = -10 a = -10 b = -3 b虽然大于target 但是a+b其实是小于目标值的
              if (list[b] + list[a] > target && list[b] + list[a] >= 0) {
                  break
              }
              // 去重
              // 注意 如果是刚开始循环 前一位是a不进行去重判断
              // b > a + 1很重要 不然会导致如[2,2,2,2] target = 8无法得到结果
              if (b > a + 1 && list[b] === list[b - 1]) {
                  continue
              }
  
              // 双数
              let c = b + 1 // 左指针 以第二层循环后一位开始
              let d = list.length - 1 // 右指针 数组末尾开始
              while (c < d) {
                  let sum = list[a] + list[b] + list[c] + list[d]
                  if (sum < target) {
                      // 和小于目标值 增大左指针
                      c++
                  } else if (sum > target) {
                      // 和大于目标值 缩小右指针
                      d--
                  } else {
                      // 找到了 先将结果填入数组
                      result.push([list[a], list[b], list[c], list[d]])
                      // 再进行双数去重
                      while (list[c] === list[c + 1]) {
                          // 左指针与后一位相等 则往后走一格
                          c++
                      }
                      while (list[d] === list[d - 1]) {
                          // 右指针与前一位相等 则往前走一格
                          d--
                      }
                      // 找到目标值 向内收缩左右指针
                      c++
                      d--
                  }
              }
          }
      }
  
      return result
  }
  
  // 验证
  let nums = [1, 0, -1, 0, -2, 2]
  let target = 0
  console.log('四数之和有多少种结果？', fn(nums, target)) // [[-1, -2, 1, 2], [-1, 0, 0, 1], [-2, 0, 0, 2]]
  nums = [2, 2, 2, 2, 2]
  target = 8
  console.log('四数之和有多少种结果？', fn(nums, target)) // [[2, 2, 2, 2]]

## 字符串

### 反转字符串

#### 反转字符串

- [力扣344](https://leetcode.cn/problems/reverse-string/description/)

  ```js
  // 思路
  // 设置双指针在字符串首尾 交换首位位置元素
  // 然后向内收缩
  
  function fn(list) {
      let slow = 0
      let fast = list.length - 1
      while (slow < fast) {
          // 小技巧 解构赋值 可以实现交换 而无需设置临时变量
          [list[fast], list[slow]] = [list[slow], list[fast]]
          slow++
          fast--
      }
  }
  
  // 验证
  let str = ["h","e","l","l","o"]
  fn(str)
  console.log('反转字符串结果：' + str) // [o, l, l, e, h]
  ```

#### 反转字符串II

- [力扣541](https://leetcode.cn/problems/reverse-string-ii/description/)

  ```js
  // 思路
  // 以2k步长前进 反转前k的字符串
  // 要点
  // 1、反转字符串的函数要改成接收起止位置进行反转
  // 2、遍历字符串时以 2k 步长移动
  
  function fn(list, n) {
      // 定义反转函数
      function reverse(start, end) {
          while (start < end) {
              [list[end], list[start]] = [list[start], list[end]]
              start++
              end--
          }
      }
      for (let i = 0; i < list.length; i += 2 * n) {
          // 虽然是以 2n 步长移动 但是始终只反转前 n 个
          // 因此边界条件只需要判断字符长度是否达到 n 即可
          if (i + n < list.length) {
              // 注意 n - 1 才是增加的索引长度
              reverse(i, i + n - 1)
          } else {
              reverse(i, list.length - 1)
          }
      }
  }
  
  // 验证
  let str = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
  fn(str, 2)
  console.log('反转abcdefg:' + str) // b,a,c,d,f,e,g
  str = ['a', 'b', 'c', 'd']
  fn(str, 2)
  console.log('反转abcd:' + str) // b,a,c,d
  ```

#### 翻转字符串里的单词

- [力扣151](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

  ```js
  // 思路
  // 首先字符串中可能有多余的空格 因此第一步就是去除多余空格
  // 其次需要注意到反转整个字符串后 再对单词进行反转 即可得到想要的结果
  // 难点其实是如何在连续空格中保留一个空格并删除其余空格
  // 这题算是数组移除元素的一个变种
  
  function remove(str) {
      // 用移除元素的双指针法 遇到要删除的空格就停下慢指针
      // 当快指针移动到非目标元素时将其赋值到慢指针位置
      // 要点 快慢指针的含义
      // 快指针表示 要 获取(保留) 的的元素
      // 慢指针表示 要移动到的 新的位置
      let slow = 0
      for (let fast = 0; fast < str.length; fast++) {
          // 同力扣27移除元素 遇到删除的目标就跳过
          // 使慢指针停留在要替换的位置
          if (str[fast] !== ' ') {
              // 关键点1 
              // 快指针此时指向要移动和保留的元素
              // 慢指针指向空格 但是每个单词间要保留一个空格
              // 因此慢指针在当前位置留下一个空格后 移动一位
              // 再进行赋值
              // 注意 首个单词前不需要加空格
              if (slow !== 0) {
                  str[slow] = ' ' // 留一个空格
                  slow++ // 往后移动
              }
              // 关键点2
              // 因为每次for循环进来存在slow位置保留一个空格的操作
              // 而外层for循环表示fast每移动一个字符
              // 因此为了不把一个单词拆成 字符空格字符空格的形式
              // 就得在当前循环中把一个单词完整的移动完
              while (fast < str.length && str[fast] !== ' ') {
                  str[slow] = str[fast]
                  // 复制完 移动双指针
                  slow++
                  fast++
              }
              // 循环结束 要么快指针已经走完全程
              // 要么当前单词已经复制完 快指针现在指向空格
              // 此时慢指针指向要移动的新位置
              // 不用担心for循环结束的fast++会有影响
              // 如果还有下一次循环 那么当前快指针指向空格 fast++只是把它移出空格位置
          }
      }
      // 此时slow是删除多余空格后 新数组长度
      return str.slice(0, slow)
  }
  
  function reverse(start, end, str) {
      while (start < end) {
          [str[start], str[end]] = [str[end], str[start]]
          // 调换后移动指针
          start++
          end--
      }
  }
  
  function fn(str) {
      // 先去除字符串中多余空格 保证每个空格前后必是单词
      let newStr = remove(str)
      // 进行数组整体反转
      reverse(0, newStr.length - 1, newStr)
      // 此时字符串整体都被反转 再对单词进行反转就正过来了
      let slow = 0 // 设置慢指针 指向空格间单词的起始位置
      for (let fast = 0; fast < newStr.length; fast++) {
          if (newStr[fast + 1] === ' ' || fast === newStr.length - 1) {
              // fast后一位是空格 或 已经遍历完数组
              // 反转这段单词
              reverse(slow, fast, newStr)
              // 注意！反转完后记得移动slow到新位置
              // 反转完slow到fast之间单词后 此时fast停在单词末尾
              // 如果还没遍历完
              // 那么fast后一位必是空格 又因为多余空格已去除
              // 那么fast后第二位必是单词起始位置 slow就移动到这
              slow = fast + 2
          }
      }
      return newStr
  }
  
  // 验证
  let str = 'the sky is blue'.split('')
  console.log('反转单词结果：' + fn(str).join('')) // blue is sky the

#### 右旋字符串

- [卡码网55](https://kamacoder.com/problempage.php?pid=1065)

  ```js
  // 思路
  // 先将字符串整体反转 此时后面的字符已经到了前面
  // 再依据整数 对字符串分段反转 即可得到右转结果
  
  function reverse(start, end, str) {
      while (start < end) {
          [str[end], str[start]] = [str[start], str[end]]
          start++
          end--
      }
  }
  
  function fn(str, num) {
      // 先将字符串反转 将后面的转到前面去
      reverse(0, str.length - 1, str)
      // 根据num分段反转
      reverse(0, num - 1, str)
      reverse(num, str.length - 1, str)
  }
  
  // 验证
  let str = 'abcdefg'.split('')
  fn(str, 2)
  console.log('字符串右转：' + str.join('')) // fgabcde

### 替换数字

- [卡码网54](https://kamacoder.com/problempage.php?pid=1064)

  ```js
  // 思路
  // 若要替换扩充数组 只需计算有多少个替换元素 扩充相应的长度
  // 为了避免添加元素后 所有元素整体向后移动 增加时间复杂度
  // 设置两个指针在新旧数组末尾 从后往前遍历取值
  // 遇到要替换的元素 就停下旧数组的指针 等到替换完成再同步移动
  
  function fn(list) {
      // 先获取有多少个替换元素
      let count = 0
      for (let val of list) {
          if (!isNaN(Number(val))) {
              // 是数字则自增
              count++
          }
      }
      // 设置双指针
      let slow = list.length - 1
      // 数字要被替换成number字符串 因此 原长 + 多出的长度  * 计数
      let fast = list.length + 5 * count - 1
      for (slow; slow >= 0; slow--) {
          // 原数组每走一步判断是否是数字
          if (isNaN(Number(list[slow]))) {
              // 不是数字 则将其赋值给fast位置
              // 赋值完fast往前移一位
              list[fast--] = list[slow]
          } else {
              // 是数字 则插入替换字符串
              // 每插入一个往前移一位
              list[fast--] = 'r'
              list[fast--] = 'e'
              list[fast--] = 'b'
              list[fast--] = 'm'
              list[fast--] = 'u'
              list[fast--] = 'n'
          }
      }
  }
  
  // 验证
  let str = 'a1b2c3'.split('')
  fn(str)
  console.log('替换数字后：' + str) // a,n,u,m,b,e,r,b,n,u,m,b,e,r,c,n,u,m,b,e,r

### KMP算法

#### 实现 strStr()

- [力扣28](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

  ```js
  // KMP思路
  // KMP用于 字符串匹配 其核心在于如何记录之前已经遍历过的字符串 而不用重复遍历
  // 有以下几个关键点
  // 1、KMP的Next数组是对比一段字符串中前缀和后缀相等的 最大前缀长度
  // 我的理解是 起始位置固定 的 滑动窗口 且需要注意的是
  // 前缀定义是 不包含 最后一个 字符但 必须包含 首字符 的 连续 字符串
  // 后缀定义是 不包含 首字符 但必须包含 末尾字符 的 连续 字符串
  // 这就是Next数组中元素值的核心！
  // 如 aa字符串 其前缀是首字母a 后缀是末尾字符a 前后缀相同的最大前缀为a 长度为1
  // 那么aa这段字符串 映射到Next数组 就是在末尾a的位置记录为1
  // 表示aa字符串 前后缀相等的最大前缀长度为1
  // 如 aabaa字符串 前缀：aaba aab aa a 后缀：abaa baa aa a 前后缀相同的最大前缀为aa 长度为2
  // 那么映射到Next数组 就是在next[4]的位置记录为2
  // 最大相等前缀的长度放在索引下标中 就正好是下一个要比较的字符
  // 这就是Next数组 回退 的思想
  // 2、Next数组元素值是如何得来的
  // 请记住 KMP思想是记录已经遍历过的字符串 不再重复遍历
  // 因此其核心思路就是字符串比对 只比对 末尾 字符是否相同！如果相同则在前一个最大相等前缀长度基础上+1
  // 如果不相同 则 回退 到 上一个 最大相等前缀 后一位 比对
  // 3、有了Next数组后 与目标字符串进行匹配
  // 如 目标字符串aabaabaaf 模字符串aabaaf
  // 从前往后匹配 到模字符串的f时 发现不匹配 这说明两件事
  // 一、模字符串f前的aabaa 与 目标字符串b前的aabaa相同 二、找aabaa的最大相等前缀 即回退到aa
  // 基于KMP思想 目标字符串的指针继续向前 但Next数组的指针要 回退 到aa后的b 再进行比对
  // 直到Next数组指针顺利走完全程 说明目标字符串中存在与模字符串完全相同的字符串
  // 如果目标字符串的指针都走完了 模字符串指针还没走完 说明不存在对应字符串
  // 顺便说一下为什么不用哈希表
  // 因为本题要求模字符串从起始位置到末尾 字符个数 位置 完全相同
  // 而哈希表只能统计字符个数 少一个位置维度
  // 顺便说一下为什么要找最大相等 前缀
  // 因为source和target进行对比时 遇到不相等的字符 说明source和target前面部分是相同的 看作公共部分
  // 为了source的索引不往回退 对于公共部分source当前索引位置就相当于是“后缀” 
  // 而要找到target中已经遍历过的部分就相当于“前缀”
  // 因此只要找到 最长 的 “前缀” 和 “后缀” 相同的部分 就可以略过已经遍历过的部分
  
  function getNext(target) {
      let next = []
  
      // 仅一个字符时 没有前后缀 因此next中第一个值为0
      let j = 0
      next[0] = j
      // 跳过第一个字符
      for (let i = 1; i < target.length; i++) {
          // 关键点 next数组中存的是0~i字符串的 最大相等前后缀
          // 如ababa 就是在末尾a的位置存3 因为aba是前后缀相等的最长前缀
          // 只对比末尾字符 不同则 回退 到上一个最大相等前后缀的后一位
          // 因为回退后的字符依然可能不同 所以回退不能只执行一次
          // 因此用while循环比对
          // 回退到0就结束循环 说明没有前后缀相等 即与记录过的字符都不匹配
          while (j > 0 && target[i] !== target[j]) {
              // 当前j位置字符不匹配 就找j的前一位看它的最大相等前后缀索引位置
              // 然后再拿上一个最大相等前后缀的后一位即target[j]对比i位置字符
              // 如果相等 说明上一个最大相等前后缀长度还可以增加1
              // 如果不相等 说明上一个最大相等前后缀不满足当前0~i字符串的最大相等前后缀
              // 那么就再回退看上上个最大相等前后缀是否符合
              // 直到找到符合的 最大相等前后缀 或 没有相等前后缀
              j = next[j - 1]
          }
          // 循环结束 说明已经回退到0 或 j位置字符和i位置字符相同
          if (target[i] === target[j]) {
              // j位置字符和i位置字符相同
              // 说明上一个最大相等前后缀长度还可以增加1
              // 则在当前最大相等前后缀长度的基础上+1
              j++
          }
          // 将当前最大相等前后缀长度存到 i位置
          // 顺便说一下为什么要求“前缀” 因为前缀就表示已经遍历过的相同字符串 无需再重新遍历
          next[i] = j
      }
  
      return next
  }
  
  function fn(source, target) {
      // 先根据target获取next数组
      let next = getNext(target)
      // 设置慢指针遍历target
      let slow = 0
      // 从第一个字符开始比对
      for (let fast = 0; fast < source.length; fast++) {
          // slow的位置就表示slow之前的字符与fast之前的字符相同
          // 从fast和slow位置开始不同 进行比较
          while (slow > 0 && source[fast] !== target[slow]) {
              // 如果fast 和 slow字符不同
              // 说明fast和slow前面的字符是相同的 根据slow前一位在next中的值得到 前面相同字符串的
              // 最大相等前后缀的后一位 再进行比对 如果仍然不匹配
              // 则一直回退到 slow为0 或 匹配为止
              // 如 aabaabaaf 和 aabaaf fast = 5 slow = 5时 b和f不匹配 但前面aabaa相同 作为公共部分
              // 那么只要找到 公共部分aabaa 的最大相等前后缀 aa
              // 即fast = 5 fast前面的aa是 公共部分aabaa的后缀
              // 与slow = 2(回退后的值)时 aab的前缀aa相同
              // 即aabaaf中前缀aa已经记录过 只需对比slow = 2的b和fast = 5的b是否相同 
              // 所以可以这么理解：
              // KMP是将target字符串处理成存储 最大相等前后缀(可回退位置) 的数组
              // 在source中匹配到不相同的字符时 找寻公共部分字符串的最大相等前后缀
              // 来得到slow的回退位置 从最大相等前后缀后一位开始比对是否相等
              slow = next[slow - 1]
          }
          // 循环结束 slow已经回退到0 或 slow位置字符与fast位置字符相同
          if (source[fast] === target[slow]) {
              // slow位置字符与fast位置字符相同
              // 则slow在target中位置要前进一步
              slow++
          }
          // 此时如果slow已经走完target 说明找到了目标字符串
          // 注意是target.length 不是target.length-1
          // 因为最后一个字符匹配成功后slow++
          if (slow === target.length) {
              // 返回 0~fast字符串长度 - target字符串长度 的结果值
              return (fast + 1 - slow)
          }
      }
      // fast遍历结束 没找到
      return -1
  }
  
  // 验证
  console.log('aabaabaaf匹配aabaaf位置:' + fn('aabaabaaf', 'aabaaf')) // 3
  console.log('hello匹配ll位置:' + fn('hello', 'll')) // 2
  console.log('aaaaa匹配bba位置:' + fn('aaaaa', 'bba')) // -1

#### 重复的子字符串

- [力扣459](https://leetcode.cn/problems/repeated-substring-pattern/description/)

  ```js
  // 枚举思路
  // 如果是全部由子串组成的字符串 那么最少有两个子串
  // 因此字符串遍历到一半长度即可
  // 然后设置两层for循环 外层确定子串的起始位置 里层确定子串的结束位置
  // 在里层遍历时 与 索引0开始的子串进行比较 不匹配则跳出内循环
  // 外循环移动
  
  function fn1(str) {
      // 注意 因为找重复子串 必然是与首位错开的 所以遍历要从1开始
      // 注意 重复数最小情况是只有两个子串构成 即整个字符串对半分
      // 因此外循环最大索引是第二个子串起始位置 即2 * slow = len
      for (let slow = 1; slow * 2 <= str.length; slow++) {
          // 注意 如果str全部由重复子串构成 那么str的总长度一定可以整除子串长度
          // 如str长度为9 由3个长度为3的子串构成 那么slow为3时一定可以被9整除
          // 因此只需要判断余数为0的
          if (str.length % slow === 0) {
              // 先设置标记为true 只要内循环找到一个不相同的就返回false
              let flag = true
              // 以0~slow为目标子串 以slow~fast为匹配字符串
              // slow作为起始位置 一直遍历到str末尾看是否完全由目标子串构成
              for (let fast = slow; fast < str.length; fast++) {
                  // 因为是以0~slow为目标子串 因此fast - slow即从0开始匹配
                  if (str[fast] !== str[fast - slow]) {
                      // 过程中任意字符不相同 跳出循环
                      flag = false
                      break
                  }
              }
              // 如果内循环结束都没找到不匹配字符 说明全部是由目标子串构成
              if (flag) {
                  return true
              }
          }
      }
      // 循环结束仍没return true说明不是由重复子串构成
      return false
  }
  
  // 验证
  console.log('abcabcabc是否由重复子字符串构成：' + fn1('abcabcabc')) // true
  console.log('aabaa是否由重复子字符串构成：' + fn1('aabaa')) // false
  
  // 前后拼接字符串思路
  // 可以这样理解：如果一个非重复字符串 取它的前缀和后缀交换位置
  // 一定无法构成原字符串 而str + str形成的新字符串
  // 是由前一个str的后半部分和后一个str的前半部分拼接而成 类似前后缀交换顺序
  // 因此不存在非重复字符串str + str能生成str
  // 如 abcabc 拼接后 abcabcabcabc 去掉首尾 bcabcabcab 可以在其中找到abcabc
  // 如 abcab 拼接后 abcababcab 去掉首尾 bcababca 其中找不到abcab
  
  function fn2(str) {
      let ss = str.substring(1) + str.substring(0, str.length - 1)
      let result = ss.indexOf(str)
      if (result === -1) {
          return false
      } else {
          return true
      }
  }
  
  // 验证
  console.log('拼接字符串：' + fn2('abcabc')) // true
  
  // KMP思路
  // next数组中存的是模式串中0~i字符串的最大相等前后缀长度 即可回退的已记录字符串位置
  // 如果是重复子串构成的字符串 其next数组中的值一定是递增的
  // 因为0~i往后伸展的过程中最大相等前后缀一定是越来越长的
  // 只有开头的子串没有相等的前后缀 所以是0
  // 因此只要用字符串长度 - 最大相等前后缀长度 得到最小子串长度
  // 再用字符串长度对该最小子串长度取余 如果能整除说明就是由这个子串重复构成
  
  function getNext(str) {
      let j = 0
      let next = []
      next[0] = j
      for (let i = 1; i < str.length; i++) {
          while (j > 0 && str[i] !== str[j]) {
              j = next[j - 1]
          }
          if (str[i] === str[j]) {
              j++
          }
          next[i] = j
      }
      return next
  }
  
  function fn3(str) {
      // 先取得next数组
      let next = getNext(str)
      // 求最小子串长度
      let min = str.length - next[next.length - 1]
      if (str.length % min === 0) {
          return true
      } else {
          return false
      }
  }
  
  // 验证
  console.log('KMP判断 abab 是否为重复子串构成：' + fn3('abab')) // true
  console.log('KMP判断 abcabcabcabc 是否为重复子串构成：' + fn3('abcabcabcabc')) // true
  console.log('KMP判断 aba 是否为重复子串构成：' + fn3('aba')) // false
  ```

## 栈与队列

### 栈和队列模拟

#### 用栈实现队列

- [力扣232](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

  ```js
  // 思路
  // 用栈模拟队列行为 要点
  // 1、栈模拟队列 必须要用两个栈 正所谓负负得正 两个先进后出 结合起来就能模拟先进先出
  // 2、入栈和入队列操作相同 都是往末尾添加
  // 3、模拟出队列 关键要调整元素顺序
  // 先判断出栈是否为空 出栈如果不为空 说明之前入栈的元素还没走完 那就先弹出栈的元素
  // 如果出栈为空 说明先进来的元素已经走完 可以出栈新的元素 就将入栈的元素依次装入出栈
  
  class myQueue {
      // 入栈 模拟入队列的行为
      inStack = []
      // 出栈 模拟出队列的行为
      outStack = []
  
      // 入队列
      push(value) {
          this.inStack.push(value)
      }
  
      // 出队列
      pop() {
          // 出栈还没清空 说明先入队列的元素还没清完
          if (this.outStack.length) {
              return this.outStack.pop()
          }
          // 出栈已经清空 则将入栈元素依次装入出栈
          while (this.inStack.length) {
              this.outStack.push(this.inStack.pop())
          }
          // 此时出栈里的元素已经与入栈时的元素相反 与入队列元素顺序相同
          this.outStack.pop()
      }
  
      // 查看队列首位元素
      peek(){
          let val = this.pop()
          // 注意 只是查看并不是让该元素出队列 因此还要装回去
          this.outStack.push(val)
          return val
      }
  
      // 判断队列是否为空
      empty(){
          // 入栈和出栈都清空了才算队列为空
          return !this.inStack.length && !this.outStack.length
      }
  }
  ```

#### 用队列实现栈

- [力扣225](https://leetcode.cn/problems/implement-stack-using-queues/description/)

  ```js
  // 思路
  // 用队列模拟栈的行为 要点
  // 1、用队列模拟出栈就是先将队列前面的元素依次弹出并装入队列末尾
  // 这样队列头部的元素就是末尾要弹出的元素了
  // 2、返回栈顶元素也是依靠 队列模拟出栈操作 将元素出栈后再装到队列末尾
  
  class myStack {
      // 用一个队列模拟栈操作
      queue = []
  
      // 入栈操作
      push(value) {
          this.queue.push(value)
      }
  
      // 出栈操作
      pop() {
          // 记录队列长度
          let len = this.queue.length
          // 一边从顶部出队列 一边装入队列末尾
          // 直到最后一个元素
          while(--len){
              this.queue.push(this.queue.shift())
          }
          // 此时最后一个元素在队列最前面
          return this.queue.shift()
      }
  
      // 查看栈顶元素
      top(){
          // 利用出栈操作取出队列末尾元素 再装入队列末尾
          let val = this.pop()
          this.queue.push(val)
          return val
      }
  
      // 栈是否为空
      empty(){
          return !this.queue.length
      }
  }
  ```

### 栈的应用

#### 有效的括号

- [力扣20](https://leetcode.cn/problems/valid-parentheses/description/)

  ```js
  // 思路
  // 本题规则是允许 []() [()]形式 但不允许 [(])形式
  // 以及不允许缺少闭合括号 如([] ()]
  // 也就是有三种情况
  // 1 ([]这样左边括号多了
  // 2 ()]这样右边括号多了
  // 3 [(])这样左右不匹配
  // 利用栈来对左半边括号进行统计 当对应的右半边括号数量和种类与栈中不匹配
  // 说明有括号没有闭合
  // 顺便说一下为什么要用栈这种结构
  // 因为要防止[(])这样的形式 栈的先进后出正好符合[]() [()]形式的闭合规则
  // 遇到左半边就将对应的右半边装入栈 遇到右半边就找栈顶的的括号是否符合
  
  function fn(str) {
      // 注意 左右闭合的括号 一定是成对出现
      // 因此符合的字符串长度一定是偶数
      if (str.length % 2 !== 0) {
          // 奇数 说明必不符合
          return false
      }
      // 设置栈
      let list = []
      for (let i = 0; i < str.length; i++) {
          // 遍历字符串 找出左半部分 将对应的右半部分填入栈中
          if (str[i] === '(') {
              list.push(')')
          } else if (str[i] === '[') {
              list.push(']')
          } else if (str[i] === '{') {
              list.push('}')
          } else if (!list.length || list[list.length - 1] !== str[i]) {
              // 前面的if过滤了左半边括号 当前遇到右半边括号
              // 栈为空 且 字符串中仍有右半边括号
              // 说明左半边括号少了 多了右边括号 符合情况2
              // 当前右括号与栈顶存的右括号类别不符
              // 说明出现[(])这样闭合括号不符 符合情况3
              return false
          } else {
              // 剩下的就是找到对应右半边括号 将其出栈
              list.pop()
          }
      }
      // 当遍历完字符串 栈中仍有剩余 说明左半边括号多了 符合情况1
      if (list.length) {
          return false
      }
      // 此时入栈数和出栈数相等 说明字符串符合题目要求
      return true
  }
  
  // 验证
  let str = '()[]{}'
  console.log(`${str} 是否完全闭合:` + fn(str)) // true
  str = '([)]'
  console.log(`${str} 是否完全闭合:` + fn(str)) // false
  str = '{[]}'
  console.log(`${str} 是否完全闭合:` + fn(str)) // true
  ```

#### 删除字符串中的所有相邻重复项

- [力扣1047](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/)

  ```js
  // 栈思路
  // 利用栈的结构 每遍历一个元素与栈内的元素不同
  // 就将其装入栈 当遇到相同的元素就将栈顶的元素出栈
  // 由此就可以达到像消消乐的效果
  
  function fn1(str) {
      let result = []
      for (let i = 0; i < str.length; i++) {
          if (!result.length || result[result.length - 1] !== str[i]) {
              // 栈为空 或 栈顶元素(数组末尾)与当前元素不相同 就入栈
              result.push(str[i])
          } else {
              // 栈顶元素与当前元素相同 则将栈顶元素出栈
              result.pop()
          }
      }
      return result.join('')
  }
  
  // 验证
  console.log('栈消除相邻相同元素' + fn1('abbaca')) // ca
  
  // 双指针模拟栈思路
  // 栈的方法因为还要使用额外的内存空间 空间复杂度是O(n)
  // 双指针思路类似力扣27移除元素 两指针一前一后
  // 遇到不同的元素就赋值 相同的就回退前指针
  
  function fn(str) {
      // 转换成数组才能用下标形式修改 字符串只能用下标读 不能用下标改
      str = [...str]
      // 类似链表中的虚拟头节点 等于-1是为了用通用方法处理头部元素
      let slow = -1
      for (let fast = 0; fast < str.length; fast++) {
          if (slow === -1 || str[fast] !== str[slow]) {
              // 首字符 或 fast元素不等于slow元素 则入栈
              // 因为slow从-1开始 先移动slow 再赋值
              str[++slow] = str[fast]
          } else {
              // fast元素和slow元素相同
              // 说明slow元素要与fast元素抵消掉 因此slow要往回退一步
              slow--
          }
      }
      // 遍历完 此时slow指向的是消除相邻且相同元素后的末尾元素
      //末尾元素索引+1 等于新数组长度
      slow++
      // 用array.length = num可以扩展或裁剪数组
      // 只保留slow长度内的元素
      str.length = slow
      return str.join('') // 将数组再转换成字符串
  }
  
  // 验证
  console.log('双指针模拟栈消除相邻相同元素' + fn1('abbaca')) // ca
  ```

#### 逆波兰表达式求值

- [力扣150](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

  ```js
  // 思路
  // 遍历数组 遇到数字就入栈 遇到操作符就出栈
  // 注意一个操作符两边只能各放1个数
  // 因此每次遇到操作符出栈 只出固定2个数
  // 且出栈的数经过操作符计算完后要将结果入栈
  
  function fn(list) {
      // 设置栈存储数字
      let result = []
      for (let i = 0; i < list.length; i++) {
          let num = Number(list[i])
          if (!isNaN(num)) {
              // 是数字 则入栈
              result.push(num)
          } else {
              // 是操作符 则弹出栈顶两个元素
              let x = result.pop()
              let y = result.pop()
              let r
              switch (list[i]) {
                  case '+':
                      r = x + y
                      break
                  case '-':
                      // 减 和 除 要注意顺序
                      // 依照栈中先进后出 后出栈的元素放前面
                      r = y - x
                      break
                  case '*':
                      r = x * y
                      break
                  case '/':
                      // 除法要注意分母为0的情况
                      r = Math.round(y / x) || 0
                      break
              }
              result.push(r)
          }
      }
      // 循环结束 栈中只会有一个数字 即计算结果
      return result[0]
  }
  
  // 验证
  let list = ["2", "1", "+", "3", "*"]
  console.log('后缀表达式计算结果：' + fn(list)) // 9
  list = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
  console.log('后缀表达式计算结果：' + fn(list)) // 22
  ```

### 队列的应用

#### 滑动窗口最大值

- [力扣239](https://leetcode.cn/problems/sliding-window-maximum/description/)

- 单调升/降队列

  ```js
  // 队列思路
  // 用类定义一个单调队列 每在队列末尾装入一个元素
  // 看其前面的元素是否小于它 将其前面小于它的元素全部弹出
  // 这样就保证了队列元素是从大到小排列
  // 滑动窗口每移动一步 对比队列头部(最大值) 与 滑动窗口移除的元素 是否相等
  // 相等说明滑动窗口已经要移出头部最大元素在数组中的位置了 将其弹出
  // 不相等说明头部元素还在滑动窗口内部 不进行弹出操作
  // 因为在滑动窗口 最大值前的元素在push操作时已经弹出了
  // 然后滑动窗口每移动一步 就将队列头部元素填入结果数组
  
  // 构造单调队列类
  class Queue {
      // 不用通过构造器赋值可以这样简写
      list = []
      // 获取最大值
      get_max() {
          // 队列从大到小排列 取第一个就是滑动窗口最大值
          return this.list[0]
      }
      // 从滑动窗口移出的元素 判断是否在队列中
      remove(num) {
          // 当前传入数字判断是否是队列头元素
          // 不是说明在push操作时已经将小于头部的弹出了
          // 相等 说明当前移出滑动窗口的数字就是队列头元素
          if (this.list.length && list[0] === num) {
              // 队列不为空 且 头元素与当前移出数字相同
              this.list.shift()
          }
      }
      // 队列末尾填入当前进入滑动窗口的元素 并将小于其的数字弹出
      push(num) {
          let last = this.list[this.list.length - 1]
          // 可能不止有一个 因此用循环
          while (last && last < num) {
              this.list.pop()
              last = this.list[this.list.length - 1]
          }
          // 循环结束 队列中只保留了比当前进入滑动窗口的数字大的元素
          this.list.push(num)
      }
  }
  
  function fn(nums, k) {
      let queue = new Queue()
      let result = []
      // 先将长度k的滑动窗口数字填入队列
      for (let i = 0; i < k; i++) {
          queue.push(nums[i])
      }
      result.push(queue.get_max()) // 前k长度结果值
      // 再遍历nums 进行滑动窗口移动
      // 注意 j-1表示滑动窗口结束位置 j表示即将进入滑动窗口的元素
      for (let j = k; j < nums.length; j++) {
          // 从k索引开始 即第一个元素要移出
          // 滑动窗口起始位置是j - k
          queue.remove(nums[j - k])
          // 再判断要加入的元素是否放到队头
          queue.push(nums[j])
          // 取队头元素作为结果值
          result.push(queue.get_max())
      }
      return result
  }
  
  // 验证
  let list = [1,3,-1,-3,5,3,6,7]
  let k = 3
  console.log('滑动窗口最大值：' + fn(list, k)) // [3, -1, 5, 5, 6, 7]
  ```

#### 前 K 个高频元素

- [力扣347](https://leetcode.cn/problems/top-k-frequent-elements/description/)

- 优先级队列

  - 小顶堆、大顶堆

  ```js
  // 思路
  // 本题要求元素出现的频次 即要对元素进行统计 这就要用到哈希表
  // 又要求前k个 也就是需要哈希表排序 取前k个作为结果 时间复杂度为nlog(n)
  // 更优解是不对 整个 哈希表进行排序 而是只维护哈希表中前k个元素
  // 用一个队列装这k个元素的频次 并且队列只能从头部弹出元素
  // 因此要对这k个元素排序 这就可以用优先级队列
  // 优先级队列不像单调队列单调升或单调降
  // 其本质是 堆 但是只能从头部弹出 尾部添加所以看起来像队列
  // 又因为只能从队列头部舍弃元素 因此要舍弃的就是频次较小的元素 也就是小顶堆
  // 每在队列末尾填入一个元素就要依照小顶堆规则 将较小频次的元素移动到队列头部(堆顶)
  // 如果当前队列已经超过k的长度 则将头元素(最小值)替换为末尾填入的元素 即舍弃了最小值
  // 以维持k的长度 然后对新填入的元素进行排序 放到堆的合适位置
  // 由此就可以得到前k个高频元素
  // 注意 小顶堆只是节点值小于左右孩子的值 不代表左右孩子的值也是有排过序的
  // 但是本题只要求前k个 不论顺序 因此没关系
  
  // JS中没有堆 手动实现
  class Heap {
      // 虽然是堆 但JS中是用数组保存其序列
      list = []
      constructor(compareFn) {
          // 接收建堆结构时 传入的回调函数(规则)
          this.compareFn = compareFn
      }
      // 堆大小 方便外部访问list长度
      size() {
          return this.list.length
      }
      // 比较节点大小方法
      compare(pre, next) {
          // 处理下标越界问题
          if (this.list[pre] === undefined || this.list[next] === undefined) {
              // 当排序方法的前一个值 或 后一个值不存在 则不进行交换
              return -1
          }
          // 根据回调函数的规则对比
          return this.compareFn(this.list[pre], this.list[next])
      }
      // 往堆(队列)末尾填入元素
      push(value) {
          this.list.push(value)
          // 新填入的元素在堆底 因此要进行上升操作
          let current = this.size() - 1 // 初始值为数组末尾索引
          let parent = Math.floor((current - 1) / 2) // 计算父节点索引公式
          // 循环向上查找 并根据compareFn决定是否交换位置
          while (parent >= 0 && this.compare(parent, current) > 0) {
              // 父节点必须存在 且 父节点比当前节点大 则交换位置
              // 注意 compare中的参数顺序 因为是上升操作 所以小的元素要往上浮
              [this.list[current], this.list[parent]] = [this.list[parent], this.list[current]]
              // 交换后 继续向上查找 更新索引位置
              current = parent
              parent = Math.floor((current - 1) / 2)
          }
      }
      // 队列头部弹出元素
      pop() {
          // 队列为空 或 只有一个元素则不需要执行后续下沉操作 直接弹出
          // 因为用的是pop方法 队列末尾弹出 所以长度大于1的都要执行后续操作
          if (this.size() <= 1) {
              return this.list.pop()
          }
          // 下沉操作 就是将pop要弹出的末尾元素(最大值) 替换掉 头元素
          // 相当于头元素(最小值)被丢掉 但是最末尾元素被放到了头节点 依照堆的结构就要进行下沉操作 把它放到堆中合适的位置
  
          // 先存储头节点 作为自定义pop方法的返回值
          let out = this.list[0]
          // 然后用末尾弹出元素替换头节点
          this.list[0] = this.list.pop()
          // 依据compareFn规则对头节点进行下沉
          let current = 0
          let leftChild = current * 2 + 1 // 计算父节点的反向计算
          // 找到符合条件需要交换的子节点
          // 如小顶堆的话就取左右子节点中较小的 大顶堆的话就取左右子节点中较大的
          let searchChild = this.compare(leftChild, leftChild + 1) > 0 ? leftChild + 1 : leftChild
          // 因为compare中已经做了边界判断 从上往下遍历 取到队列中不存在的索引后 循环就结束了
          while (this.compare(current, searchChild) > 0) {
              // 大于0 说明按compareFn规则需要交换 将当前节点与其最小子节点进行换位
              [this.list[current], this.list[searchChild]] = [this.list[searchChild], this.list[current]]
              // 交换完 移动索引位置
              current = searchChild
              leftChild = current * 2 + 1
              searchChild = this.compare(leftChild, leftChild + 1) > 0 ? leftChild + 1 : leftChild
          }
          // 循环结束 堆结构重新调整好了 返回原先堆顶的元素
          return out
      }
  }
  
  function fn(nums, k) {
      // 先统计元素频次
      let map = new Map()
      for (let num of nums) {
          map.set(num, (map.get(num) || 0) + 1)
      }
      // 创建小顶堆
      // 传入的回调函数表示 pre - next 大于0就交换位置 同array.sort方法中传入的回调函数
      // 注意 传入 compareFn 的 this.list[索引] 是遍历map时 得到的[key, value]数组
      // 因此这里pre[1]和next[1]才是元素对应的频率值
      let minHeap = new Heap((pre, next) => pre[1] - next[1])
      // 遍历map
      for (let arr of map) {
          // 先将map元素填入小顶堆队列 进行排序
          minHeap.push(arr)
          // 然后判断当前队列长度是否超过k
          if (minHeap.size() > k) {
              // 大于k 则弹出队列头元素
              minHeap.pop()
          }
      }
      // 循环结束 minHeap中由小到大存着前k高频元素
      let result = []
      // 从尾部遍历 按频率由高到低填入结果数组
      for (let i = minHeap.size() - 1; i >= 0; i--) {
          // 注意 pop出来的是[key, value] 取key才是元素
          result.push(minHeap.pop()[0])
      }
      return result
  }
  
  // 验证
  let nums = [1, 1, 1, 2, 2, 3]
  let k = 2
  console.log(`前${k}个高频元素是：${fn(nums, k)}`) // [2, 1]
  nums = [1]
  k = 1
  console.log(`前${k}个高频元素是：${fn(nums, k)}`) // [1]
  ```

## 二叉树

### 二叉树种类

- 满二叉树
  - 定义：所有节点要么没有子节点，要么只有两个子节点
  - 满二叉树节点个数：`2^k - 1`
    - `k`为二叉树深度，从1开始
- 完全二叉树
  - 除了底层==全满==，底层==从左到右节点是连续的==
  - 满二叉树也是完全二叉树
  - ==优先级队列(小顶堆/大顶堆)==就是完全二叉树
- 二叉搜索树
  - 左子树的节点**的值**都小于中间节点**的值**，右子树的节点**值**都大于中间节点**值**
    - 简单来说就是所有节点都符合==左边小于中间，右边大于中间==
    - 注意：搜索树是有值的大小区分
  - 搜索时间复杂度：`log(n)`
- 平衡二叉搜索树
  - 空树或左右子树高度差的绝对值不超过**1**
    - 注意：所有子树都要符合这个规则。如左子树的左右子树高度差也不能超过1

### 二叉树存储方式

- 链式存储
  - 用==左右指针==指向下一个节点
    - 本质是==链表==
- 线性存储
  - 用数组存，从根节点往下一层一层存，每层从左到右
  - 索引关系
    - `左子节点索引 = 2 * 父节点索引 + 1`
    - `右子节点索引 = 2 * 父节点索引 + 2`
    - `父节点索引 = (左子节点索引 - 1) / 2`
    - `父节点索引 = (右子节点索引 - 2) / 2`

### 二叉树的遍历方式

- 深度优先遍历
  - 定义：先往深走，遇到叶子节点再往回走
  - 属于深度优先搜索的方法
    - 前序遍历（递归法，迭代法）
    - 中序遍历（递归法，迭代法）
    - 后序遍历（递归法，迭代法）
  - 前/中/后序遍历其实取决于中间节点的顺序
    - 前序遍历：中左右
    - 中序遍历：左中右
    - 后序遍历：左右中
    - 注意：这里的左和右表示左/右子树
    - 个人理解：为什么前/中/后由中间节点的位置来决定？因为左和右都表示**子树**，而不是**节点**，只有==中表示节点本身==，才可以添加其值到结果数组中，对应到代码中就是`result.push(中间节点.value)`，而左和右都是`递归方法(中间节点.left)`和`递归方法(中间节点.right)`
- 广度优先遍历
  - 定义：==一层一层==遍历
  - 属于广度优先搜索的方法
    - 层次遍历（迭代法）

### 二叉树的递归遍历

- 递归本质是就是==压栈==，每次调用都将该步操作压栈，`return`就是出栈，所以最关键的就是==确定终止条件==，至于递归本身的处理代码靠经验

- 递归算法三要素

  1. 确定递归终止条件
  2. 确定递归函数的参数和返回值
  3. 确定单层重复执行的逻辑

- 前/中/后序遍历就是换`result.push(node.value)`的位置

  ```js
  let result = []
  // 前序遍历
  function pre(node){
      // 确定终止条件
      if(node === null){
          // 确定递归函数出口返回值
          return
      }
      // 确定重复执行逻辑
      result.push(node.value) // 中
      // 确定递归函数参数
      pre(node.left) // 左
      pre(node.right) // 右
  }
  ```

### 二叉树的迭代遍历

- 递归本质是压栈、出栈的过程，因此用迭代`while`循环实现同样的结果，就是在模拟压、出栈的行为

  - 但是因为迭代法是每次循环中都执行完才进行下次循环，所以与递归逻辑不同，递归可以在一次调用中不停的往下递归，再==自动==出栈执行一开始外层的后续操作，而迭代就得考虑如何在一次循环中把事情做完，且不影响后续循环操作
  - 简单来说，就是递归不用考虑出栈的问题，而迭代需要在每次循环及时出栈，并配合出栈执行相应的操作

- ==前/后==序遍历都可以用==中==在前的形式得到结果数组 但是中序不行，因为访问节点(遍历节点)与处理节点(将元素放进结果集)不一致

  ```js
  // 前序遍历
  function pre(root){
      let result = []
      let stack = [] // 模拟行为用的栈
      // 前序遍历 中在前 所以一开始就将根节点入栈
      stack.push(root)
      // 栈不为空就一直循环
      while(stack.length){
          // 中节点在栈顶 出栈 并将其装入结果数组
          let node = stack.pop()
          result.push(node.value)
          // 再将左右子节点压栈
          // 注意 因为栈是先进后出 所以先压栈右节点 这样出来的顺序才是先左后右
          if(node.right){
              // 空节点不入栈
              stack.push(node.right)
          }
          if(node.left){
              stack.push(node.left)
          }
      }
  }
  
  // 后序遍历
  function last(root){
      let result = []
      let stack = []
      // 后序遍历与前序遍历基本上是相反的
      // 所以就可以用前序遍历的模板 得到结果数组 然后再对数组反转
      stack,push(root)
      while(stack.length){
          let node = stack.pop()
          result.push(node.value)
          // 注意 虽然是以前序遍历的执行逻辑为模板 但是后序遍历是左右中
          // 反转数组是中右左 所以进栈时要左先入栈 右才能先出栈
          if(node.left){
              // 注意此处和前序遍历的区别
              stack.push(node.left)
          }
          if(node.right){
              stack.push(node.right)
          }
      }
      // 得到结果数组 中右左 将其反转得到后序遍历结果
      result.reverse()
  }
  
  // 中序遍历
  function mid(root){
      let result = []
      let stack = []
      // 中序遍历有所不同 因为结果数组无法先填入中节点
    	// 得先遍历左子树
      // 因此需要用一个指针遍历
      let curNode = root
      // 指针不为空 或 栈不为空就继续遍历
      while(curNode !== null || stack.length){
          // 中序遍历是先遍历左子树 左子树为空则回退到中节点
          // 将中节点放入结果数组 再遍历右子树
          if(curNode){
              // 当前节点不为空 放入栈中
              stack.push(curNode)
              // 接着遍历左子树
              curNode = curNode.left
          }else{
              // 当前节点为空 但栈不为空
              // 出栈 得到中节点(要处理的数据)
              curNode = stack.pop()
              // 将其填入结果数组
              result.push(curNode.value)
              // 继续遍历右子树
              curNode = curNode.right
          }
      }
  }
  ```

### 二叉树的统一迭代法

```js
// 统一迭代法的思路
// 每次循环 先出栈 并保留出栈的元素
// 如果遇到非空节点 说明遇到了左或右节点 需要继续遍历 就按顺序将其与左右子节点入栈(如果存在的话)
// 并在中节点入栈后在其前面再填一个 null 作为标记 这就是标记法
// 如果出栈为 null 说明回退到了中节点(注意栈中已经排列好顺序了)
// 那么就再次出栈 将中节点填入结果数组

class Node {
	constructor(value, left, right) {
		this.value = value;
		this.left = left;
		this.right = right;
	}
}

let n1 = new Node(1, null, null);
let n2 = new Node(2, null, null);
let n4 = new Node(4, n1, n2);
let n6 = new Node(6, null, null);
let root = new Node(5, n4, n6);

// 前序遍历
function pre(root) {
	let result = []; // 结果数组
	let stack = []; // 模拟栈
	// 先将根节点入栈
	// 注：虽然根节点也是中节点 但是特殊处理 没有在入栈时像后面的中节点一样添加null标识
	// 这是为了能进入循环时遍历左右子树
	stack.push(root);
	// 栈不为空就一直循环
	while (stack.length) {
		// 先出栈 并保存出栈元素
		let cur = stack.pop();
		if (cur) {
			// 当前出栈的元素不为空
			// 说明需要继续遍历左右子树
			// 前序遍历 中左右 入栈顺序右左中
			if (cur.right) {
				// 右
				stack.push(cur.right);
			}
			if (cur.left) {
				// 左
				stack.push(cur.left);
			}
			stack.push(cur); // 中
			// 注意 这里还要添加一个null标识中节点
			stack.push(null);
		} else {
			// 出栈元素为null
			// 说明下一个出栈元素是中节点 要填入结果数组
			let mid = stack.pop();
			result.push(mid.value);
		}
	}

	return result;
}

// 验证
console.log('前序遍历：' + pre(root)); // [5,4,1,2,6]

// 中序遍历
function mid(root) {
	let result = [];
	let stack = [];
	stack.push(root);

	while (stack.length) {
		let cur = stack.pop();
		if (cur) {
			// 中序遍历 左中右 入栈顺序 右中左
			if (cur.right) {
				// 右
				stack.push(cur.right);
			}
			// 中
			stack.push(cur);
			stack.push(null);
			if (cur.left) {
				// 左
				stack.push(cur.left);
			}
		} else {
			let mid = stack.pop();
			result.push(mid.value);
		}
	}

	return result;
}

// 验证
console.log('中序遍历：' + mid(root)); // [1,4,2,5,6]

// 后序遍历
function last(root) {
	let result = [];
	let stack = [];
	stack.push(root);

	while (stack.length) {
		let cur = stack.pop();
		if (cur) {
			// 后序遍历 左右中 入栈顺序 中右左
			// 中
			stack.push(cur);
			stack.push(null);
			if (cur.right) {
				// 右
				stack.push(cur.right);
			}
			if (cur.left) {
				// 左
				stack.push(cur.left);
			}
		} else {
			let mid = stack.pop();
			result.push(mid.value);
		}
	}

	return result;
}

// 验证
console.log('后序遍历：' + last(root)); // [1,2,4,6,5]
```

### 二叉树的层序遍历

- [力扣102](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

  ```js
  // 思路
  // 层序遍历 用一个队列存每层的节点
  // 外层循环一开始先记录队列中本层节点数 即出队列数
  // 然后小循环挨个出队列 并将本层节点的子节点填入队列
  // 小循环结束 队列中存的就是下一层节点
  
  class Node {
      constructor(value, left, right) {
          this.value = value
          this.left = left
          this.right = right
      }
  }
  let n1 = new Node(1, null, null);
  let n2 = new Node(2, null, null);
  let n4 = new Node(4, n1, n2);
  let n6 = new Node(6, null, null);
  let root = new Node(5, n4, n6);
  
  function layer(root) {
      let result = []
      let queue = []
      queue.push(root)
      while (queue.length) {
          // 记录当前层节点数
          let size = queue.length
          // 用一个数组记录本层节点
          // 并遍历将下一层节点添加到队列
          let curLayer = []
          while (size--) {
              // 将队列头部节点出列
              let node = queue.shift()
              // 将其装入本层数组
              curLayer.push(node.value)
              // 将其子节点装入队列
              // 注：这里就体现为什么要提前记录队列长度
              // 因为队列长度会变化 所以一开始要记录本层需要出列的数量
              if (node.left) {
                  queue.push(node.left)
              }
              if (node.right) {
                  queue.push(node.right)
              }
          }
          // 循环结束 将本层数组装入结果数组
          result.push(curLayer)
      }
      return result
  }
  
  // 验证
  console.log('层序遍历', layer(root)) // [[5], [4, 6], [1, 2]]
  ```

#### 反向排列的层序遍历

- [力扣107](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/)

  ```js
  // 思路
  // 依旧从上往下层序遍历 只不过将每层数组从头部插入结果数组
  
  class Node {
  	constructor(value, left, right) {
  		this.value = value;
  		this.left = left;
  		this.right = right;
  	}
  }
  
  let n7 = new Node(7, null, null);
  let n15 = new Node(15, null, null);
  let n20 = new Node(20, n15, n7);
  let n9 = new Node(9, null, null);
  let root = new Node(3, n9, n20);
  
  function layer2(root){
      let result = [] // 记录每层结果
      let queue = [] // 辅助数据结构队列
      queue.push(root) // 初始装入根节点
  
      while(queue.length){
          // 记录本层节点数
          let size = queue.length
          // 记录本层节点值的数组
          let curLayer = []
          while(size--){
              // 根据初始队列长度弹出节点
              let node = queue.shift()
              // 将其值装入数组
              curLayer.push(node.value)
              // 将其子节点填入队列
              if(node.left){
                  queue.push(node.left)
              }
              if(node.right){
                  queue.push(node.right)
              }
          }
          // 从头部插入结果数组 避免还要倒序排列
          result.unshift(curLayer)
      }
  
      return result
  }
  
  // 验证
  console.log('反向层序遍历', layer2(root)) // [[15, 7], [9, 20], [3]]
  ```

#### 二叉树的右视图

- 本题层序遍历是最优解，因为不是单纯遍历右子树节点，而是取每层最后一个节点

- [力扣199](https://leetcode.cn/problems/binary-tree-right-side-view/description/)

  ```js
  // 思路
  // 层序遍历时 只存每层最后一个节点
  
  class Node {
      constructor(value, left, right) {
          this.value = value;
          this.left = left;
          this.right = right;
      }
  }
  
  let n1 = new Node(1, null, null);
  let n2 = new Node(2, null, null);
  let n4 = new Node(4, n1, n2);
  let n6 = new Node(6, null, null);
  let root = new Node(5, n4, n6);
  
  function fn(root) {
      let result = []
      let queue = []
      queue.push(root)
  
      while (queue.length) {
          let size = queue.length
  
          let lastNode
          while (size--) {
              let node = queue.shift()
              if (!size) {
                  // 本层最后一个节点 进行保存
                  lastNode = node.value
              }
              // 将本层的子节点装入队列
              if (node.left) {
                  queue.push(node.left)
              }
              if (node.right) {
                  queue.push(node.right)
              }
          }
          result.push(lastNode)
      }
      return result
  }
  
  // 验证
  console.log('二叉树右视图：' + fn(root)) // [5, 6, 2]
  ```

#### 二叉树的层平均值

- [力扣637](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/)

  ```js
  // 思路
  // 层序遍历 每层记录值并求均值
  
  class Node {
      constructor(value, left, right) {
          this.value = value;
          this.left = left;
          this.right = right;
      }
  }
  
  let n1 = new Node(1, null, null);
  let n2 = new Node(2, null, null);
  let n4 = new Node(4, n1, n2);
  let n6 = new Node(6, null, null);
  let root = new Node(5, n4, n6);
  
  function fn(root) {
      let result = []
      let queue = []
      queue.push(root)
  
      while (queue.length) {
          // 记录当前层节点个数
          let size = queue.length
          // count为循环用变量
          let count = size
          // 记录每层节点值总和
          let sum = 0
          while (count--) {
              let node = queue.shift()
              sum += node.value
              // JS中&&符 是找false 找到就不再进行后面的运算
              node.left && queue.push(node.left)
              node.right && queue.push(node.right)
          }
          // 循环结束 求均值
          result.push(sum / size)
      }
      return result
  }
  
  // 验证
  console.log('二叉树每层平均值：' + fn(root)) // [5, 5, 1.5]
  ```


#### N叉树的层序遍历

- [力扣429](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/)

  ```js
  // 思路
  // 依旧是层序遍历模板
  // 区别在于不再是只取二叉树左右子节点 而是遍历子节点列表
  
  class Node {
      constructor(value, child) {
          this.value = value;
          this.child = child;
      }
  }
  
  let n1 = new Node(1, []);
  let n2 = new Node(2, []);
  let n4 = new Node(4, [n1, n2]);
  let n6 = new Node(6, []);
  let root = new Node(5, [n4, n6]);
  
  function fn(root) {
      let result = []
      let queue = []
      queue.push(root)
  
      while (queue.length) {
          let size = queue.length
  
          let curLayer = []
          while (size--) {
              let node = queue.shift()
              curLayer.push(node.value)
  
              // 将当前节点的子节点取出
              for (let item of node.child) {
                  item && queue.push(item)
              }
          }
          result.push(curLayer)
      }
      return result
  }
  
  // 验证
  console.log('N叉树的层序遍历', fn(root)) // [[5], [4, 6], [1, 2]]
  ```

#### 在每个树行中找最大值

- [力扣515](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/)

  ```js
  // 思路
  // 层序遍历模板 取每一层最大值
  
  class Node {
      constructor(value, left, right) {
          this.value = value;
          this.left = left;
          this.right = right;
      }
  }
  
  let n9 = new Node(9, null, null);
  let n3_3 = new Node(3, null, null);
  let n5 = new Node(5, null, null);
  let n2 = new Node(2, null, n9);
  let n3 = new Node(3, n5, n3_3);
  let root = new Node(1, n3, n2);
  
  
  function fn(root) {
      let result = []
      let queue = []
      queue.push(root)
  
      while (queue.length) {
          let size = queue.length
          // 记录最大值
          let max
          while (size--) {
              let node = queue.shift()
              if (!max || node.value > max) {
                  // 如果max未赋值 或 节点值大于max 则记录
                  max = node.value
              }
              node.left && queue.push(node.left)
              node.right && queue.push(node.right)
          }
          // 本层 循环结束 将最大值装入结果数组
          result.push(max)
      }
  
      return result
  }
  
  // 验证
  console.log('每层最大值：' + fn(root)) // [1, 3, 9]
  ```

#### 填充每个节点的下一个右侧节点指针

- [力扣116](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/)

  ```js
  // 思路
  // 层序遍历模板 只是要记录前一个节点 让其next指向当前节点
  
  class Node {
      constructor(value, left, right, next = null) {
          this.value = value;
          this.left = left;
          this.right = right;
          this.next = next
      }
  }
  
  let n4 = new Node(4, null, null)
  let n5 = new Node(5, null, null)
  let n6 = new Node(6, null, null)
  let n7 = new Node(7, null, null)
  let n2 = new Node(2, n4, n5)
  let n3 = new Node(3, n6, n7)
  let root = new Node(1, n2, n3)
  
  function fn(root) {
      // 不需要结果数组
      // let result = []
      let queue = []
      queue.push(root)
      
      while (queue.length) {
          let size = queue.length
          
          while(size--){
              // 先拿到当前节点
              let curNode = queue.shift()
              // 如果size大于0说明本层还有节点
              // 就将其连到下一个即将要出队列的节点
              if(size){
                  curNode.next = queue[0]
              }
  
              curNode.left && queue.push(curNode.left)
              curNode.right && queue.push(curNode.right)
          }
      }
      // return result
      return root
  }
  
  // 验证
  console.log('填充next', fn(root))
  ```


#### 二叉树的最大深度

- [力扣104](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

  ```js
  // 思路
  // 层序遍历模板 只不过每遍历一层 记录下深度
  
  class Node {
      constructor(value, left, right) {
          this.value = value;
          this.left = left;
          this.right = right;
      }
  }
  
  let n1 = new Node(1, null, null);
  let n2 = new Node(2, null, null);
  let n4 = new Node(4, n1, n2);
  let n6 = new Node(6, null, null);
  let root = new Node(5, n4, n6);
  
  function fn(root) {
      let queue = []
      queue.push(root)
  
      let deep = 0
      while (queue.length) {
          let size = queue.length
          // 每层循环一开始先累加层数
          deep++
          while (size--) {
              let node = queue.shift()
              node.left && queue.push(node.left)
              node.right && queue.push(node.right)
          }
      }
      return deep
  }
  
  // 验证
  console.log('二叉树深度为：' + fn(root)) // 3
  ```

#### 二叉树的最小深度

- [力扣111](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

  ```js
  // 思路
  // 层序遍历模板 找到 第一个 左右孩子都为空的节点 所在层 即为最小深度
  
  class Node {
      constructor(value, left, right) {
          this.value = value;
          this.left = left;
          this.right = right;
      }
  }
  
  let n1 = new Node(1, null, null);
  let n2 = new Node(2, null, null);
  let n4 = new Node(4, n1, n2);
  let n6 = new Node(6, null, null);
  let root = new Node(5, n4, n6);
  
  function fn(root) {
      let queue = []
      queue.push(root)
  
      let minDeep = 0
      while (queue.length) {
          let size = queue.length
          // 每层循环开始先累加最小层高
          minDeep++
          while (size--) {
              let node = queue.shift()
              // 找到第一个叶子节点 就不必往下遍历了 返回结果
              if (!node.left && !node.right) {
                  return minDeep
              }
              node.left && queue.push(node.left)
              node.right && queue.push(node.right)
          }
      }
  }
  
  // 验证
  console.log('二叉树最小深度:' + fn(root)) // 2
  ```

  
