## 中央处理单元CPU

- CPU的**作用**：实现==程序控制==、==操作==控制、==时间==控制、==数据处理==功能
- （考点）CPU的**组成**：==运算==器、==控制==器、==寄存器==组、内部==总线==
- （考点）**运算器**
  - **组成**
    - 算术==逻辑单元ALU==：实现对数据的算术和逻辑**运算**
    - **累加**==寄存器AC==：**运算结果**或**操作数**的存放区
    - 数据**缓冲**==寄存器DR==：暂时存放在**内存**的**指令**或**数据**
    - **状态**条件==寄存器PSW==：保存指令运行结果的条件码内容
      - 如：溢出标志
  - **功能**
    - 执行所有==算术运算==
      - 如：加减乘除
    - 执行所有==逻辑运算==并进行逻辑==测试==
      - 如：与、或比较
- （考点）**控制器**
  - **组成**
    - **指令**==寄存器IR==：**暂存**CPU正在执行的**指令**
    - 程序==计数器PC==：存放**即将执行**的**指令**执行**地址**
    - **地址**==寄存器AR==：**保存**当前CPU所访问的**内存地址**
    - 指令==译码器ID==：**分析**指令**操作码**
  - **功能**
    - 控制整个CPU的工作，最为重要
      - 如：程序控制、时序控制等

## 校验码

- 为了解决计算机各部件进行数据传输和交换，确保传送过程正确无误
- 常见的几种校验码：==奇偶==校验码、==循环冗余==校验码（==CRC==）、==海明码==

## Cache的地址映像方法

- `Cache`是为了解决==内存和CPU之间==速度容量不匹配的问题(==运算==速度越来越==快==，而==写入==速度==跟不上==)，在这个过程中会将==主存内容**复制**到cache中==，方便CPU==就近访问==
- 计算机一般按照==页==或==块==的方式调用，毕竟按`1bit`之类的调用太过细致
  - 何为页/块，即将主存分为==大小相同==的区域
    - ==页面、块、缓存块==是一个东西
    - 这里的大小相同，**不是**指等比划分，而是真的大小一致，如主存划出`3KB`大小的块，`Cache`也要划出`3KB`大小的块
  - 按页/块调用的过程中，会形成地址映射关系
    - 注意！主存和`Cache`之间的映射由**硬件**来完成

- 映射规律：分为**直接**相联映像、**全**相联映像、**组**相联映像
  - 直接：主存和**块**与`Cache`**块**的对应关系是**固定的**
    - 即将主存划分成和`Cache`大小一致的区域，如0号区，1号区，2号区，`Cache`也同样，主存的0号区只能放在`Cache`的0号区
    - 缺点：易**冲突**，如果这个位置已经被占用了，新数据会替换掉原来的数据
    - 优点：**硬件**电路设计简单，复杂度低
  - 全：依旧划分成大小相同的块，但是==任意主存地址都可以存放在Cache的任何位置==，需要一个**查找表**来管理所有的**映射关系**
    - 缺点：电路设计复杂，只适用==小容量==的`Cache`，==无法从主存块中直接获取Cache块==，因此速度慢
    - 优点：冲突率低，灵活
  - 组：直接和全相联的**折中**形式，将`Cache`中的==块分成组==，组内采用全相联方式
    - 如：主存任何区的0组只能存到`Cache`的0组，1组只能存到`Cache`的1组中，而组内，主存1组的任意块可以存入`Cache`1组的任意块
    - 先分区，再分组

## Cache替换算法

- 又名，页面==置换==算法，或页面==淘汰==算法

-  常见替换算法
  - 随机替换算法(==RAND==)：使用**随机数**作为==被替换块号==，将该块号替换出去
  - 先进先出算法(==FIFO==)：替换==最早==进入缓存的块
  - 近期最少使用算法(==LRU==)：替换近期最少==使用==的块。根据`Cache`中块的==使用==时间
  - 最不频繁使用使用算法(==LFU==)：替换==访问次数==最少的块。用一个==计数器==记录==访问==块的==次数==
    - 注：==LFU使用计数器==，这是曾经的考点
  - 优化替换算法：==先执行一次==程序，==统计开始时的替换情况==，在后续执行中==选择合适的缓存块==进行替换
- `Cache`的读写过程
  - `Cache`的内容是==从主存**直接**复制==，在CPU的调度下使用
  - CPU在使用过程中有==可能会修改块的内容==，因此会造成`Cache`和内存中不一致的情况，因此有3种**读写算法**：
    - **写直达**：同时写入`Cache`和内存
      - Cache内容修改的同时修改内存中相应内容
      - 缺点：效率慢，消耗大
    - **写回Cache**：==只写Cache==，**仅当**==淘汰缓存块时==，==将修改的内容写回内存中==
      - 例：Cache一直在用一个页面，只在最后不用这个页面时写回到内存中
      - 优点：减少主存的写操作
    - **标记法**：==只写内存==，**每个**缓存块都有一个标记，来表示该缓存块中的数据来自主存中的哪个地址，每次修改将其==在内存中修改==，但是==修改时，要对Cache进行标记==，后面再用到对应标记的数据时，就从内存中直接调取新的数据
      - 注：Cache本质上就是==缓存==机制，实质的内容还是在==内存==当中
      - 注：标记通常和索引（Index）一起使用，用于快速定位缓存中的数据

## 磁盘(机械硬盘)

- 以==文件形式==存储数据

- CPU无法直接读取外存中的数据，需要将其==以文件为单位==调入内存中才能进行访问
- 外存包括：光盘、固态硬盘、磁表面存储器(机械硬盘、磁带)
- 磁盘结构
  - 由多个盘面组成，一个==盘片==可能有两个==盘面==，每个==盘面==上有一个==磁头==，==磁头==通过硬件==连接到主杆==上，==磁盘==始终进行==同向**固定速度**==旋转，而==磁头==沿着==半径方向**直线**运动==
  - 一个==盘面==可以划分成多个==同心圆==，每个圈就是一个==磁道==，而==磁道==又会被分成一个个==扇区==，最内侧扇区==面积==最小，因此数据==密度==最大
    - ==磁道==按==由外向内==进行编号，从0开始
  - 垂直来看，对应编号的磁道构成一个空心圆柱体，叫做==柱面==，而==磁头==就固定在某一个==柱面==上，==磁头==移动==寻找磁道==的过程就是在==寻找柱面==
  - 在==磁头找到==需要的==磁道==上后(叫做==寻道时间==)，==等待磁盘旋转==到所需==扇区==(叫做==等待时间==/==旋转延迟==)
    - 磁盘存取数据的时间(存取时间) = 寻道时间 + 等待时间
      - 寻道时间 远大于 等待时间，因为磁头的机械臂移动速度较慢，而磁盘转动速度很快
      - 所以在磁盘调度策略中，先移动磁头(==移臂调度==)，再进行==旋转调度==
    - 磁头移动到磁道，等旋转到对应扇区的==起始位置==就开始==读取数据==
      - 磁头读取数据依靠的是读取==介质中的正负磁性==，通过电流传输回去，因此传输时间很快可忽略不计
    - 注：==平均读取时间==是不包括==传输时间==的

- 固态硬盘 与 机械硬盘 区别
  - 物理层面
    - 没有==扇区==和==盘面==，因此不是由机械存取，而是由芯片进行存储
    - 固态的存储芯片分为两种
      - 闪存
        - 非易失性存储器，即断电后数据仍能保存
        - 基于浮栅晶体管技术，可以多次擦写
      - DRAM
        - 易失性存储器，即断电后数据会丢失
        - 基于电容和晶体管，需要不断刷新以维持数据
    - 固态缺点
      - 写入次数有限制，次数是写入固定大小的数据才算一次
- （考点）==寻道时间耗时最长==，其**调度算法**如下
  - 先来先服务 ==FCFS==：根据==进程请求访问==的==先后顺序==进行调度
    - **缺点**：低效率，因为不同请求间隔的磁道可能相隔很远

  - 最短寻道时间优先 ==SSTF==：优先调度与当前磁道==最近==的访问请求，使得寻道时间最短
    - **缺点**：会产生“饥饿”现象，即远处进程永远无法访问

  - 扫描算法 ==SCAN==（电梯算法）：工作原理类似于电梯在楼层间移动，在磁头移动过程中，按一个方向依次处理所有请求，直到到达磁盘的一个边界，然后反向移动，继续处理请求
  - 单项扫描调度算法 ==CSCAN==：与 SCAN 不同，只能单向移动，即只能从里向外，或从外向里


## 输入输出技术(I/O)

- 指的是==CPU控制==主存与==外设（I/O设备）==之间交互
- ==外设==速度慢，==内存==速度快，因此有以下几种平衡方式
  - 直接程序控制
    - 直接在==CPU==控制下，因此会==降低CPU效率==
    - 分为两种方式
      - 无条件传送
        - 外设总是准备好，可以随时接收CPU发来的输入/输出数据
      - 程序查询
        - 最傻的一种方式，可以理解为==轮询==，定期检查外设是否有数据可读，有就处理
        - 缺点：无法处理突发事件
  - ※程序中断方式(==中断技术==)
    - 可以理解为，外卖到了按铃通知
    - CPU正常执行任务，当外设需要处理数据时，会发送==中断信号==，==CPU==在收到以后，会暂停并==保存**正在执行**的程序现场==，然后处理I/O
    - 注：==不适用==于读写快速的==硬盘==，因为会==导致频繁中断==，只==适用于鼠标、键盘==这类
  - ※==DMA==技术（直接主存存取）
    - 硬盘或外部存储设备有的会写“支持DMA”，只要支持DMA，就可以在传输过程中==降低CPU使用频率==
    - 相较于上两种方式都用CPU控制，占用CPU运行效率，DMA使用==主存和外设==进行数据交互，在==**传输过程**中无需CPU干预==
      - 注：在==过程开始时==，需要==CPU向外设发送传输指令==，在==过程结束后==，通过==中断==或==轮询==的方式==得知过程结束==，下一个操作是否准备就绪
      - 实际操作由DMA硬件完成，CPU发送完指令就走了、
    - DMA传输时单独开了一条==系统总线==（DMA可以直达主存的线路），这条线将DMA的==接口==与==主存==连接
      - 注：==DMA==和==CPU==都可以==直接访问主存==，但是==DMA的优先级更高！==DMA在传输时占用系统总线，此时CPU不能使用总线
        - 因为采用DMA的设备一般都是快速I/O外设，如显卡、声卡、网卡
  - 输入/输出处理机（IOP）
    - 又称==通道==，是个==处理器**硬件**==，分担一部分CPU功能，对外设的==统一管理==，完成外设与主存之间的数据传送
      - 激活通道需要激活程序，**但是**这个程序不是由CPU执行，而是由主程序上的==通道程序==执行==激活自身==
- 总结
  - 鼠标、键盘使用程序中断的方式
  - 显卡、声卡、网卡采用DMA

## Flynn分类法

- Flynn分类法根据指令流和数据流的特征，对计算机系统分类

  - 指令流：机器执行的指令序列，==对应控制部分==（口诀：指令需控制），多指令流意味着多多个控制部分
    - 如：写一个简单的程序，计算1到10的和，这个程序的==指令流==就是==从第一条指令开始==，==逐条==执行，直到最后一条指令结束

  - 数据流：==指令流调用==的==数据序列==，包括==输入==数据和==中间==结果以及==输出==数据，==对应处理部分==（口诀：数据需处理），多数据流意味着多个处理器
    - 如：处理一个图像，图像数据从==硬盘==读取==到内存==，再==从内存==传输到==处理器==进行处理，最后处理结果再==传回内存或硬盘==，这个过程就是一个==数据流==
- 计算机分为4种类型
  - 单指令流单数据流
    - 所有指令串行执行，一段时间内，CPU只能处理一个数据流 
    - 如：早起巨型机器
  - ==单指令流多数据流==
    - 数字信号处理、图像处理等领域使用广泛 
    -  如：==GPU==、单核计算机
  - 多指令流单数据流
    - ==只是理论==，没有投入实际使用
  - ==多指令流多数据流==
    - 主流计算机使用
    - 如：Intel、AMD的==多核==处理器

## 计算机指令

- 计算机==指令==的**组成**：一条指令由==操作码==和==操作数==组成
- 指令**执行过程**：==取==指令、==分析==指令、==执行==指令

### 复杂指令集系统 CISC

- 频率：指处理器每秒钟能够执行的指令周期数。通常以赫兹（Hz）为单位
- CISC的设计目标是通过复杂的指令来减少程序的指令数量，每条指令的执行时间可能较长
- 频率高的话，意味着每秒钟能够执行更多的复杂指令
- **应用**：==Intel==、==AMD==的x86 CPU

### 精简指令集系统 RISC

- RISC的设计目标是通过简单的指令来提高执行效率。每条指令执行的操作较少，但执行速度快
- **应用**：ARM、Power为代表，如国产处理器龙芯、飞腾

## 指令流水线

- 一条指令分成好几个阶段：取指令、译码、执行、访存和写回，每个阶段由专门的硬件单元负责，指令在不同的硬件单元之间流动
  - 注：每个阶段是不同硬件执行，因此可以在第一条指令的取指令完成后，在进行译码时，让取指令的硬件继续取第二条指令，而不是等待第一条指令全部阶段完成再取第二条

- 指令流水线：指在程序执行时，多条指令==重叠进行==操作的==准并行==处理技术
  - 准并行：不是起头并进，所以不是真正的并行
  - 简言之就是：==不同部件==在==同一时刻==执行==各自工作==

- 指令流水线相关概念
  - 流水线==周期==：==执行时间最长==的一段

  - 流水线==执行时间==：`第1条指令执行时间 + (指令条数 - 1) * 流水线周期`

  - 流水线==吞吐率==（TP）：`总指令条数 / 流水线执行时间`

  - 流水线==加速比==（S）：`不使用流水线总执行时间 / 使用流水线总执行时间`

- ==流水线执行时间==计算公式
  - ==第1条==指令==执行时间==就是流水线==建立时间==

  - 计算公式：第1条指令执行时间 + (指令条数 - 1) * 流水线周期

    - 理论公式：`(t1 + t2 + ... + tk) + (n -1) * t`
      - `k`：表示第一条指令的步骤
      - `t`：流水线周期
      - 考试默认使用公式
    - 实践公式：`k * t + (n - 1) * t`
      - `k * t`：表示第一条指令所有步骤都按执行时间最长的步骤的时间累加，又有k个步骤，因此是 步骤数 * 周期时间
      - 理论公式求不出再使用实践公式

  - 流水线==吞吐率==（TP）计算公式
    - 基本公式：TP = 指令条数 ÷ 流水线执行时间

    - ==最大吞吐率==：`TPmax = 1 / t`
      - 公式推导见书上
      - `t`：流水线周期
  - 流水线==加速比==（S）
    - S = 串行执行时间 / 并行执行时间
      - 串行：即不用流水线方式，一条指令执行完再执行下一条
      - 并行：即流水线方式，前一条指令执行第二步时，第一步的硬件继续执行下一条指令的第一步

## 冯·诺依曼结构与哈佛结构

- 冯·诺依曼结构
  - ==指令==存储器和==数据==存储器==合并==在一起的==存储器==结构
  - 用途：PC处理器，如英特尔i7处理器
  - 总线：指令和数据都用同一条数据总线传输
- 哈佛结构
  - 指令和数据==分开存储==的存储器结构
    - 分开存储使其可以并行读取，有==较高==数据的==吞吐率==
  - 用途：嵌入式系统处理器（DSP）
    - DSP是==数字信号==处理器
  - 总线：有四条总线，==指令==总线、==数据==总线、==地址==总线、==控制==总线

- 总结
  - 最主要的区别在于如何处理数据
    - ==冯·诺依曼==结构中，指令和数据==存储在一起==，CPU==只能执行一条==指令
      - 因为需要等待指令和数据都被加载到CPU当中
      - 指令和数据存储在一起，指令也可当作数据一样修改，即程序可以动态修改自身代码逻辑，==所以容易遭到病毒攻击==
      - 优点是易于实现和设计
    - 而==哈佛结构==中，指令和数据并不存储在一起，CPU可以==同时访问==指令和内存，因此可以执行多条指令
    - 简单来说就是，冯·诺依曼是串行，哈佛结构是并行
- 拓展知识
  - （考点）==FPGA结构==
    - 是一种==可编程逻辑门阵列==，即**电路**结构，不是体系结构
    - **优点**：相比于GPU、DSP，FPGA具有高度的==并行处理能力==和==低延迟==特性
    - **应用**：嵌入式、通信领域，以及需要高效定制化硬件加速的场景
  - GPU结构
    - 特殊类型的处理器，具有数百、数千内核，可并行运行大量计算
    - **应用**：深度学习、机器学习
  - DSP
    - 专用于==实时数字信号==处理，通过饱和算法处理溢出的问题，乘积累加运算提高矩阵运算的效率
    - **应用**：高速信号采集设备

## 总线

- 英文名叫Bus，意为公共汽车

- 广义上分为
  - ==内部==总线：芯片与处理器之间通信的总线

  - ==系统==总线：==板级总线==，用于计算机内各部分之间连接

  - ==外部==总线：设备一级总线，微机和外部设备的总线

- 细分为
  - 数据总线（DB）
    - 通常是==双向==，通过数据总线，CPU可从内存或外设==读取==数据，也可将内存数据==写入==内存或外设
    - 总结：传输数据的
  - 地址总线（AB）
    - ==单向==
    - 管理RAM中存储的数据地址，传输CPU发出的地址信息
  - 控制总线（CB）
    - ==每条线是单向==，且方向==固定==，但==总体==来看是==双向==的
    - 传输控制信号、时序信号、状态信息
- 总线特性
  - 共享
    - 总线上挂载多个部件，通过总线进行信息交换
  - 分时
    - ==同一时刻==，只允许==一个==部件向总线==发送==信息，**但**允许==多个==部件同时从总线==接收相同==的信息
- 根据数据线数量分
  - ==串行==总线
    - 只有==一条双向==，**或**==两条单向数==据线
    - 适合==长距离==传输
    - 单工：串行总线只能实现发送或接收功能
      - 例：打印机，只能接收
    - 全双工：既能发送又能接收
      - 例：电话
    - 半双工：能==轮流==实现发送和接收
      - 例：对讲机
  - ==并行==总线
    - 有==多条数据线==，效率高，但是可以理解为异步，数据线长由于延迟的原因，可能会导致组装收到的数据异常，因此一般用于==近距离==传输

## 加密技术

### 对称加密技术

- 指信息发送和接收方都用同一密钥加密和解密数据
  - 可以理解为token
  - 应用：指纹锁、PIN码锁、登录的账号密码

- 加密过程：明文 + **加密**算法 + 私钥 = 密文

- 解密过程：密文 + **解密**算法 + 私钥 = 明文
- 优点
  - 算法公开，加密和解密速度快
  - 适合对==大量数据==进行加密

- 缺点
  - 加密==强度==不够
  - 密钥==管理==困难

### 非对称加密技术

- 使用==一对==密钥，即==公钥==和==私钥==，成对出现，用==公钥/私钥==加密，用==私钥/公钥==进行解密
  - 公钥是公开的，私钥自己保存
- 优点：安全性更好
- 缺点
  - 解密和加密耗时长
  - 不适合对大文件加密

## 认证技术

### 信息 摘要算法

- 信息摘要**理解**：简单说就是==哈希函数==，将需要认证的数据生成一个==固定长度==的信息摘要，只要是相同数据，由哈希函数生成的信息摘要就是相同的
- 信息摘要**算法**：==MD5==（128位）、==SHA==（安全散列算法，160位）
- 信息摘要**存在的问题**
  - 只要双方生成的信息摘要相同，即可==判断数据有没有被篡改==
  - 但是如果发送方发送的数据和信息摘要都被改了，那么接收方就无能为力了，因此诞生出==数字签名==技术
  - 对于**大文件**是==单向不可逆==，但可以通过彩虹表，即文件列表挨个生成MD5，遍历找到对应文件
    - 不可逆：如1GB文件生成`700bit`摘要，而仅`700bit`不可能还原回1GB文件


### 数字签名

- 采用==非对称加密==
- 具有功能
  - 报文鉴别
    - 用途：证明来源，根据 签名 确定 具体发送者
  - 防止抵赖
    - 防止 发送者 否认 签名
  - 防止伪造
- **总结**：==信息摘要防篡改，数字签名防抵赖==

### 数字证书

- 通过权威机构认证，防止假冒网站
- 诞生出的机构就是==PKI公钥基础设施==

## 计算机可靠性模型（涉及计算）

- ==串联==系统
  - 假设一个系统由N个子系统组成，==当且仅当==所有子系统都正常，系统才能正常工作
    - 子系统==可靠性用Rn==表示
  - 公式：R(系统可靠性) = R1 * R2 * ... * Rn
- ==并行==系统
  - 同样由N个子系统组成，==只要==有一个正常，系统就能正常工作
  - 公式：R = 1 - (1 - R1) * (1 - R2) * ... * (1 - Rn)
    - 公式的意思是，每一个子系统不可靠性相乘，再用1减去不可靠性，即得可靠性
- （**考点**）可靠性相关概念：题目直接出英文单词
  - 平均无故障时间 ==MTTF== = `1 / 失效率`
    - MTTF：Mean Time To Failure
  - 平均故障修复时间 ==MTTR==  = `1 / 修复率`
    - MTTR：Mean Time To Repair
  - 平均故障间隔时间 ==MTBF== = `MTTF + MTTR`
    - MTBF：Mean Time Before Failure
  - ==系统可用性== = `MTTF / (MTTF + MTTR) * 100%`

## 计算机系统概述

![计算机系统概述.png](https://github.com/hjxool/static-resource-save/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0.png?raw=true)

## 存储器（计算机硬件）

- 利用半导体、磁、光等介质做成的存储数据的设备，根据硬件结构可分为：SRAM、DRAM、Flash等
- 按 ==与处理器的物理距离== 可分为4类
  - 片上缓存
    - **处理器核心内**直接集成的缓存，一般为==SRAM==结构，容量较小，一般为16KB~512KB
  - 片外缓存
    - **处理器核心外**的缓存，需要经过交换互联开关访问，略大一点，256KB~4MB
  - 主存（==内存==）
    - 通常采用==DRAM==结构，以独立芯片存在，通过总线与处理器连接，依赖充电维持其中数据（即断电丢失数据），容量在数百MB~数十GB
  - ==外存==
    - 即硬盘、磁盘等，访问速度慢，容量大，断电后能保存数据

## 计算机软件

![计算机软件.png](https://github.com/hjxool/static-resource-save/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6.png?raw=true)

### 中间件分类

![计算机中间件.png](https://github.com/hjxool/static-resource-save/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E9%97%B4%E4%BB%B6.png?raw=true)