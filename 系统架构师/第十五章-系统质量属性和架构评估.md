## 层次架构风格

### C/S架构 和 B/S架构

- 三层**C/S**架构**关键**在于==各层之间的通信效率==
- 三层**B/S**架构
  - 将客户端变为设备上的浏览器，将应用服务器变为网络上的WEB服务器，因此也称为0客户端架构
  - **优点**：不用下载客户端，在任意终端都可以访问，使用==方便==
  - **缺点**
    - 浏览器运算能力有限，==服务器压力大==
    - 浏览器的==安全性差==
    - ==查询速度==比 C/S架构 差，因为浏览器所有数据在服务器上， C/S架构 部分数据在本地（浏览器的缓存完全比不过 C/S架构）
    - 数据提交一般以页面为单位，如用户填写表单时，整个页面的数据会被打包成一个请求发送到服务器进行处理，并刷新页面，因此动态交互性不强
- **混合架构风格**
  - **内外有别**模型：企业内人员使用 C/S ，外部人员使用 B/S
  - **查改有别**模型：查询时用查询效率较高的 B/S ，修改时用修改效率较高的 C/S
  - 开发成本高，实现困难

### 富互联网应用架构 RIA

- 解决 B/S架构 问题
  - **本质**：是0客户端，如==小程序==，其实就是软件内缓存页面，避免像浏览器那样每次重新加载
  - **优点**
    - 结合了 C/S架构 反应==速度快==、==交互强==的优点
    - 与 B/S架构 ==易于传播==的特点
    - 简化并改进了 B/S架构 的交互，将数据缓存在客户端，从而达到比 HTML ==响应速度快==，不用频繁访问服务器

### MVC架构

- 分为三层

  - **模型层**（Model）
    - 作用：处理==数据==
  - **视图层**（View）
    - 作用：将==页面呈现==给用户，==接收输入数据==
  - **控制层**（Controller）
    - 作用：页面和数据之间，处理页面==逻辑==和交互

- **缺点**：模型层 可以将数据直接交给 视图层，存在风险，如用户信息没经过过滤直接展示在视图层，应该由控制层来传递两层之间的交互

  ![MVC架构.png](https://github.com/hjxool/static-resource-save/blob/main/MVC%E6%9E%B6%E6%9E%84.png?raw=true)

### MVP架构

- 将 MVC架构 中的 控制层 变成了 ==呈现层==（==Presenter==），完全==隔绝 视图层 和 模型层 之间的联系==

  ![MVP架构.png](https://github.com/hjxool/static-resource-save/blob/main/MVP%E6%9E%B6%E6%9E%84.png?raw=true)

### MVVM架构

- 类似 MVP架构 ，但是将 呈现层 换成了 ==ViewModel==层，都是为了分离 视图层 和 模型层 ，实现==双向绑定==，目前只在前端框架中使用这个理念，没有应用到前后端服务器场景中
  - 与 **MVP架构 区别**
    - **MVP**：数据绑定是手动的，Presenter需要明确地将数据传递给View层，并且View层需要手动更新UI
      - 如，React
    - **MVVM**：数据绑定是自动的，View层通过数据绑定机制直接与ViewModel的属性进行绑定，一旦ViewModel中的数据发生变化，View层会自动更新UI
      - 如，Vue
- **优点**
  - 低耦合：视图层 独立于 模型层 变化和修改，视图变化时，数据可以不变，数据变化时，视图可以不变，且ViewModel可以绑定不同视图
  - 可复用：可以把一些视图逻辑放在ViewModel中，让多个视图层复用这段视图逻辑
  - 独立开发：开发专注业务逻辑和数据开发，设计专注页面设计

## 面向服务的架构风格 SOA

- SOA 是一种==粗粒度==、==低耦合==架构，粗粒度说明它可以单独部署、运行，低耦合说明它每个构件隔离程度高
  - 服务由以下组成
    - 封装的通用方法
    - 统一的语言格式
    - 安全防护、异常处理
    - 业务逻辑层
    - 数据访问层
    - 数据管理：SQL等

- SOA 不仅是开发方法，还具有管理优势
  - 管理员可以直接管理开发人员所构建的多个服务
    - 如一个应用对应一个服务
  - 多个服务通过 ==企业服务总线（ESB）==提出服务请求
    - 即服务不能直接通信，而是通过总线进行传递，总线连接所有服务

- SOA **目标**：让服务==最大化复用==

- SOA **特征**
  - 随时可用
    - 服务请求及时响应
  - 粗粒度接口
    - 粗粒度：只专一提供一种特定业务功能
    - 细粒度：构件方法
  - 服务分级
  - 低耦合
    - 服务使用者和服务提供者分离
  - 可复用的服务及接口
  - 标准化接口
    - **WSDL**
      - 是一种**基于XML**的**语言**，用于**描述**Web**服务**及其**功能**。它定义了服务的接口、操作、消息格式以及服务的访问地址等信息
    - **SOAP**
      - 是一种基于XML的**协议**，用于在网络上**交换**结构化**信息**。它通常用于Web服务之间的**通信**
    - **XML**
      - 是一种**标记语言**，用于**描述数据**。它具有自描述性和可扩展性，广泛用于数据交换和存储
  - 支持各种消息模式
  - 精确定义的服务接口

- **基于服务的构件** 与 传统构件 的**区别**
  - 服务构件 是==粗粒度==
    - 传统构件 一般是细粒度
  - 服务构件 是**标准接口**，主要是**WSDL接口**
    - 传统构件 是具体API形式
  - 服务构件 实现与语言无关
    - 传统构件 绑定某种特定语言
  - 服务构件 可以通过构件容器提供Qos的服务
    - 传统构件 完全由程序控制
    - **构件容器**：是一个**运行环境**，它管理和支持这些服务构件，并提供一些额外的功能，比如事务管理、安全性、负载均衡等
    - **Qos**：保证服务质量而提供的一系列技术和机制
      - 如，企业网络中，QoS服务可以优先处理视频会议和VoIP电话的数据包，确保这些实时应用的质量，而将文件下载和邮件传输等非实时应用的数据包放在次要位置处理

- SOA **关键技术**

  ![SOA关键技术.png](https://github.com/hjxool/static-resource-save/blob/main/SOA%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF.png?raw=true)

  - **描述服务**：负责服务的描述，通常使用WSDL（Web服务描述语言）来描述服务的接口、方法、参数等信息