## 架构师内容关联与区别

- 在学习系统架构师内容时，能见到非常多系统设计，它们有什么区别？
  - **信息系统方法论**
    - 属于**最顶层**，它是一个**宏观**的概念，指导如何从整体上去规划和设计一个信息系统，包含了人员管理等方面，强调的是系统的整体性和**业务价值**
    - 如，要建设一个企业的ERP系统，信息系统方法论会告诉我们从需求分析、系统设计、实施到维护的**整个过程**
  - 软件工程中的**系统设计**
    - 属于**中层**的设计，专注于**开发过程**，涵盖了**需求分析**、**设计**、**编码**、**测试**、**维护**等各个阶段
    - 如，设计一个电商平台，系统设计会涉及到用户模块、商品模块、订单模块等
  - 本章的**系统架构设计**
    - 属于**软件工程环节中顶层设计**，从**需求分析阶段**就开始了，关注的是**如何**将系统**分解**成不同的模块，以及这些模块**如何交互**，侧重于**非功能性需求**（如性能、可扩展性、可靠性等），==不涉及功能==，在软件工程之前进行
    - 如，设计一个**分布式**系统，架构设计会涉及到如何划分服务、如何进行服务间通信、如何进行**负载均衡**等
  - **面向对象设计**
    - 属于**底层**，其中设计模式是一些常见问题的**解决方案**，而UML（统一建模语言）是一种可视化建模语言，用来表示**系统**的**结构**和**行为**
      - 设计模式：如单例模式、工厂模式
  - **数据库设计**
    - 属于**底层**，是**具体实现**层面的设计
    - 如，设计用户表、课程表、订单表等
  - **项目管理**
    - 属于 **信息系统 中的一环**，信息系统方法论涵盖了系统开发的整个生命周期，而**进度管理**则是确保这些步骤能够**按计划进行**的关键部分

## 软件架构概述

- 软件架构 指从==需求分析==到==概要设计==之间的==过渡过程==，软件架构设计好了，软件才不会出现崩溃，其实应该属于软件工程中的一个环节`需求分析 -> 架构设计 -> 概要设计 -> 详细设计`
- 设计分四个方面
  - ==架构设计==
    - ==最高层次==的设计，关注系统的整体结构和高层次的==设计决策==，决定系统的主要组件、==模块==之间的==关系==，以及==技术栈==的选择
    - 如，建一个大楼，架构设计就相当于决定大楼的框架、结构和主要功能区的布局
  - 软件工程中的==概要设计==
    - 仅次于 架构设计 的==高层==设计，在 架构设计 之后进行的，进一步==细化==系统的==设计==，==描述==每个==模块==的==功能==和接口，但还**不会涉及**到**具体**的**实现**细节，决定系统的功能划分和==模块==之间的==交互==
      - 注：关系 和 交互 不一样，关系 指布局，交互 指如何交换数据
    - 如，大楼的设计图纸
  - 软件工程中的==详细设计==
    - ==最具体==的设计，对每个模块进行详细的设计，详细描述每个模块的内部结构、数据结构、算法和流程
    - 如，大楼的施工图纸，详细设计会具体到每根钢筋、每块砖的位置
  - ==数据库设计==
    - ==针对数据==的具体设计，贯穿于上述各个设计阶段，包括概念设计、逻辑设计和物理设计
    - 如，建一个图书管理系统，数据库设计就会确定图书、读者、借阅记录等实体，以及它们之间的关系
- 具体内容见书P~299~

## 构件

- **定义**：是系统中可==独立部署==、可==复用==、具有明确==接口==和功能的==模块化单元==

  - 可以理解为架构中的**模块**、**微服务**中的服务、引入的外部**库**

- （**考点**）构件==特性==：可复用性、标准化接口、独立性、可组装

- 构件的**组装方式**

  ![架构设计1.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A11.png?raw=true)

- ==服务==和==构件==的**区别**
  - 服务
    - 侧重功能，即==能否单独使用==
    - 提供==特定功能==
    - 通常可以==独立访问==
    - ==通过网络==访问
    - 常用于==面向服务的架构==（SOA），如微服务架构
      - SOA：面向服务的架构，将系统的功能模块化为独立的服务，服务可以通过网络进行调用和组合
  - 构件
    - 侧重结构，即==能否组成更大的系统结构==
    - 是软件系统的==组成部分==
    - 是==低耦合==、==可复用==
    - 常用于==组件化开发==
      - 组件化开发：将功能划分为独立的组件，提高代码的可维护性、可扩展性和复用性

- 构件标准有三种流派（**考点**：选择题）
  - ==EJB==
    - **无状态会话Bean**：不保存客户端的状态
      - 如，电商网站，用户下单的时候调用一个无状态会话Bean来处理订单，这个Bean处理完订单后就结束了，不会记住这个用户的任何信息
      - 注：Bean就是一个Java对象，它遵循一些特定的规范
    - **实体Bean**（最常用）：用来表示==数据库==中的数据
      - 如，用户表，每个用户对应一个实体Bean。这个Bean可以用来增删改查用户数据。现在实体Bean用得少了，更多的是用JPA（Java Persistence API）来做数据持久化
        - JPA：Java平台的一种规范，把数据库中的==表==和Java中的==类连接起来==，让你可以用面向对象的方式来操作数据库（可以理解为NodeJS中的Mongoose）
    - **消息驱动Bean**：处理==异步消息==，响应来自==消息队列==的消息
      - 如，订单系统，当用户下单后系统会发送一条消息到消息队列，然后消息驱动Bean会监听这个队列并处理订单，比如更新库存、发送确认邮件等
    - 总结：会话Bean处理业务逻辑，有状态和无状态之分；实体Bean表示数据库中的数据；消息驱动Bean处理异步消息
  - ==COM==、==DCOM==、==COM++==
    - （考点）COM是==微软公司==的
    - DCOM是COM的拓展
    - COM+是COM的应用
  - ==CORBA==
    - （考点）三个层次
      - **对象请求代理**（==ORB==）
        - CORBA的**核心**组件，负责处理客户端和服务器端对象之间的通信，类似于一个中介，接收客户端的请求并将其转发给合适的服务器对象。ORB屏蔽了底层的网络细节，使得客户端和服务器可以像本地调用一样进行远程调用
      - **公共服务对象**
        - CORBA提供的一组==标准服务==，用于支持分布式应用的开发
        - 如，命名服务、事件服务、交易服务、安全服务等
      - **公共设施**
        - CORBA定义的一组高层次的==应用==服务，旨在为==特定领域==的应用提供支持
        - 如，用户界面、信息管理、任务管理等

## 软件架构风格

- 考点：选择题（考概念）、案例分析的填空题、论文中用架构风格凸显项目
- **定义**（考点）：指描述特定系统**组织方式**的**惯用模式**，组织方式描述了系统的组成构件和构件的组织方式，惯用模式则反应众多系统共有的结构和语义
  - 风格：如日系风、哥特风，是一种==惯用模式==
  - ==架构风格==：类似 软件工程 中 面向对象 设计方法中的==设计模式==（单例模式等），只不过是==更高层次的设计模式==，是针对==特定应用领域==的惯用模式
  - 架构风格 定义了一个架构定义、一个词汇表、一组约束
    - **架构定义**：即系统的==整体结构==和==连接方式==
    - **词汇表**：包含构件、连接件类型
      - 连接件：用于连接不同构件，进行数据交换和功能调用
        - 连接件可以是==接口==（interface）或者==消息队列==
        - 如，用户管理构件需要与借阅管理构件进行交互，确认用户是否有借书权限，这时候接口可以作为连接件来使用，确保用户信息能够正确传递到借阅管理构件
    - **约束**：就像数据库设计里第一范式等约束，是对==系统设计==和实现的一些==限制==或规则，帮助==规范==系统结构和行为
- 架构风格 的==作用==
  - 就是个模板，往里面套
  - 反应了众多系统的共性：==共有结构==、==语义特性==
    - **语义特性**：指架构风格所表达的含义和行为，定义了系统在该架构风格下如何运作和交互，如，面向服务架构风格，语义特性之一是服务的自治性，每个服务都是独立的，可以独立部署和运行
  - 强调对==**架构设计**的重用==
  - 定义了用于==描述==系统的==术语表==，一组==指导==构件系统的==规则==

### 数据流 风格 类型（重点）

- **特点**是以==流==的形式处理数据，==按一定顺序从前往后执行==
- **代表**的风格有
  - ==批处理序列==风格
    - 构件之间只通过数据传递交互，==每个步骤是独立的程序==（同步执行），每一步必须在其==前一步结束后才能开始==（前者失败后者也不会进行），==数据必须完整，以整体为单位==
    - 如，电商平台每晚进行销售数据汇总，生成日报表。这种任务不需要实时处理，适合用批处理序列
  - ==管道-过滤==风格
    - 就像流水线，每个工人（过滤器）只负责一道工序，数据像流水一样从一个工序流到下一个工序，**特点**是==前一个的输出作为后一个的输入==
    - 如，视频流处理，每一帧视频数据都要经过去噪、调整亮度、加字幕等多个步骤，每个步骤由不同的过滤器完成，数据实时流动
    - 与 **批处理序列** 的**区别**
      - 批处理序列
        - 适合一次性处理**大量**数据
        - 支持**离线执行**
        - 适合**批量处理**任务
        - 数据是**整体**的
      - 管道-过滤
        - 将任务分为**多个阶段**，每个阶段逐步处理数据
        - **实时执行**
        - 适合可**拓展**、可**组合**的任务
        - 数据是**部分**，每个阶段干一部分事情


### 调用 / 返回 风格 类型（重点）

- **特点**是通过==函数调用==和返回来实现模块之间的交互，一般是**显式**的调用
  - **显式**：一个模块（比如主函数）会明确地调用另一个模块（比如子函数），并等待它返回结果，这个==过程是直接且可见==的
- **代表**的风格有
  - ==主程序/子程序==风格
    - 把问题划分成==若干处理步骤==，==主程序==、==子程序==就是==构件==，子程序==可合成为模块==，==调用过程==就是==连接件==
    - 如，计算器程序，主程序负责读取用户输入，然后调用不同的子程序来执行加法、减法等
    - **特点**是==结构简单==明了，适合==小规模==程序，但随着程序规模增大，主程序会变得复杂，难以维护
  - ==面向对象==风格
    - ==构件是对象==，==连接件是对象间交互==
    - 如，类实例化对象，再由对象调用方法，得到返回结果
    - **特点**是通过==封装==、==继承==和==多态==提高了代码的==复用==性和==可维护==性，适合==复杂系统==的开发
  - ==层次结构==风格
    - ==分层==的调用/返回风格，每一层只与==相邻层交互==，常见的层次结构包括==表示层==、==业务逻辑层==和==数据访问层==
      - 注：因为相邻层交互，且上一层调用下一层，直到底层再一层层返回给上层，所以修改某一层，一般只影响它的上层
    - 如，电商网站，表示层负责用户界面，业务逻辑层处理购物车、订单等业务逻辑，数据访问层负责与数据库交互
    - **特点**是层次==结构清晰==，职责分明，每一层==只关注自己==的任务，==便于开发==和维护
    - ==客户端/服务器==（C/S），其实属于层次结构，客户端调用服务器接口得到返回结果
      - 注：早期是两层，即客户端服、数据库服务器，且客户端处理除了数据交互以外的所有事情，所以客户端做的事情很多，称之为“胖客户端，瘦服务器”，后期又增加了应用服务器，即处理逻辑的服务器，C/S架构变成了表示层、功能层、数据层

### 独立构件 风格 类型（重点）

- **特点**是强调各个构件之间的==独立性==，每个构件可以独立开发、测试和部署，一般是**隐式**的调用
  - **隐式**：构件之间并不直接调用对方，而是==通过==某种==中介==（如消息队列、事件总线）来进行==通信==，就像JS和DOM绑定事件一样，只有触发的时候才调用，不能直接看到调用过程
- **代表**的风格有
  - ==进程通信==风格
    - 就是不同进程之间如何交换数据和信息，==构件==是独立的==进程==，==连接件==是==消息传递==
    - **构件**通常==是命名过程==
      - 命名过程：每个进程（或构件）都有一个唯一的标识符（名字），通过这个名字，进程之间可以相互识别和通信，即PID

    - **消息传递**的方式有==点对点==、==异步==、==同步==、==远程方法调用==
    - 如，多线程文件下载器，一个线程负责下载，另一个负责监视下载进度，两线程需要通过进程通信来共享下载状态，以便监视线程显示下载进度

  - ==事件驱动==风格
    - 行为是==由事件触发==，并不由构件直接调用方法，构件中的方法在一个或多个事件中注册，当事件触发时，系统会自动调用这个事件中注册的所有方法
    - 如，前端DOM绑定事件

- **优点**：方便维护和复用
- **缺点**：构件只能被动的控制

### 虚拟机 风格 类型（重点）

- **特点**是在某一套规则上==运行另外一套规则==，使用者基于这个规则开发构件，能够==跨平台==适配
- **代表**的风格有
  - ==解释器==风格
    - 包括==解释引擎==、**被解释**==代码的存储区==、记录解释引擎当前==工作状态==的==数据结构==、记录源代码被解释==执行进度==的==数据结构==
    - 如，VSCode中语法高亮
  - ==基于规则的系统==风格
    - 包含==规则集==、规则==解释器==、规则/数据==选择器==、工作==内存==，一般用在人工智能、DSS这类高大上的系统
      - 规则解释器：解释规则的意思
      - 规则/数据选择器：选择哪一个规则，根据规则选哪个数据
      - 工作内存：是完整的系统，需要在内存中执行
    - 如，决策支持系统DSS
    - **适用于**
      - 根据一组==事先定义的规则==或条件来控制系统的行为
      - 灵活的业务规则和决策逻辑

### 数据共享(仓库) 风格 类型（重点）

- **特点**是强调系统中的多个构件通过==共享数据==来进行协作和通信，**核心**在于数据的==集中存储==和==共享访问==
- **代表**的风格有
  - ==仓库==风格
    - 将数据存储在数据库中，各个组件可以从仓库中读取和写入数据，组件之间通过数据库进行通信和协作
    - 如，天气预报系统，气象传感器将数据写入共享的数据仓库，天气预报应用定期查询仓库，以获取最新气象信息并生成预测
  - ==黑板==风格
    - 多个独立的组件称为“专家”，==共享一个公共存储区==（黑板），组件根据黑板上信息进行推断和决策
    - 如，医学诊断系统，包括放射科、内科等，每个专家可以根据患者诊断情况，向黑板提交自己的诊断信息，黑板集成各个专家的诊断，最终生成诊断结果
    - **适用于**解决复杂的==非结构化问题==
      - 非结构化问题：指没有明确的解决方案或步骤的问题，往往需要依赖经验、直觉和创造性思维来解决，而不是通过标准的算法或公式
    - 与 **仓库风格** 的**区别**
      - 仓库风格
        - 强调数据的集中==存储和共享==
        - 组件==通过==共享==仓库==来==交互==
      - 黑板风格
        - 强调多个独立组件共享一个中央==知识存储区==
        - ==集合==共享==信息==进行==决策和推断==

### 闭环控制 风格

- 有==不断调整的过程==的就是闭环控制风格
  - 如，空调不会设置某个温度就马上到达该温度，而是监测室内温度，来变化输出空调温度
- 定义：用来操作==物理系统==时，软件和硬件形成一个==反馈循环==，通过接受一定的输入，确定一系列输出，最终达到新的状态
  - 物理系统：由物理实体组成的系统，如电路系统
- **适用于**==嵌入式系统==

### C2结构 风格

- 只要看到有描述顶部、底部、连接件相连，就是C2结构风格

- 构件通过连接件绑定在一起运作，其规则如下

  - ==构件==之间==不能直接相连==，必须通过连接件，并且==连接件在构件底下==
  - **一个**连接件可以连接**任意数目**构件
  - 连接件之间连接时，必须由一个的底部连接另一个的顶部

  ![架构风格-C2.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-C2.png?raw=true)

### 架构风格总结

![架构风格-总结.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-%E6%80%BB%E7%BB%93.png?raw=true)

## 软件架构复用

- **软件产品线**：是==**一组共享**核心资产的**软件系统**==，这些系统通过预定义的方式进行定制和组合，以满足特定市场或任务的需求
  - 软件产品：即软件系统
  - 线：指多个产品
  - 例：假设你是一家生产手机操作系统的公司。你有一个基础的操作系统内核，这个内核可以用在不同品牌和型号的手机上。为了适应不同的手机，你可能会在这个基础内核上添加或修改一些功能，比如不同的用户界面、不同的预装应用等等。这些不同版本的操作系统就是你的“软件产品线”
- 软件架构**复用的时机**包括
  - **机会复用**
    - 特点：==没有计划==
    - ==开发过程中==，只要发现可复用的资产就进行复用
      - 资产：包括需求、架构设计、测试、人员等所有要素
  - **系统复用**
    - 特点：==有计划==、有组织的复用
    - ==开发之前==，规划、决定哪些需要复用
- **复用的过程**
  1. 首先盘点哪些资产可复用，获取这些资产，并存放在==构件库==
  2. 管理构件库
  3. 根据需求，选择可复用资产使用

## 特定领域架构 DSSA

- 即某个特定领域量身定制的架构，里面预先包含了==这个领域常见的需求和解决方案==。这样做的好处是，开发人员可以在这个基础上进行==扩展和定制==，==快速开发==出符合特定需求的软件系统
  - **关键字**：领域参考==模型==、参考==需求==、参考==架构==
- DSSA 分为两类
  - **垂直**领域
    - 在==特定领域通用==的架构设计
    - 如，电子病历系统、医院信息系统
  - **水平**领域
    - ==通用场景==使用的架构
    - 如，收费系统、登陆模块
- DSSA **基本活动**（同信息系统设计的前几个步骤）
  1. 领域**分析**（需求分析）
     - 目标：==获得==领域==模型==（需求）
  2. 领域**设计**（架构设计）
     - 目标：==获得==特定领域==架构==设计
     - 有以下几个步骤
       1. 定义领域范围：确定用户需求
       2. 定义领域特定的元素：建立字典、归纳术语
       3. 定义领域特定的设计和约束
       4. 定义领域模型和架构
       5. 产生、搜集可复用的模块
  3. 领域**实现**（编码）
     - 目标：==开发具体的==信息系统==软件==
- 参与 DSSA 的**角色**
  - 领域**专家**
    - 该领域内有丰富经验的人员
  - 领域**分析人员**
  - 领域**设计人员**
  - 领域**实现人员**
- 进行特定领域开发，每个工程师对应的具体工作
  - `领域架构师 -> 领域开发环境`
    - 领域开发环境：架构师总结出该领域通用的架构设计
  - `应用工程师 -> 领域特定的应用开发环境`
    - 领域特定的应用开发环境：工程师将其更具体化，设计出各种功能模块
  - `操作员 -> 应用执行环境`
    - 应用执行环境：操作员部署和上线应用，进行运维

## 基于架构的软件开发 ABSD

- **特点**是==先设计==好系统的==架构==（即还没开始需求分析），再在这个架构的基础上进行详细设计和实现

  - **关键字**：==架构驱动==、==递归的==
  - 强调==业务==、==质量==、==功能组合==，来**驱动**架构**设计**
  - 强调==视角==、==视图==。来描述**架构**
  - 强调==用例==，来描述**功能需求**
  - 强调==质量属性**场景**==，来描述**质量需求**
    - 质量属性：系统在运行时表现出的非功能性特性
      - 如，性能、安全性等
    - 质量属性场景：通过具体的场景来明确系统在面对各种情况时的表现
      - 如**性能质量属性场景**：
        - **刺激源**：用户
        - **刺激**：发起一个搜索请求
        - **环境**：系统在高负载下运行
        - **工件**：搜索模块
        - **响应**：搜索模块返回搜索结果
        - **响应度量**：搜索结果在2秒内返回

- ABSD **基础**

  - ==功能的分解==：知道有哪些具体的功能
  - ==通过选择架构风格来实现质量和业务需求==：选择通用风格决定后期工作开展
  - ==软件模板的使用==：使用可复用构件

- （考点）ABSD 开发**步骤**

  1. 体系结构==需求==：了解需求

     - 主要掌握：==标识构件==的三个步骤

     ![架构需求过程.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%9E%B6%E6%9E%84%E9%9C%80%E6%B1%82%E8%BF%87%E7%A8%8B.png?raw=true)

  2. 体系结构==设计==：架构设计

     - 将 **标识构件** 映射成==构件==，分析构件的相互作用，得到==连接件==

     ![架构设计过程.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png?raw=true)

  3. 体系结构==文档==化：编写文档

     - **产出**：架构==规格说明==、==测试==架构需求的==质量设计==说明书

  4. 体系结构==复审==：不满足则回到第2步重新设计

     - 注：不是只有这步才评审，==每一个开发步骤都有评审==
     - 注：复审 由==外部人员==承担

  5. 体系结构==实现==

  6. 体系结构==演化==：有新需求，则回到第1步，进行需求修改

     - 按需求改变架构，增删构件，使==架构可复用==