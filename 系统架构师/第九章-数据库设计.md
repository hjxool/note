## 概述

- 数据：是==数据库中==存储的==基本对象==，是==描述事物==的符号记录
- 数据的分类：文本、图像、音视频
- 数据库（DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合
- 数据库的特点
  - 可为各种用户共享数据
  - 冗余度较小
  - 数据独立性较高
  - 易拓展
- ==数据库系统==（DBS）：能够==操作==和==管理==存储在==硬件==上的==数据==的==软件==，由以下几个部分==组成==
  - 数据库：以==文件==的形式==存储==在磁盘上
  - 硬件：==外置存储设备==，如磁盘
  - 软件：操作系统、==数据库管理系统（DBMS）==和应用程序
  - 人员：就是用户，以及==数据库管理员（DBA）==
- ==数据库**管理**系统==（DBMS）的==功能==
  - 对共享数据的有效组织、管理、存取
  - 数据库建立、运行、操作、维护，数据的存储管理

## 三级模式 两级映像

### 三级模式

- 指数据库管理系统从以下几个层次管理数据
  - ==外模式==
    - 就是跟用户交互的视图层，如页面或软件上显示个人数据
    - 只显示适合用户查看的数据，如数据库表中性别用0或1表示，在视图上则是男或女
    - 不是展示表中所有字段，而是取需要的部分展示，只允许用户看到部分数据，或不同用户看到不同数据
    - 注：表的数据是存储在磁盘上的，而**视图**看到的数据是**查询出来**的
  - ==概念模式==
    - 又称为==模式==、==逻辑模式==，在试题中看到要知道是概念模式
    - 开发人员设计表的蓝图，不是数据库里的具体的表，是抽象、语义化的描述表中应该有的字段和功用，如`students`表，里面有学生的学号、姓名、性别等
    - 跟Excel表格一样，只不过除了要设计列，还要限制每列的数据类型、长度等
  - ==内模式==
    - 又称为==物理模式==、==存储模式==
    - 就是存储在硬盘中的文件，类似Excel文件，在概念层，开发人员使用表的形式操作表文件

### 两级映像

- 因为三级==模式==都是==相互独立==，所以映像就是为了联系各层模式，体现了各层独立性和隔离性
  - ==逻辑独立==性
    - 外模式和概念模式之间的映像体现了==逻辑独立==性。即==逻辑表的修改不会影响外层视图==
    - 如：原本一张表中有“库存”、“销量”这两个字段，外模式（视图）展示的“库存”和“销量”这两个字段，并**不会随**“库存”或“销量”这两字段被**分开存到不同表**中而**显示异常**
  - ==物理独立==性
    - 概念模式和内模式之间的映像体现了==物理独立==性。即==修改了内模式不影响概念模式和外模式==
    - 如：把内模式文件的`.xls`改为`.xlxs`，或者把数据库从MySQL改为Oracle，对外模式视图和概念模式是没有影响的

## 数据库设计

- 分为以下几个步骤进行
  1. ==需求分析==（考点）
     - 产出==数据流图==、==数据字典==、==需求说明书==
     - 如：顾客是做烧烤的，想要一套财务管理系统，沟通时要确定他会**用到哪些**数据、要用这些数据**做什么**，想**得到哪些**数据，最后得出==需求说明书==
  2. ==**概念**结构设计==（考点）
     - 产出==E-R图==，即实体-联系图，也叫==概念模型==
     - 注：2~4步骤数据概念层面的设计
     - 概念设计阶段有以下几个步骤
       1. 分解出有哪些模块
       2. 设计模块的E-R图
       3. 合并模块E-R图为总E-R图
          - 合并时可能会遇到==属性冲突==（考点），即同一属性可能存在于多个模块，如学生表，有学生姓名，还有个班级表，里面有学生姓名，课程表，里面有学生姓名
          - 合并时还可能遇到==命名冲突==（考点），即**相同意义**的属性，在不同模块的E-R图中有**不同**的**命名**，或**命名相同**的属性，在不同E-R图中有**不同含义**，如学生表中，学生ID叫学号，在班级中又叫学生名
          - 合并时可能会遇到==结构冲突==（考点），即同一实体对象在一个模块中属性有5个，在另一模块中有8个属性，没有统一标准。如学生表在模块A中有3列属性，在模块B中有8列属性
  3. ==**逻辑**结构设计==
     - 产出==关系模型==，即==表结构蓝图==
  4. 物理设计
     - 确定数据分布、存储结构、访问方式，即==选用哪种数据库==、数据库需要不需要专门的备份、访问方式、存储层级结构等
  5. 数据库实际开发
     - ==实际开发数据库中表==
  6. 数据库运维
     - ==改BUG==、==调整表结构==等

## 数据模型

### 概念模型（考点）

- 就是E-R图

- E-R图

  ![E-R图.png](https://github.com/hjxool/static-resource-save/blob/main/E-R%E5%9B%BE.png?raw=true)

  - 强实体：对应一张表，如员工表示有一张表

  - 弱实体：强实体中的具体分类，如经理不是一张单独的经理表，而是员工表中员工，只不过经理在员工表中的`Job`属性值为经理

    - 注：简单来记忆就是面向对象中的继承，弱实体依赖于强实体而存在

  - 菱形：动词，表示关联关系，如经理和超市，经理 管理 超市

  - 数字或`*`号：表示1对1、1对多等对应关系，如员工和部门，员工 所属 部门，且员工和部门属于1对多的关系

    - 注：`*`号、`m`、`n`都表示多个

  - 椭圆（一般题目中没有）：表示属性，用于描述实体中有哪些属性

    ![E-R图2.png](https://github.com/hjxool/static-resource-save/blob/main/E-R%E5%9B%BE2.png?raw=true)

  - 实体集：就是表，比如学生表，里面每个学生就是实体

### 关系模型（考点）

- 就是表结构，跟Excel表一样

  ![关系模型图.png](https://github.com/hjxool/static-resource-save/blob/main/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%9B%BE.png?raw=true)

- 优点

  - 结构简单、清晰易懂
  - 存取路径对用户透明，从而数据独立，简化数据库开发，即没有`a.b.c`，直接取姓名等属性即可

- 缺点

  - 由于存取路径透明，查询效率往往不如非关系数据模型
    - 如用户表和朋友表，要获得一个用户的朋友关系，需要进行表连接，通过一个表查另一个表中数据，而非关系数据模型（如MongoDB），可以直接存储用户和他们的好友

### 网状模型

- 就是把E-R图中的E（实体）取出，以一对一、一对多、多对多的形式连线

### 面向对象模型

- 采用面向对象方式设计数据库，以对象为单位，对象包括属性和方法，具有类和继承
- 注：一般都是用结构化法，从顶向下设计，不会用到面向对象模型

### 数据模型 三要素

- 数据==结构==
  - 即有哪些属性、属性值类型、属性值长度
- 数据==操作==
  - 即**增删改查**
- 数据的==约束==条件
  - 即**范式**和**约束**
    - ==范式==
      - 第一范式（==1NF==）：要求每一列都是原子值，**不能有重复**的列
      - 第二范式（==2NF==）：要求**非主键**列完全**依赖**于**主键**，如学生表中，学号是主键，学生的其他属性取决于学号多少
      - 第三范式（==3NF==）：要求非主键列不能依赖于其他非主键列，如学号是主键，学生的姓名不能由学生的成绩值决定，只取决于学号

### E-R图如何转换为实体表

- 使用以下方式进行转换
  - 实体对应一个关系模型（表）
  - 实体名对应表名
  - 属性对应表的列
  - 联系对应表的码
    - 如：有`Person`、`Card`两张表
      - 如果是`1:1`（==1对1==）联系，则==互存主键==，可将`Person`中的`pid`放到`Card`中，将`Card`中的`cid`放到`Person`中，这样两张表都能找到对方；或建一张单独的表，用来存`pid`和`cid`之间的映射关系
      - 如果是`1:N`（==1对多==）联系，则在==N端加入1端==表的==主键==
      - 如果是`M:N`（==多对多==）联系，**必须**==单独建表==，建一张表`Person_Card`，里面`id`为主键，`pid`、`cid`为==外键==（见上述约束内容）==对应==`Person`、`Card`中==主键==

## 关系代数

- 简单来说就是数据库查询条件

- ==交==（==∩==）

  - 两张表取交集，结果==只保留==两张表中==相同==的记录

- ==并==（==∪==）

  - 两张表取并集，不同的部分堆叠，相同的部分只保留一个

- ==差==（==—==）

  - 求差要注意顺序！表1减表2，和表2减表1是不同的结果！
  - **表1**减**表2**：结果保留**表1有**，而**表2没有**的部分
  - **表2**减**表1**：结果保留**表2有**，而**表1没有**的部分

- ==笛卡尔积==（==X==）

  - 两张表相乘

  - 两张表中==所有列==一并==展示==，哪怕是相同列名

  - 数据相乘。表1==每一列中每一项==与表2中==对应列的每一项==数据取==交集==，如两张表各有3条记录，则结果为3 x 3 = 9 行记录

    - 注：数据相乘在数据库查询语句中，有单独的操作符`crossjoin`

  - 应用场景：如计算某球队在主客场中和各个队比赛结果

    ![笛卡尔积.png](https://github.com/hjxool/static-resource-save/blob/main/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF.png?raw=true)

- ==投影==（==Π：读作pai==）

  - 用来==筛选列==，相当于SQL语句中`select 列名1, 列名2, ...`
  - 如上图表S1求1、2列投影，写作Π~1,2~S1，其中`1,2`表示第几列

- ==选择==（==6：读作seigema==）

  - ==筛选行==，相当于SQL语句中的`where 条件`语句
  - 如上图表S1求`Sno`值等于`No0003`的记录，写作6~1=No0003~S1，其中`1 = No0003`，1表示第几列，中间是条件符号，`No0003`表示条件值

- ==自然连接==（==⋈==）

  - ==列名取**并集**==，==重复==的列==只保留一个==

  - ==数据取**交集**==

    ![自然连接.png](https://github.com/hjxool/static-resource-save/blob/main/%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5.png?raw=true)

    - 如图，表R和表S自然连接，先对列取并集，得ABCD四列，再将表R与表S中列A、C同一行都相同的记录连接在一起，得图中结果

## 函数依赖

- 给定一个X，能唯一确定一个Y，就称X决定（`->`）Y，或者说Y依赖X
  - 如，Y = X^2^，`X = 2`时`Y = 4`，X能确定Y的值，而`Y = 4`时`X = 2`或`X = -2`，Y无法确定X的值，所以称`X -> Y`
- 函数依赖又可拓展两种规则
  - ==部分函数依赖==
    - 如`A -> C`（A决定C）、`AB -> C`（A和B形成的组也可以决定C），既然A都可以决定C了，有没有B就无所谓了，这就是==部分==函数依赖
  - ==传递函数依赖==
    - 如`A -> B`、`B -> C`则`A -> C`，这就是==传递==函数依赖，**但是**！如果A等于B，就不是传递

### 函数依赖公理系统

- 就是推导公式（理论），也称阿姆斯特朗公理，了解即可
- 有以下推理规则
  - 自反律：如果属性集合 Y 属于 X，则`X -> Y`
  - 增广律：就是 自反律 的乘法，如果属性集合`X -> Y`，那么`XZ -> YZ`
  - 传递律：同 传递函数依赖，如果`X -> Y`且`Y -> Z`，那么`X -> Z`
- 由上面3条规则推理出以下几条规则
  - 合并律：如果`X -> Y`且`X -> Z`，那么`X -> YZ`
  - 分解律：如果`X -> YZ`，那么`X -> Y`且`X -> Z`
  - 合成律：如果`X -> Y`且`Y -> Z`，那么`XZ -> YZ`

## 键

- ==超键（码）==
  - 能够唯一标识一条记录的==属性==或==属性集==，即==**只要**能标识一条记录的属性组合或属性就是超键==
    - 注：可以说==主键==是从==超键==中抽取出的一小部分
  - 如学生表，包含属性：学号、姓名、性别、出生日期，超键可以是：{学号}、{学号，出生日期}、{姓名，性别，出生日期}，因为这些属性组合都可以唯一标识每个学生
- ==候选键==
  - 是==超键==的一个==子集==，去除了超键中的非关键属性，也就是说候选键中每个属性都是必须的，即==能唯一标识一条记录的就是最小属性集（属性）==
  - 如学生表，{学号}是候选键，因为它是唯一标识学生的最小属性集
    - 如果**姓名**也**不能重复**，则{姓名}也是候选键，但是{姓名，性别，出生日期}不是候选键，因为姓名已经可以是唯一标识，就不需要性别和出生日期
- ==主属性==
  - 候选键可能有多个，主属性就是==候选键的**并集**==
    - 注：还有个非主属性，即与主属性相反的概念
  - 如上例中，如果姓名不能重复，则候选键为{学号}、{姓名}，主属性则为学号和姓名
- ==主键==
  - 从候选键中选一个，作为唯一标识
- ==外键==
  - 就是用于建立表之间的关联
  - 如有一部门表`id:101, name:开发部`，又有一员工表`id:201, name:'张三', depID:101`，其中`depID`就是==外键==，用于关联部门表中的主键
- 总结
  - ==超键==包含==候选键==，==候选键==包含==主键==
  - ==主属性==则是==候选键==的并集

## 约束

- ==主键==约束（实体完整性约束）
  - 要求每一**行**数据都有一个**唯一标识**，如学号
- ==外键==约束（参照完整性约束）
  - 即用于**表之间关联**的**唯一标识**，如在课程表中，学号用于定位到学生表中具体学生，学生表中也有课程号定位到课程表中具体哪个课程
- ==唯一==约束
  - 要求某一列或某几列的值在表中是唯一的
  - 注：与**主键约束**的区别在于**唯一约束**可以有多个“主键”，即多个列的值都可以是唯一值
- ==非空==约束
  - 要求某一列的**值不能为空**，如订单表中，订单日期可以设置为非空约束，确保每个订单都有一个日期

## 范式

- 可以理解为指导思想，指导如何将==E-R图转成关系模型==

### 第一范式1NF

- ==表中字段==必须是原子值，==不可拆分==
  - 如省、市、区分为不同字段保存，不能用省字段包含市字段这样的形式

### 第二范式2NF

- 在==1NF的基础上==，要求表中非主属性完全依赖于某一候选键，简单来说就是表中不能存在==联合主键==，或者说==不能存在多个主键==

  ![第二范式.png](https://github.com/hjxool/static-resource-save/blob/main/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F.png?raw=true)

  - 如图中学号不能决定成绩，得有（学号，课程号）才能决定成绩
  - 解决办法：不符合第二范式的就要进行拆表，即对表进行分解，每个表只留唯一主键及对应非主属性。如图中拆成
    - 学生表（学号、学生姓名、所在系）
    - 选课表（课程号、学号、成绩）

- 注意！实际开发中不一定完全遵循三范式，因为拆的太零碎会损耗查找性能，所以像==多对多单独建表==进行关联，就==不会遵循第二范式==

### 第三范式3NF

- 在==2NF的基础上==，每个非主属性不能依赖其他非主属性，即==不能存在**传递**依赖，非主属性必须依赖于唯一主键==
  - 如第二范式例图中，`学号 -> 所在系`，再由`所在系 -> 系主任`，因此存在传递依赖
  - 解决办法：对表进一步分解，将存在传递的部分拆成不同表，每张表只留唯一**主键**、关联其他表用的**外键**以及其余**非主属性**

### BC范式BCNF

- 第三范式的更严格版本，要求在满足第三范式的基础上尽量避免==冗余字段==和==数据不一致==
  - 如仓库管理表（仓库ID、物品ID、管理员ID、物品数量），一个管理员只在一个仓库工作，一个仓库存多种物品，这个关系模式已经满足3NF，但是存在如下问题
    - 插入异常：如新建一个仓库，此时仓库没有物品，就无法写入管理员ID，因为写入数据时，物品和数量不能为空
    - 删除异常：仓库被清空时，物品ID、数量会被删除，而依照非空约束，仓库ID、管理员ID也会被删除
    - 更新异常：如果仓库换管理员，表中所有行的管理员ID都要修改
  - 解决办法：继续分解表。如本例中拆成仓库管理表（仓库ID、管理员ID），以及仓库表（仓库ID、物品ID、数量）

## 反规范化

### 基本概念

- 完全按照范式的话，每张表都是最小单位，实际场景可能会多次==联表查询==，==性能很低==，因此反规范化即牺牲部分规范，提高性能。反规范化本质就是扩大每张表，来提升查找性能，即牺牲空间节省时间
  - 如有学生表、教师表，页面显示教师信息时，还想带上学生信息，按照反规范化思想，就可以在教师表中存学生姓名，这样就不用联表查询
- 具体方法
  - 增加冗余列
    - 多个表中存相同列（属性）
  - 增加派生列
    - 派生列，即本表或其他表的数据通过函数计算得出，类似Vue的计算属性
    - 如出生日期，可以通过用户年龄倒推计算得出，存为一列
  - 重新组表
    - 将如果有多处需要联表查询的，则将多张表组合成一张表
  - ==水平==分割表
    - 当数据规模很大，如单张表中有一千万条记录，则将其拆成多个独立的表，比如一张表中存800条数据
  - ==垂直==分割表
    - 按列分割，如一张表中有10列，其中4列是查找时常用的，则将这4列单独放一张表

### 模式分解

- 对表进行分解，消除联合主键等混合依赖关系，一般分为以下两种方式

  - ==是否保持函数依赖==

    - 如关系模式R(A、B、C)，依赖集`(A -> B, B -> C, A -> C)`，将其拆成关系模式R1(A, B)和R2(B, C)，因为能从==子==表的依赖集==推导出父==表的依赖集，就说明是==保持==函数==依赖==的分解，反之则是不保持
    - 如关系模式R(A、B、C)，依赖集是`(A -> B, B -> C)`，将其拆成关系模式R1(A, B)和R2(A, C)，`A -> C`不能推导出`B -> C`，说明不保持依赖

  - ==有损无损分解==

    - 只拆成2个表时

      - 根据公式`R1 ∩ R2 -> R1 - R2`**或**`R1 ∩ R2 -> R2 - R1`，==R1与R2交集，能决定R1减R2**或**R2减R1，说明是无损==，反之则是有损
      - 如关系模式R(A, B, C, D, E)，拆成表R1(A, B, D)和表R2(A, E, C)，则R1∩R2得A，R1 - R2得B、D，看A能否决定B、D

    - 拆成2个表以上时

      - 使用表格求解

      ![模式分解-是否有损.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3-%E6%98%AF%E5%90%A6%E6%9C%89%E6%8D%9F.png?raw=true)

      1. 将分解的表放入初始表中，存在与初始表对应属性，则打勾，反之打叉
      2. 根据初始表的依赖集，一行行推导，能推导出的就打勾，**只要有一行**全部打勾，则是无损分解，没有一行全部打勾则是有损分解

## 并发控制

### 事务

- 有一系列操作组成，是将这一连串操作看作一个整体，这些操作要么全部成功，要么全部失败
  - 概念解释
    - ==DML==：即对数据的==增删改==操作
    - ==DDL==：对表==结构==的==增删改==操作
      - 如删除表，新增表
    - ==rollback==：数据回滚，有一个操作失败，则不保存结果
      - 如A账户扣500，B账户加500，如果B增加的操作失败，则将500退回给A
    - ==commit==：所有操作都成功，则保存所有操作结果
- 有以下重要特性
  - ==操作原子==性
    - 把==事务==，即==一组操作==看作==最小单位==，要么全部成功，要么全部失败，不可分割
    - 如银行转账，没到最后一步转账完成前，前面所有操作都是无效的
  - ==数据一致==
    - 事务发生前后，数据是一致的
    - 如银行转帐，如果事务成功，账户A减少100元，账户B增加100元，**总**金额**保持不变**；如果事务失败，账户A和账户B的金额都不变
  - ==执行隔离==
    - 事务的执行不会受到其他事务的干扰，在当前事务执行成功提交前，其他事务无法操作当前事务操作的数据 
  - ==改变持续==
    - 事务提交后，其对数据库的所有更改都会永久保存，即使系统发生故障也不会丢失

### 并发控制

- 事务是并发控制的前提，并发控制用来确保多个事务能够并发执行而不会导致数据不一致或其他问题。简单来说，就是为了防止多个用户同时操作数据库时出现冲突
- 并发控制中存在一些**现象**
  - ==丢失更新==
    - 简单说就是，因为多个事务并发操作，导致事务的==实际结果与预期不符==
    - 如T1事务读取到`a = 10`，在执行`a = a - 5`的过程中，T2事务读取`a = 10`，而不是5，并执行`a = a - 8`，T1期望得到的`a = 5`，T2期望得到的结果`a = 2`，而实际上，T1执行完后`a`已经等于5，这时T2才可接手对`a`的操作，操作完`a = -3`，而不是T2所期望的`a = 2`，T1、T2的更新都丢失了
  - ==不可重复读==
    - 在一个事务中，两次读取同一数据时，数据内容发生了变化。简单来说，就是你在==同一个事务==里，==前后==两次==读到的数据不一致==
  - ==读脏数据==
    - 如在事务T1中`a = 20`，操作`a = a + 50`，此时事务T2读取`a = 70`，而T1接着进行了rollback，实际上`a = 20`，此时T2读到的数据就是脏数据

### 封锁协议

- 因此有了给数据上锁，让事务排队执行，其他事务无法碰到当前事务正在操作的数据

- 锁的类型

  - ==**X**锁是**排它**锁（写锁）==

    - 事务**需要**==写数据时==加上锁，只==允许==当前事务的==读和写==，其他事务都==不能对该数据加任何类型的锁==，直到当前事务释放数据上的锁

  - ==**S**锁是**共享**锁（读锁）==

    - 事务**只**==读数据时==加上锁，==只允许==当前事务==读==数据，**但**==不能改==，==其他事务只能==对该数据上==读锁==，直到所有事务释放对该数据的读锁，新事务才能对该数据加其他锁

  - 可以理解为，读是共享的，但写只能一个人

  - 考点：锁的名字、什么时候加锁、加了会有什么后果

  - 封锁协议分为三级

    - ==一级封锁==协议

      - T1先修改数据加==X锁==，直到==事务结束==才释放，然后轮到T2修改，加X锁
      - 解决==丢失更新==问题
    
      ![一级封锁协议.png](https://github.com/hjxool/static-resource-save/blob/main/%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.png?raw=true)
    
    - ==二级封锁==协议
    
      - **一级封锁**的基础上，T1先修改数据加X锁，然后轮到T2读取数据，加==S锁==，==读完就释放==
      - 解决==丢失更新==、==读脏数据==问题

      ![二级封锁协议.png](https://github.com/hjxool/static-resource-save/blob/main/%E4%BA%8C%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.png?raw=true)

    - ==三级封锁==协议

      - **一级封锁**的基础上，T1**先读**取数据，加==S锁==，==事务结束==时才释放，然后轮到T2加X锁
      - 解决==丢失更新==、==读脏数据==、==不可重复读==问题
    
      ![三级封锁协议.png](https://github.com/hjxool/static-resource-save/blob/main/%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.png?raw=true)

## SQL语句

- 增删改查==关系数据库==
- SQL的主要功能（可能出一个语句考它属于什么语言）
  - 数据==定义==语言（==DDL==）
    - 用于定义**表**、索引等，可以理解为对文件目录结构的操作
    - 常见操作
      - 创建表：`create database/table/index/view 名称`
      - 修改：`alter table 表名 add/drop/modify 列名`
      - 删除：`drop database/table/index/view 名称`
  - 数据==操作==语言（==DML==）
    - 对表**数据**的增删改操作
    - 常见操作
      - 插入：`insert into values(): insert into t1 values('a', 6)`
      - 删除：`delete from..where: delete from t1 where sno=4`
      - 修改：`update ... set ... where ...: update t1 set sname='aa' where sno=3`
  - 数据==查询==语言（==DQL==）
    - **查询**表中记录
    - 常见操作（考点）
      - `select`：选择列
        - 语法：选择T1表所有列`select * from t1`
      - `from`：从哪张表
      - `where`：查询条件
        - 语法：`WHERE age > 18`
      - `group by`：查询结果按**列**分组
        - 语法：`GROUP BY grade`
        - 注意！`select`后使用了`AVG()`、`MAX()`等聚合函数，且`select`后有属性名时，须用`group by`
        - 注意！`group by`后分组名**必须**与`select`后组名相同
      - `having`：分组后的条件，通常和 `GROUP BY` 一起使用。如只想查学生人数大于 10 的年级，可以用 `HAVING COUNT(*) > 10`
        - 语法：`GROUP BY age HAVING (avg(score) > 60)`
      - `order by`：对查询结果进行排序
        - 语法：`ORDER BY age`（默认升序）
          - 如果是降序`ORDER BY age DESC`
      - `limit`：限制查询结果的条数
        - 语法：`limit startIndex, pageIndex`
          - `startIndex`：从第几项开始
          - `pageIndex`：展示多少项
      - `as`：更名运算
        - 语法：`select grade as '学号' from table`
      - `like`：字符串匹配。%匹配多个字符串、_匹配任一字符串
        - 语法：`select * from t1 where grade like 'a_'`
  - ==事务控制==语言（==TCL==）
    - 管理**事务**操作
    - 常见操作
      - 开启事务：`start transaction`
      - 事务提交：`commit`
      - 事务回滚：`rollback`
      - 设置保存点：`save point`
      - 回滚至保存点：`rollback to savepoint`
  - 数据==控制==语言（==DCL==）
    - 管理数据库权限
    - 常见操作
      - 创建新数据库用户：`CREATE USER`
      - 删除用户：`DROP USER`
      - 修改用户密码：`ALTER USER`
      - 授予用户权限：`GRANT`
      - 撤销权限：`REVOKE`
      - 创建新数据库角色：`CREATE ROLE`
      - 删除角色：`DROP ROLE`
      - 授予用户角色：`GRANT ROLE`
      - 撤销用户角色：`REVOKE ROLE`
  - 其他表操作
    - 指定某个表的字段为主键：`primary key()`
    - 指定某个表字段为外键，并关联哪个表主键字段：`foreign key()`

## 应用程序如何与数据库数据交互

- 通过框架接口访问数据库
  - 库函数接口：最底层方式，效率低，学习难度大
  - 嵌入式SQL访问接口：直接将SQL和程序代码封装到一起，类似JPA，直接通过数据库表名操作，需要嵌入式SQL的预编译器
  - 通用接口：数据库厂商提供。如JDBC、ODBC等
  - ORM访问接口（使用最多）：使用框架将对象与数据库表建立映射，使程序员直接操作对象就能修改表数据。如Hibernate、JPA等框架

## NoSQL非关系型数据库

- 何为”关系“？
  - 即表之间关联关系，如不同表之间1对1、1对多、多对多，是关系映射
  - 所以存一个系统的数据会根据范式分很多表出来，再根据表之间关系进行查询
    - 优点：安全、稳定
    - 缺点：效率较差
- ==NoSQL不保证SQL数据库中的ACID特性==，即原子性、隔离性等，也就是安全性比SQL数据库差
  - 补充：新的还有NewSQL，在NoSQL基础上，加入了比ACID更先进的特性。传统SQL也被称为OldSQL
- NoSQL分类
  - ==列式存储==数据库
    - 与传统SQL数据库相同，数据按列存储
    - 应用：分布式数据库的存储海量数据，如HBase
  - ==键值对==存储数据库（重点）
    - 以`key-value`形式存储，特点是简单、容易部署
    - 也叫==内存数据库==，==存在内存当中==，所以查询速度非常快，==提高性能==，有两个重要的数据库工具
      - **Redis**
        - 数据存放在内存中
        - 不仅是哈希表，还支持list、set等格式的数据
        - 不是所有数据都存在内存中，当物理内存用完时，可以将很久没用到的value交换到磁盘（持久化）
        - 支持多方面数据库特性，可以说是数据库系统
      - **MemCache**
        - 数据存放在内存中
        - 是个巨大的哈希表，除了键值对，还可以缓存图片、视频等
        - 只能简单的缓存键值对
  - ==文档==型数据库
    - 类似键值对数据库，但是升级版，==可以嵌套==
    - 应用：处理复杂数据时比传统键值对==存储效率高==，如**MongoDB**
  - ==图==数据库
    - 核心概念是“节点”和“边”，节点代表实体，边代表实体之间的关系
    - 应用：适合处理有复杂关系的数据，如Neo4J
      - 如社交网络，电影推荐系统，节点是用户和电影，边是用户对电影的评分。可以很容易地找到某个用户喜欢的电影，然后推荐给其他有相似喜好的用户
- NoSQL特征：==易拓展==、==大数据量==、==高性能==、==灵活==的数据模型、==高可用==
  - 高可用：系统或者服务在大部分时间内都能正常运行，不会因为故障而中断，通过冗余设计、故障切换和负载均衡等技术手段来实现
- NoSQL框架分层：数据==持久==层、==分布==层、==逻辑模型==层、==接口==层
- NoSQL适用场景：==数据简单==、==结构灵活==、对数据性能要求高、不需要数据高度一致性

## 数据库对比

![数据库类型对比.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B%E5%AF%B9%E6%AF%94.png?raw=true)

- 注1：**关系型**数据库使用ACID（原子性、一致性、隔离性、持久性）事务来保证数据的一致性，而**非关系型**数据库中只有**文档型**数据库支持**单文档**的**事务**操作，对于跨文档或者跨集合的操作，MongoDB更多的是依赖于最终一致性模型。最终一致性意味着数据在一段时间后会达到一致状态，但在短时间内可能会有不一致的情况
