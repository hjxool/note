## 软件过程

### 基本概念

- 软件开发==生命周期==
  - 软件定义
    - 即实际开发前所有事情，都属于软件定义时期，如可行性分析、需求分析等
  - 软件开发
    - 编码、测试阶段
  - 软件运维
    - 产品交给用户使用
- 软件系统文档可分为
  - ==系统文档==
    - 开发人员使用，描述怎么测试、实现等
  - ==用户文档==
    - 用户使用，告诉用户怎么用的手册
- ==软件过程==指得到软件产品进行的4个==活动==
  - P(Plan)
    - ==软件规格说明==
    - 就是计划阶段，规定软件功能和运行限制
  - D(Do)
    - ==软件开发==
  - C(Check)
    - ==软件确认==
    - 跟用户确认功能是否满足需求
  - A(Action)
    - ==软件演进==
    - 不断满足新需求
- 按软件过程活动将软件工具分为
  - 软件开发工具
    - 开发用的IDE等
  - 软件维护工具
    - 版本控制、用别人线程代码二次开发等
  - 软件管理和软件支持工具
    - 项目管理用的软件、评价软件等
- ==软件设计==四个==活动==
  - ==数据==设计
    - 即设计数据库表、表与表之间关系、数据字典等
  - ==架构==设计
    - 即功能模块，整体结构等设计
  - ==界面==设计
    - 即页面样式、布局等设计
  - ==功能==设计
    - 即各模块具体功能如何实现，如前端如何收集用户信息，后端如何处理订单

### 能力成熟度模型 CMM

- 即对**公司**==开发==软件==能力==的==分级==模型
- 考点：不同等级对应的特点
  - 初始级
    - 即开发过程杂乱无章，项目能不能成看运气，完全==依赖个人==努力和核心人物
  - 可重复级
    - 就是从初始级时，发现有一些规律可循，==有成功==项目==经验==
  - 已定义级
    - 已经能从成功的经验中定义出一些==标准==，并有对应==文档==，其他人来参照自己
      - 注意！这级只是别人**参考**你而已
  - 已管理级
    - 制定行业标准！虽然还是标准，但规定具体的细节，如铁路局规定铁轨宽度多少合规
    - 可理解为==详细的度量==阶段
  - 优化级
    - 就是管理级往上不知道怎么升了，只能说不断优化，使制定的标准越来越好，越来越棒

### 能力成熟度模型集成 CMMI

- 对CMM的进一步扩展，集成，表示它已经不仅仅局限于软件过程，还涵盖了多个工程学科领域，系统、一致的==过程改进框架==
- CMMI 两种表示方法
  - ==阶段式==模型（考点）
    - 注意！总体结构同 CMM ，**但是**==第二级和第四级有变化！==
      - CMMI 第二级是==已管理级==，CMM 第二级是==可重复级==
      - CMMI 第四级是==定量管理==，CMM 第四级是==已管理级==
  - 连续式模型

### 软件过程模型

- 同 信息系统 章节中方法论一样，就是指导思想、方法论，有多种模型，**但是**信息系统方法论涵盖范围要比软件过程大

#### 敏捷 模型

- 又称敏捷开发
- 特点
  - 适应各种需求变化，而非预设好的
  - 满足用户需求为最高优先级，不追求每个阶段都要产出
- 核心思想
  - 快速开发并发布出小型版本
  - ==迭代增量式==开发过程
- 主要方法（考点：记得名字就行）
  - 极限编程（==XP==）
    - 加强交流、从简单做起、及时反馈、实事求是
    - 将开发过程分解为一个个==小周期==
    - ==测试先行==，开始进行前先写好测试计划 
  - 水晶系列方法
    - 机动性的、个人英雄主义式，以人为中心
  - 并列争球法
    - 就是封闭式开发，每段时间(如30天)一次迭代版本，称为“冲刺”，按需求优先级实现产品
  - 特征驱动开发方法（==FDD==）
    - 构造特征、计划特征...所有都跟==特征==有关

#### 统一过程模型（RUP）

- 记忆点：==重量级过程==，类似 瀑布模型，是个重过程的开发模型
- RUP 把开发生命周期==划分为多个循环==每个循环产生一个版本，==每个循环有4个阶段==每个阶段有固定产出
  1. ==初始==阶段：定义产品视图和业务模型
  2. ==细化==阶段：确定系统的体系结构、工作计划
  3. ==构造==阶段：实现产品、测试
  4. ==移交==阶段：把产品交给用户使用
- 特点（考点）
  - ==用例驱动==
    - 需求分析、设计、实现、测试都是用例驱动
    - 用例：描述系统与用户之间如何交互，即==功能==
      - 如开发一个图书管理系统。我们可以定义几个用例，比如“借书”、“还书”和“查询图书”。每个用例都会详细描述用户与系统的交互过程
  - 以体系结构（==架构）为中心==
    - 强调在整个开发过程中，系统的体系结构起到了核心作用。体系结构不仅是系统设计的基础，还指导了开发、测试和部署等各个阶段的工作
  - 迭代与增量
    - 每次迭代只考虑一部分需求，迭代是在已完成的基础上进行，每次增加一些新功能
- （考点）==RUP的4+1视图==模型
  - 4加1，1是==测试==人员用的==用例视图==，描述测试功能流程
  - 与==用户==相关的是==逻辑视图==，描述系统有哪些功能
  - 与==开发人员==相关的是==实现视图==，描述具体如何实现功能
  - 与==系统集成人员==相关的是==进程视图==，描述开发好的系统性能如何，如吞吐率等
  - 与==系统工程师==相关的是==部署视图==，描述开发好的系统如何部署、安装


#### 瀑布 模型

- 每阶段做完==不能回滚==，适合==需求非常明确==的项目
- 阶段
  1. 可行性分析（软件计划）
  2. 需求分析
  3. 软件设计（概要设计、详细设计）
  4. 编程实现
  5. 测试
  6. 运维
- 特点
  - 同  信息系统结构化方法 ，==每一阶段==都有其==产出==，==各阶段承接上一阶段的产出==继续工作
  - 不同的是，==每一阶段==都要进行==评审==，审核过了才进行下一阶段

#### 原型化 模型

- 同 信息系统 章节的 快速原型法 ，适合==需求不明确==，边改边做的项目
- 特点
  - 实际可行
    - 画出的原型图必须是能实现的，不能夸大
  - 具有最终系统的基本特征
  - 原型图构建方便、快速

#### 螺旋 模型

- 可以理解为==循环执行==**制定计划**、**风险分析**（考点）、编程（**实施工程**）、**用户评估**这四个阶段，从而不断优化、收缩修改范围，即版本迭代，1.0、1.1版本这样持续完善
  - 考点：==**只有**螺旋模型具有**风险分析**！==看到这个确定是螺旋模型
- 适合==庞大复杂、**高风险**的项目==

#### V 模型

- 特点
  - 左边阶段，右边测试，即为每个阶段都进行测试，而不是最终再测试
  - （考点）V模型主要特点就是==测试多==
- 考点：每个阶段对应的测试，及各阶段下一阶段是什么
  1. ==需求==分析 对应 ==验收==测试
     - 可以理解为，最初提什么需求，最终验收就以什么标准
  2. ==概要==设计 对应 ==系统==测试
     - 当初概要设计了哪些模块，测试就测系统整体架构稳定性
  3. ==详细==设计 对应 ==集成==测试
     - 具体设计了哪些模型功能，就对其进行集成测试
  4. 软件==编码== 对应 ==单元==测试
     - 写完一块功能代码，就以这个功能为单元进行测试
- 适合==需求明确==、==变动不频繁==的项目

#### 增量 模型

- 类似 螺旋模型 ，是迭代进行，先开发核心模块，与用户确认后，再开发次核心模块功能，每一块都可单独发布，优先交付核心模块
- 考点：不同于螺旋模型，==每一次增量==，或者或迭代版本都可以**独立**作品
  - 如先开发了一个基本的登录功能，然后再开发用户管理功能，接着是数据处理功能，每个增量都可以独立发布和测试
  - 可以简单记为模块迭代就是增量模型

#### 喷泉 模型

- 记忆点：==面向对象==开发方法

#### 基于构建的开发模型

- 记忆点：==低代码==平台

#### 形式化 模型

- 记忆点：跟==数学==有关

## 逆向工程

- 简单说就是“拆解”别人的东西，搞明白它是怎么做出来的，==通过程序==，==还原==出E-R图等前期==设计思路==

  - 如接手别人做好的项目，现在要进行二次开发、拓展，就得逆向工程
  - 注意！逆向工程的==软件复用==，不只是程序复用，还有程序设计之初所有相关资料的复用，如文档、设计，甚至原开发人员

- 逆向工程的四个阶段

  1. 实现级（考点）
     - 仅还原出部分模块的设计，如数据库表、交互过程设计
     - 如逆向工程一个计算器程序，在实现级，通过分析源码，了解如何实现加减乘除算法，找到==程序中==定义的==变量及函数== 
  2. 结构级
     - 了解页面结构，确定哪些是主页面，以及页面见引用关系
  3. 功能级
     - 如逆向工程一个邮件系统，在功能级，分析程序逻辑，了解各模块功能实现方式
  4. 领域级（考点）
     -  还原出需求分析阶段的资料，如E-R图
     - 如逆向工程一个电子商务网站，在领域级，通过分析程序中实体关系，了解其==业务流程==

  - 注意！==领域级抽象级别最高==，完备性最低，==实现级==抽象级别最低，==完备性最高==
    -  完备性：代码完整度
    -  抽象级别：即设计理念等抽象层次的东西
    - 抽象级别和完备性相反，==抽象越高，完备性越低，抽象越低，完备性越高==

- 相关概念

  - 重构
    - 对代码的精简、优化
    - 用户无法感知
  - 设计恢复
    - 还原出设计文档、设计说明等设计的过程
  - 再工程
    - 修改已有系统，==产生一个新版本==，这是与重构最大的区别
    - 用户可以感知到
  - 正向工程
    - 就是正常开发流程，从抽象到具体实现

## 需求工程（考点）

### 需求工程分为

- 需求开发 部分

  1. 获取需求
  2. 需求分析（分析需求）
  3. 需求定义（生成规划说明书）
  4. 需求验证（确认需求，用户签字）
  5. 得到需求基线（即产品质量的基准线）

- 需求管理 部分

  - 良好的管理支撑开发质量

  1. 当需求变化时，走需求变更流程，即==变更控制==
  2. 对版本的控制
  3. 跟踪开发有没有完成需求
  4. 逆向跟踪有没有需求之外的功能被做出来 

### 需求的分类

- ==业务==需求
  - 高层想达到的==战略目标==，一般是投资人、市场部门等
    - 如胖东来想从线下业务发展到线上
- ==用户==需求
  - 已经对要做的软件有较明确要求
    - 如想要什么样的网站，支持指纹支付等
- ==系统==需求
  - ==功能==需求
    - ==具体==想要开发什么样的功能
      - 如小程序如何上架商品
  - ==非功能==需求
    - 软件==质量==
      - 比如网站的可靠性，能否支持24小时运行
  - 设计==约束==
    - 对开发的一些限制条件
      - 如银行系统，金额要保留小数点后7位

### 需求开发

#### 获取需求

- 方法
  - 用户==访谈==
    - 适合1～3人的交谈
    - 对提问者水平有要求
  - ==问卷==调查
    - 适合==用户多==的场景
    - 对问卷编写者水平有要求
  - ==采样==
    - 看到==数理统计==就是采样方法
  - ==情节串联板==
    - 就是==原型图==
  - 联合需求计划（==JRP==）
    - 就是==开会==讨论
  - 需求记录技术
    - 任务卡片、Volere白卡

#### 需求分析（重点）

- 需求分析的工作：把杂乱无章的用户期望==转化为**用户需求**==
- 需求==分析任务==
  - 绘制==数据流图==
  - 画出==界面草图==
  - ==分析==需求的==可行性==
    - 用户的需求有的是不合实际的
  - ==列出==需求的==优先级==
  - 为需求==建立模型==
    - 三大模型：
      - **功能**模型
        - 通过==数据流图==实现
      - **数据**模型
        - 通过==E-R图==实现
      - **行为**模型
        - 通过==状态转换图==实现
          - 状态转换图：如状态转换图描述售货机在不同操作下的状态变化
            - **初始状态**：售货机待机，等待用户操作
            - **选择商品**：用户选择商品，售货机进入“等待付款”状态
  - 创建==数据字典==
    - 数据字典记录了==数据元素==的名称、类型、长度、含义、取值范围等==信息==，帮助开发团队在设计和实现系统时保持一致的理解和使用
    - 如开发一个学生管理系统，数据字典中**数据项**是
      - **学生ID**：唯一标识每个学生的数据，类型为整数，长度为10
      - **姓名**：学生的名字，类型为字符串，长度为50
  - 使用==QFD==
    - 解客户的需求，并将这些需求逐步细化和分解，最终形成具体的设计和==开发要求==
    - 如开发一款新型的智能手表。首先，你需要收集用户对智能手表的各种需求，比如电池续航时间长、屏幕清晰、佩戴舒适等。然后，通过QFD，你可以将这些用户需求转化为具体的技术指标，比如电池容量、屏幕分辨率、表带材质等
- 结构化的需求分析：==自顶向下，逐步分解，面向数据==
  - 自顶向下和逐步分解与瀑布模型一样
  - 面向数据是因为有数据流图

#### 数据流图 DFD（考点）

-  图形元素：外部==实体==、==加工==、数据==存储==、==数据流==

  ![数据流图.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png?raw=true)

  - 外部实体：如用户A、某个机器
  - 加工：具体某一个功能，如登陆
  - 数据存储：可以是文件，也可以是数据库表
  - 数据流：代表数据流向

- 考点：鉴别数据流图中的问题

  - 数据的流向==必须经过加工==，即==实体必须要经过加工才能到**另一个实体**或**数据存储**==
  - ==加工==的数据，**必须**有==输出==，否则形成数据**黑洞**
  - ==加工==的数据，**必须**有==输入==，否则称之为**奇迹**
  - ==加工==的数据，==输入输出**不匹配**==，称之为**灰洞**

#### 数据字典 DD

- 弥补数据流图没有具体属性说明，数据字典为每个项做出说明，即为了==描述数据流图==
- 数据字典有以下4类条目：以学生成绩管理系统为例
  - 数据流
    - 成绩录入流：教师录入学生成绩的数据流
    - 成绩查询流：学生查询自己成绩的数据流
  - 数据项
    - 学生ID：唯一标识每个学生
    - 课程ID：唯一标识每门课程
    - 成绩：学生在某门课程中的成绩
  - 数据存储
    - 学生成绩表：存储学生成绩信息，包括学生ID、课程ID、成绩
    - 学生信息表：存储学生的基本信息，包括学生ID、姓名、班级等
  - 加工
    - 成绩录入处理：教师录入学生成绩的过程
    - 成绩查询处理：学生查询自己成绩的过程
    - 注：加工描述逻辑方法有：结构化语言、判定表、判定树

#### 需求定义

- 即==软件需求规格说明书SRS==，是所有项目相关人员对系统的约定和共同理解
- 方法
  - 严格定义（结构化定义）
    - 较难实现，因为基于对所有需求已经确认不会改变，对用户需求吃透的情况，要对做的东西有足够的经验
    - 适合==需求明确==的情况
  - 原型方法
    - 先画出原型图，然后不断迭代更新

#### 需求验证

- 就是确认需求，与用户一起确认需求无误，对 说明书SRS 进行评审和测试
  - 需求评审，分为
    - 正式评审：所有人拉一起开会
    - 非正式评审：找到对接人确认
  - 需求测试
    - 构想使用场景，测试需求是否满足，不涉及代码
- 需求验证 通过后，用户签字确认，作为验收标准，此时，说明书SRS 就是==需求基线==，不再可以随意更新，如需更改，必须走变更流程

### 需求管理

#### 需求变更

- 有风险的做法
  - 没有足够人员参与
  - 不停有需求增加
  - 模棱两可的需求
  - SRS 过于精简

#### 需求跟踪

- 跟踪每个==需求==与==系统元素==之间的==联系==，分为两种形式
  - 正向跟踪：用户的原始需求是否都实现了，用于==判断有没有缺漏==
  - 反向跟踪：用于==判断有没有多实现的功能==
- 使用方式
  - 列一张用例和需求表，见书P~242~
  - 一行中有打叉的，说明有多实现的功能
  - 一行中全部打叉，说明对应需求没有被实现

## 系统设计

### 业务流程 设计

- 流程图表示方法
  - 程序流程图（==PFD==）
    - 就是常见的流程图，从开始到结束，中间用图形表示执行的各种操作
    - 关键词：==不涉及程序语言==、容易掌握
  - 输入输出图（==IPO==）
    - 就是数据流图，描述每个模块的输入、输出、加工
    - 关键词：==数据流==
  - ==N-S图==
    - 见书P~246·~右图
    - 容易表示嵌套、层次关系，不适合复杂程序设计
    - 关键词：==不适合复杂程序==
  - 问题分析图（==PAD==）
    - 见书P~246·~左图
    - 关键字：==结构化==
- 业务流程设计分类
  - 业务流程管理（BPM）
    - 关键字：==改善==
  - 业务流程重组（BPR）
    - 关键字：==**彻底**重新设计==
- 流程管理从以下几层依次进行
  1. 规范流程：让流程更加规范
  2. 优化流程：优化掉多余的部分
  3. 再造流程：直接重新设计流程

### 系统 设计

- 前述了如何获取需求、画出流程图，接下来系统设计就是==告诉下阶段的人该**怎么做**==

- ==方法==

  - 结构化设计
  - 面向对象设计（重点，后续章节具体描述）

- ==主要内容==

  1. ==概要==设计
     - 设计**大纲**，描述系统大概有哪些模块和功能
     - 产出：==模块结构图==、==概要说明书==（大纲介绍）
     - 概要设计 遵循以下几个原则
       - 抽象化：把复杂的问题分成更小的部分，就像递归
       - 自顶向下，逐步进行：先构想整体的结构，再逐步添加细节
       - 信息隐蔽：可以理解为封装，只暴露必要信息给其他模块，降低模块间耦合度
       - 高内聚，低耦合
         - 高内聚：==模块内==的功能和数据是否紧密关联，没有分散
           - 如模块A的一个函数功能不应在模块B中又实现一遍
         - 低耦合：降低==模块之间==的关联
           - 如不使用同一个数据
  2. 详细设计
     - 详细实现实现的过程，如使用什么算法、数据库、用到什么函数处理
     - 产出：==详细设计说明书==（包括界面等）
     - 详细设计 遵循以下几个原则
       - 模块大小要适中
         - 不能太大：如一系列查询、处理、转发的操作，写到一起，后续处理环节想换成其他格式，就又得写一遍处理环节功能
         - 不能太小：如功能拆的太零碎，拼凑起来会很繁琐，甚至还不如重新实现一遍功能
       - 减少函数嵌套的深度：嵌套层数多，会导致代码难以理解，以及后续修改
       - 多扇入，少扇出
         - 扇入：别人调用自己的功能
         - 扇出：调用别人的功能
         - 简单说就是能自己解决的尽量自己解决，太依赖别的模块功能，会导致模块嵌套深度增加
       - 单入口，单出口
         - 如函数只有一个输入，一个输出，不管内部如何复杂，外部看来接口都很清晰
       - 模块的作用域应该在模块之内：降低外部干扰，提高内部聚合度
       - 功能应该是可预测的：避免产生不可知结果

- 模块独立程度有两个标准（考点）

  - 考点

    - 一种是根据关键字问是哪种分类
    - 另一种问哪种层次低，哪种层次高

  - 内聚程度

    ![内聚分类.png](https://github.com/hjxool/static-resource-save/blob/main/%E5%86%85%E8%81%9A%E5%88%86%E7%B1%BB.png?raw=true)

    - ==偶然==内聚：==最低==程度内聚，==无关联==
    - ==功能==内聚：==最高==程度内聚，==缺一不可==

    - ==逻辑==内聚：==重载==、==逻辑相似==
    - ==时间==内聚：==同时==
    - ==过程==内聚：**只**关心==顺序==
    - ==通信==内聚：==输入输出==
    - ==顺序==内聚：**不仅**关心==顺序==，前一个==输出==还得是后一个==输入==

  - 耦合程度

    ![耦合分类.png](https://github.com/hjxool/static-resource-save/blob/main/%E8%80%A6%E5%90%88%E5%88%86%E7%B1%BB.png?raw=true)

    - ==无直接==耦合：==无关联==（低耦合，耦合程度最低，也是程序追求的耦合程度）
    - ==内容==耦合：==最高==程度耦合，模块==内部关联==
    - ==数据==耦合：仅==传递==数据==值==
    - ==标记==耦合：==传递==数据==结构==
    - ==控制==耦合：==控制==另一模块中变量，==选择执行==某一功能
    - ==外部==耦合：==外部设备==
    - ==公共==耦合：==公共数据==

### 界面 设计

- 三大原则
  - 用户要能控制界面
  - 功能要一目了然
  - 界面风格要保持一致

## 软件测试

### 原则

- 见书P~252~

### 方法

- ==静态==测试
  - 即==不运行代码==，而是==检查文档==和==代码==文件
- 动态测试
  - 即==运行==代码，一般采用以下测试方法
    - ==白盒==测试（又称==结构性/性能测试==）
      - 即能看到内部运行过程
      - 用于测试==代码结构==、==性能==
    - ==黑盒==测试（==功能性测试==）
      - 即==只关注输入==和预期==输出==是什么
      - 用于测试==功能是否正常==使用

### 阶段

1. ==单元==测试（也称==模块==测试）
   - 即对程序中最小单元，如==类==、==函数==进行测试
   - 依据：==详细设计==说明书
2. ==集成==测试
   - ==检查模块==间的==接口==调用关系
   - 依据：==概要设计==说明书
3. ==系统==测试
   - 以上几个阶段测试完，已经迭代出一个新版本，然后就要进行==整体测试==，采用功能性测试（黑盒）、性能测试（白盒）
   - 依据：==用户需求==或开发==合同==
4. ==确认==测试
   - 测试的**最后**一个**阶段**，对之前几个阶段的功能、性能等全部过一遍，然后==交付==
   - 依据：==需求文档==
5. ==回归==测试
   - 后续需求发生变化，更改了一些功能后，验证是否仍然能正常工作
   - 简单说就是你改了代码之后，要确保之前的功能没被改坏了

### 测试用例的设计

- ==黑盒==测试用例，分为以下几类

  - ==等价类==划分
    - 用来==减少==测试==用例==的==数量==，把输入数据按类划分，每类数据等价，测试其中一个就能代表这一类的效果
    - 如有一个输入框，要求用户输入1到100之间的数字。你可以把所有可能的输入分成几类：
      - 有效等价类：1到100之间的数字，比如50
      - 无效等价类：小于1的数字，比如-10；大于100的数字，比如150；以及非数字输入，比如“abc”
    - 通过测试每一类中的一个代表值，就能有效覆盖所有可能的输入情况，从而==提高测试效率==
  - ==边界值==划分
    - 针对输入数据的边界进行测试，因为很多软件错误往往出现在==边界值==上，所以这种方法能有效地发现潜在的问题
    - 如有一个输入框，要求用户输入1到100之间的数字。边界值划分就是要测试这些边界附近的值，比如：
      - 边界值：1和100
      - 边界附近的值：0、2、99、101
    - 通过测试这些边界值和==边界附近==的值，能排查可能潜藏的错误

- ==白盒==测试用例，根据==覆盖的==代码==逻辑范围==，从低到高，分为：

  - 注：白盒有覆盖率这一概念，==测试的代码行数越多==，说明==覆盖率越高==，覆盖率最高即全部代码都执行一遍

    ![白盒测试用例.png](https://github.com/hjxool/static-resource-save/blob/main/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B.png?raw=true)

  - ==语句==覆盖（==SC==）

    - 覆盖程度最低，确保每一条语句执行一次即可，不管条件判断是否都覆盖到
      - 语句：`if else`称之为表达式，判断后执行的代码称之为语句
    - 如上图，SC路径为`s->a->c->b->e->d`，只要经过所有语句即可

  - ==判定==覆盖（==DC==）

    - 也成为==分支覆盖==，==真假分支都要覆盖**一次**==，即每个`if else`分支都执行一次即可
    - 如条件表达式 `A && B`，在分支覆盖下，我们需要测试以下两种情况
      - A && B 为真，进入 if 分支
      - A && B 为假，进入 else 分支

    ![白盒测试用例2.png](https://github.com/hjxool/static-resource-save/blob/main/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B2.png?raw=true)

  - ==条件==覆盖（CC）

    - 每一个判断表达式的独立条件，都要执行一遍真和假
    - 如条件表达式 `A && B`，那么在条件覆盖下，我们需要确保 `A` 为真和假的情况，以及 `B` 为真和假的情况都被测试到，条件覆盖下，我们需要测试以下几种情况
      - A 为真，B 为真
      - A 为真，B 为假
      - A 为假，B 为真
      - A 为假，B 为假
    - **注**：如果每个`if`里面只有一个独立条件，那条件覆盖和判定覆盖就是一样的

  - ==路径==覆盖

    - 覆盖率最高，所有可能的**路径**都要覆盖

    ![白盒测试用例3.png](https://github.com/hjxool/static-resource-save/blob/main/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B3.png?raw=true)

    - 注：路径覆盖和条件覆盖的区别是
      - ==路径覆盖==关注的是从入口到出口的==所有可能路径==
      - ==条件覆盖==关注的是每个条件的所有==可能结果==