## 面向对象概念

### 类

- 可以把它想象成一个蓝图或者模板
- 如造一辆车，那“类”就是车的设计图纸，里面详细描述了车的各个部分，比如轮子、发动机、车门等
- 类又分三种
  - ==实体==类：如人、物体，属于实体类的对象
  - ==接口==类
    - 接口类对象负责向外部输出或处理输入，分人和系统两种
      - ==人的接口==：如显示屏、对话框、菜单、二维码
      - ==系统接口==：涉及把数据发送到其他系统
  - ==控制==类
    - 基于接口类，帮助多个类之间协作
    - 响应==事件==即控制类对象，有一个“学生控制类”，里面有一个方法叫“添加学生”。当用户在界面上输入学生信息并点击“添加”按钮时，这个方法就会被调用，去模型中添加这个学生的数据

### 对象

- 就是根据这个蓝图造出来的具体的车
- 如每一辆车都有自己的特性，颜色、车牌号等，虽然都是根据同一个设计图纸造出来的，但每辆车都是独一无二的

### 多态分为

- ==参数多态==

  - 如同一个函数传入不同参数，返回不同结果

- ==包含多态==

  - 一个类中包含了多个具有多态行为的对象，我的理解是对抽象类继承，实现里面的抽象方法
  - 如有一个“动物”类，类里有一个方法叫“叫声()”，然后声明“狗”和“猫”类，继承“动物”类，并各自实现“叫声()”方法，狗的“叫声()”方法是“汪汪”，猫的“叫声()”方法是“喵喵”，当调用“狗”对象的“叫声()”，它会输出“汪汪”，当调用“猫”对象的`叫声()`，它会输出“喵喵”

- ==过载多态==

  - 就是==方法重载==，指在同一个类中，有多个方法名相同但参数不同的方法，这些方法可以根据传入参数的不同而表现出不同的行为

- ==强制多态==

  - 就是==削弱==继承抽象类的子类==类型存在感==，但又想在调用子类时，触发子类的方法

  - 如父类动物类，狗类和猫类继承自动物类，并各自实现具体方法，现在有个方法要根据传入的狗类实例对象，调用其方法，如果还有猫类对象，那同样的方法又得实现一遍，以后有不同类型动物子类，就得写同样的代码，会很冗余。因此使用强制多态，将子类全部转成动物类，但是又保留有自身具体实现方法，然后统一一个方法接收传入的动物类对象

    ![强制多态1.png](https://github.com/hjxool/static-resource-save/blob/main/%E5%BC%BA%E5%88%B6%E5%A4%9A%E6%80%811.png?raw=true)

    ![强制多态2.png](https://github.com/hjxool/static-resource-save/blob/main/%E5%BC%BA%E5%88%B6%E5%A4%9A%E6%80%812.png?raw=true)

- 总结：多态本质就是把通用部分放在抽象层，具体实现放在低层

### 接口

- 只定义规范，没定义具体实现，用关键字`interface`定义接口

### 覆盖

- 子类定义一个与父类==同名同参==的方法，可以理解为覆写

## UML（重点）

### 基本概念

- UML 三要素
  - ==构造块==
    - 可以理解成搭建模型的“积木块”
    - 包含以下种类
      - ==事物==
        - 模型中最具==代表性的部分==的抽象
        - 如==类==、==接口==(Interface)、==用例==等
      - ==关系==
        - ==事物==之间的==联系==
        - 如==依赖==、==泛化==等
      - ==图==
        - ==事物==和==关系==的图形表示
        - 如==类图==、==用例图==
  - ==规则==
    - 用来约束==构造块==的使用方式，确保模型的正确性。就像咱们写作文，得有语法规则，不能随便乱写，不然别人看不懂
    - 如类和类之间可以有继承关系，但不能有多重继承
  - ==公共机制==
    - 一些通用的概念和技术，帮助我们更好地使用UML
    - 包括
      - **规格化**：定义事物的详细信息，比如类的属性和方法
      - **标注**：在图中添加说明文字，帮助理解
      - **扩展机制**：比如用标签（Stereotype）来扩展UML的功能

### 事物

- 有以下几种类型

  - ==结构==事物（考点）

    - 是一种静态结构，通常包括==类==、==接口==、==用例==、构件等
    - 如设计一个电商网站时，类就是一种结构事物，它展示了用户、订单、商品等类，以及它们所具有的属性、方法

    ![结构事物.png](https://github.com/hjxool/static-resource-save/blob/main/%E7%BB%93%E6%9E%84%E4%BA%8B%E7%89%A9.png?raw=true)

  - ==行为==事物（考点）

    - 是一种动态行为，包括==用例==、==交互==、==状态机==等
    - 如电商网站，可以用 用例图 来描述用户如何浏览商品、下订单、付款等==操作流程==

    ![行为事物.png](https://github.com/hjxool/static-resource-save/blob/main/%E8%A1%8C%E4%B8%BA%E4%BA%8B%E7%89%A9.png?raw=true)

  - 分组事物

    - 用来组织和管理模型中的其他事物的，包括**包**
    - 如电商网站的用户管理、订单管理、商品管理等功能分别放在不同的包里，这样结构就清晰多了

    ![分组事物.png](https://github.com/hjxool/static-resource-save/blob/main/%E5%88%86%E7%BB%84%E4%BA%8B%E7%89%A9.png?raw=true)

  - 注释事物

    - 用来添加说明或注释的，帮助我们更好地理解模型
    - 如类图上加一些注释，解释某个类的作用或者某个方法的功能，这样别人看图的时候就更容易理解了

    ![注释事物.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%B3%A8%E9%87%8A%E4%BA%8B%E7%89%A9.png?raw=true)

### 关系

- 用来==连接事物==，展示它们之间的联系，可以理解成事物之间的“纽带”

- 有以下几种关系

  - ==依赖==

    - 表示一个事物依赖于另一个事物
    - 如写代码时，一个方法里用到了另一个类，这就是一种依赖关系
    - 图例是==虚线==、==实心箭头==

    ![依赖关系.png](https://github.com/hjxool/static-resource-save/blob/main/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png?raw=true)

  - ==关联==

    - 注：**只**存在于==类图==！

    ![关联关系.png](https://github.com/hjxool/static-resource-save/blob/main/%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB.png?raw=true)

    - `0..1`：表示0个或1个
    - `0..*`：表示0个或多个

    - （考区别）分为以下几种，但**都**表示==整体==和==部分==的关系

      - ==组合==

        - 与 聚合 的区别，在于 组合 表示的是**强**关联，即==整体不存在==了，==部分==也就==不存在==了
        - 如电脑由各种==零部件组合成==
        - 标识是==实心==

        ![组合关系.png](https://github.com/hjxool/static-resource-save/blob/main/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png?raw=true)

      - ==聚合==

        - 又叫==聚集==，**弱**关联，
        - 如“班级”和“学生”就是一种聚集关系。班级解散了，学生还是学生，他们可以加入其他班级
        - 标识是==空心==

        ![聚合关系.png](https://github.com/hjxool/static-resource-save/blob/main/%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB.png?raw=true)

  - ==泛化==

    - 表示一种继承关系，一个==类继承==另一个类的属性和方法
    - 如，猫类和狗类都可以继承自动物类，这就是一种泛化关系
    - 图例是==实线==

    ![泛化关系.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB.png?raw=true)

  - ==实现==

    - 表示==子类具体实现==了==父类==中所有抽象==接口==方法
    - 如，鸟类具体实现了飞机类中飞行接口
    - 图例是==虚线==

    ![实现关系.png](https://github.com/hjxool/static-resource-save/blob/main/%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB.png?raw=true)

### 图

- 事物 和 关系 放在一张图里，就组成了 XX图 ，根据 事物 的类型，可以分为以下几种图
- 注：箭头指向，如`A -> B`
  - 泛化：表示A是对B的泛化(继承)
  - 包含：表示A包含B，即执行A操作前，先得执行B

#### 类图（重点）

- 系统的==静态设计==视图，展现了一组对象、接口、协作和它们之间的关系

  ![类图.png](https://github.com/hjxool/static-resource-save/blob/main/%E7%B1%BB%E5%9B%BE.png?raw=true)

  - ==多重度==
    - 类似数据库章节中的1对多，多对多这些关系，只不过这里指的是==类之间**继承**关系==

#### 对象图

- 展示==某一时刻==的==对象==及它们之间的关系，是==类==图的一个==实例化==版本，可以理解为==类图的快照==。对象图的作用是帮助理解系统在某一时刻的==具体状态==

- 没有类图时，对象图就是==静态设计==图

  ![对象图.png](https://github.com/hjxool/static-resource-save/blob/main/%E5%AF%B9%E8%B1%A1%E5%9B%BE.png?raw=true)

  - ==匿名对象==：左边缺少对象名

#### 用例图（重点）

- 什么是==用例==？

  - 用例不仅仅是单一行为，而是一个==完整的交互过程==
  - 如，网上购物系统中，“用户登录”就是一个用例。这个用例不仅包括用户输入用户名和密码的行为，还包括系统验证用户身份、显示登录成功或失败信息的整个过程

- 用例图 也属于==静态图==，展示了==用例==、==参与者==之间的关系

  - 参与者：可以是人、硬件设备或其它系统

  ![用例图.png](https://github.com/hjxool/static-resource-save/blob/main/%E7%94%A8%E4%BE%8B%E5%9B%BE.png?raw=true)

  - ==用例之间==的关系：==包含==、==扩展==、==泛化==
    - ==扩展==（考点）
      - 是对某一用例的功能扩展，==非必须条件==
      - 如 用户注册 可以选择是否 邀请好友注册
      - 图例为==虚线箭头==
    - ==包含==（考点）
      - 表示一个用例在执行过程中==必须执行==的公共功能，==必须条件==
      - 如，网上购物系统，有“下订单”和“验证用户身份”两个用例，用户下订单时，系统都需要验证用户身份。“下订单”用例包含“验证用户身份”用例

#### 序列图（重点）

- 也叫==顺序图==、==时序图==。以==时间顺序==描述对象间交互

  ![时序图.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%97%B6%E5%BA%8F%E5%9B%BE.png?raw=true)

  - ==同步==消息：阻塞调用，调用者中止执行，等消息返回
  - ==返回==消息
  - ==异步==消息：发出消息后，继续执行其他操作，不会阻塞调用者

#### 通信图

- 也叫==协作图==、==动态图==，==序列图==的另一种==表现形式==，也是由 对象 和 消息 组成，只不过==不强调时间顺序==，只强调事件之间的通信

  ![通信图.png](https://github.com/hjxool/static-resource-save/blob/main/%E9%80%9A%E4%BF%A1%E5%9B%BE.png?raw=true)

#### 状态图

- 即==状态机==，描述**单个**对象==在==多个==用例中==所经历的各种==状态==以及状态之间的转换关系

  ![状态图.png](https://github.com/hjxool/static-resource-save/blob/main/%E7%8A%B6%E6%80%81%E5%9B%BE.png?raw=true)

#### 活动图

- 属于==动态图==，是一种特殊的==状态图==，与 状态图 的区别是：活动图 更关注==流程和步骤==，而 状态图 更关注对象的状态和变化

  ![活动图.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%B4%BB%E5%8A%A8%E5%9B%BE.png?raw=true)

#### 构件图

-  描述构件之间==接口供需关系==

  ![构件图.png](https://github.com/hjxool/static-resource-save/blob/main/%E6%9E%84%E4%BB%B6%E5%9B%BE.png?raw=true)

#### 部署图

- 描述系统的==物理架构==，展示了系统中硬件和软件的部署情况，特别是各个硬件节点（如服务器、工作站）以及它们之间的通信关系

  - 注：看到物理字眼就是部署图

  ![部署图.png](https://github.com/hjxool/static-resource-save/blob/main/%E9%83%A8%E7%BD%B2%E5%9B%BE.png?raw=true)

## 设计模式（难点）

### 相关概念

- 考点：各模式的英文名、有什么用

- ==架构==模式

  - ==最高层==的设计模式，是针对整个软件系统的==结构设计==，用来指导==系统==的==整体结构==和组织
  - 如，MVC、==微服务==架构

- ==惯用法==

  - ==最底层==的设计模式，是一些常见的编程技巧和写法，它们不一定有严格的结构和规范，但因为好用、方便，所以被广泛采用。惯用法更多的是针对具体编程语言的特性和习惯
  - 如，Python的列表推导式、==排序算法==等也是惯用法

- ==设计模式==

  - 针对==软件设计==中常见问题的通用==解决方案==
  - 如，单例模式、工厂模式

  ![设计模式1.png](https://github.com/hjxool/static-resource-save/blob/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1.png?raw=true)

### 创建型

- 即可以==创建对象==的模式
  - ==工厂==模式（Factory Pattern）
    - 如，有一个“汽车工厂”，你只需要告诉工厂你要什么类型的车，工厂就会帮你搞定一切，给你一辆现成的车。这就是工厂模式的思想
    - 工厂模式 又分为两类
      - 工厂方法
        - 即上述工厂模式的例子
      - 抽象工厂
        - 将工厂与具体实现相分离
        - 如，有工厂模式“手机”，但是手机类型繁多，需要继续抽象为iPhone、华为等手机类，只有`new 华为类()`时才返回对象
  - ==单例==模式（Singleton Pattern）
    - 即确保==一个类**只有**一个实例==，并提供一个全局访问点
    - 如，家里有一个WiFi路由器。这个路由器负责给家里的所有设备提供网络连接。你只需要一个路由器就够了，不需要每个房间都放一个
  - ==建造者==模式（Builder Pattern）
    - 通过 建造者模式 ，可以根据不同需求，建造==不同类型的对象==，而==不必亲自处理所有细节==
    - 就像建房，客户A需要一座木房子，就找木房子构建者，他会自己处理建造木质的房子，客户需要砖房，就找砖房子构建者
    - 与 工厂模式 的区别
      - 如果你只是想创建一个对象而==不关心==它的==构建过程==，使用==工厂模式==
      - 如果你需要==一步一步==地构建一个==复杂对象==，使用==建造者模式==
  - ==原型==模式（Prototype Pattern）
    - ==**复制**现有==的对象来==创建新的对象==，而不是通过实例化类来创建
    - 就是用原型创建多个相同的物品

- ==创建型== 速记口诀：==单抽元件厂==

  - 单：==单例==模式
  - 抽：==抽象工厂==模式
  - 元：==原型==模式
  - 件：==建造者==模式
  - 厂：==工厂方法==模式

  ![UML创建型.png](https://github.com/hjxool/static-resource-save/blob/main/UML%E5%88%9B%E5%BB%BA%E5%9E%8B.png?raw=true)

### 结构型

- 结构型设计模式，关注的是如何将类或对象结合在一起形成更大的结构，通过==组合对象==来==获得新的功能==

  - ==适配器==模式（Adapter Pattern）
    - 就像是电源插头转换器，主要==解决==的是==接口不兼容==的问题
    - 如，有一个老版本的系统，它提供了一些功能，比如读取数据，但接口是老式的。现在你有一个新系统，想要利用老系统的功能，但新系统的接口和老系统的不一样。这个时候，你就可以创建一个适配器类，这个类实现新系统的接口，并在内部调用老系统的功能
  - ==桥接==模式（Bridge Pattern）
    - 将抽象部分与它的实现部分分离，使它们可以独立变化，就像一座桥，将==两个独立领域==连接在一起
    - 如，汽车品牌有（奥迪、宝马），颜色类型有（红色、蓝色），这是两个独立的变化纬度。桥接模式 可以将品牌、颜色抽象出来，是你可以轻松组合不同品牌和颜色
  - ==组合==模式（composite Pattern）
    - 同之前==UML中的组合==，将对象组合成==树形结构==，使单个对象和多个对象能一致对待
    - 如，文件夹可以包含文件和其他文件夹，组成一个树状结构，你可以对文件、文件夹执行==相同的操作==，如复制、删除等
  - ==装饰器==模式（Decorator Pattern）
    - 就是==给对象套一层==，允许你动态地给对象添加新的功能，而无需修改源码。简单来说，就是在不修改现有代码的情况下，通过包装的方式==给对象增加新功能==
    - 如，智能音箱，通过添加语音助手、天气查询等来==扩展其功能==，而不需要改变音响核心功能
  - ==外观==模式（Facade Pattern）
    - 简单来说，就是给复杂的系统提供一个简单的接口，让用户不用关心内部的复杂细节
    - 如，操作系统的==图形界面==，隐藏了底层操作系统的复杂逻辑
  - ==享元==模式（Flyweight Pattern）
    - 通过共享大量细粒度对象来减少内存使用。简单来说，享元模式就是通过共享来==避免==创建大量==相似对象==，从而节省内存
    - 如开发一个文字处理器，这个文字处理器需要显示大量的字符。如果每个字符都单独创建一个对象，那内存消耗会非常大。享元模式就像是一个字符工厂，它会检查是否已经有相同的字符对象，如果有，就直接使用现有的对象；如果没有，才创建新的对象
  - ==代理==模式（Proxy Pattern）
    - 它为其他对象提供一种代理，以控制对这个对象的访问。简单来说，代理模式就是在不改变原对象的情况下，通过代理对象来控制对原对象的操作
    - 如，有一个很重要的文件，不希望别人直接访问这个文件，而是通过一个中间人来控制访问。这个中间人就相当于代理，只有通过代理才能访问到文件

- ==结构型== 速记口诀：==外侨组员带配饰==

  - 外：==外观==模式
  - 侨：==桥接==模式
  - 组：==组合==模式
  - 员：==享元==模式
  - 带：==代理==模式
  - 配：==适配器==模式
  - 饰：==装饰器==模式

  ![结构型设计模式.png](https://github.com/hjxool/static-resource-save/blob/main/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png?raw=true)

### 行为型

- 行为型 设计模式，主要关注==对象之间的通信==和==职责==分配，它们定义了对象之间的通信方式和算法的分配方式

  - ==责任链==模式（Chain of Responsibility Pattern）
    - 就是把多个处理请求的对象串成一条链，==依次传递==请求，**直到**==有一个对象处理==这个请求**为止**
    - 如，在公司请假一样。你先把请假条递给你的直属领导，如果他能处理，就直接批了。如果他觉得这个事情需要更高一级的领导来决定，他就会把请假条递给他的上级。这样一级一级传递下去，直到有一个领导能处理为止
  - ==命令==模式（Command Pattern）
    - 就是==把请求封装成一个对象==，这样你就可以用不同的请求来==参数化==其他对象了。说白了，就是把“命令”当作一个对象来处理
      - 注！命令模式还有个关键字是==可撤销==
    - 如，点菜的时候，服务员会把你的点菜请求写在一个小票上，然后把这个小票交给厨房。厨房的厨师根据小票上的内容来做菜。这里，小票就是一个命令对象，它封装了你点菜的请求
  - ==解释器==模式（Interpreter Pattern）
    - 核心思想是定义一种==语言的文法表示==，并设计一个==解释器来解释==这个语言中的句子
      - 注：涉及到==虚拟机==、==编译==一类的就选 解释器模式
    - 如，“3 + 5 * 2”。你会先按照数学规则来拆解这个表达式，先计算乘法“5 * 2”，得到10，然后再加上3，得到最终结果13。这里的每一步计算就是一个小的解释过程
  - ==迭代器==模式（Iterator Pattern）
    - 就是提供一种方法来顺序访问一个集合中的各个元素，而不需要暴露集合的内部表示。说白了，就是让你能一个一个地==遍历==集合里的==元素==
    - 如，看书，从第一页开始，一页一页地往后翻，直到看完最后一页
  - ==中介者==模式（Mediator Pattern）
    - 通过一个==中介对象来封装一系列对象之间的交互==。说白了，就是把对象之间的复杂关系交给一个中介者来处理，这样每个对象只需要和中介者打交道，而不需要直接和其他对象联系
    - 与 代理模式 的区别
      - ==中介者==模式 用来==简化==对象之间的==交互==行为，可以理解为优化性
      - ==代理==模式 用来==控制==对某个对象的==访问==，可以理解为安全性
    - 如，班级里，班长就是那个中介者。假设你有事要找班主任，你不需要直接去找班主任，而是先告诉班长，然后班长再去和班主任沟通。这样，班级里的同学们之间的沟通就变得简单了，每个人只需要和班长联系就行了
  - ==备忘录==模式（Memento Pattern）
    - 保存一个对象的某个状态，以便在适当的时候恢复这个状态。说白了，就是给对象做个“==备份==”，以后需要的时候可以“==还原==”
    - 如，玩游戏的时候，打到一个重要的关卡前，你会选择存档。这样如果你不小心挂了，还可以从存档点重新开始，而不用从头再来。这里的存档就是备忘录，游戏的状态就是你要保存的内容
  - ==观察者==模式（Observer Pattern）
    - 定义对象间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会收到通知并自动更新。说白了，就是有一个“==发布==者”和多个“==订阅==者”，发布者一有动静，订阅者们就都知道了
    - 如，微博上关注了某个大V博主。这个博主发了新微博，你和其他关注他的粉丝们都会收到通知。这时候，博主就是“发布者”，你们这些粉丝就是“订阅者”
  - ==状态==模式（State Pattern）
    - 允许对象在其内部==状态改变时改变行为==。说白了，就是对象在不同状态下会有不同的表现，就像人心情好和心情不好时做事的方式不一样
    - 如角色扮演游戏，在“正常”状态下，角色可以跑、跳、攻击；在“受伤”状态下，角色可能只能慢慢走，攻击力也减弱，这些状态会影响角色的行为
  - ==策略==模式（Strategy Pattern）
    - 定义一系列==算法==，把它们一个个==封装==起来，并且使它们可以互相替换。说白了，就是让一个对象在==不同情况下可以选择不同的算法==来完成任务，就像你根据不同的情况选择不同的交通工具一样
    - 如上班，有时候开车，有时候坐地铁，有时候骑自行车。你选择哪种方式取决于当天的交通状况、天气和你的心情
  - ==模版方法==模式（Template Method Pattern）
    - 定义一个==算法==的==骨架==，并允许子类在不改变算法结构的情况下==填充==某些==步骤==。说白了，就是有一个“模版”，你可以在这个模版的基础上填充具体的内容，==就像填表一样==
    - 如，做蛋糕，有一个标准的蛋糕制作流程：准备材料、混合材料、烘烤、装饰。这个流程就是模版方法。而具体的蛋糕种类，比如巧克力蛋糕、草莓蛋糕，它们的材料和装饰可能不同，但制作流程是一样的。你可以在这个模版流程中填充不同的材料和装饰，做出不同的蛋糕
  - ==访问者==模式（Visitor Pattern）
    - 将操作和数据结构分离，使得你可以在不改变数据结构的前提下定义新的操作。说白了，就是让你可以在不修改原有类的情况下，添加新的功能
    - 与 装饰器模式 的区别
      - ==访问者==模式 是对==同一数据==结构进行不同操作，定义不同的==“访问者”类==来执行，简单说就是==操作的多样性==
      - ==装饰器==模式 是对==同一个对象==进行各种功能==拓展==，简单说就是==功能的扩展性==
    - 如，对同一个展品，艺术专家会评价画作的艺术价值，历史学家会评价文物的历史意义。这些专家就是“访问者”，他们可以对同一个展品进行不同的操作，而展品本身并不需要改变

- 行为型 速记口诀：==观摩对策，责令解放，戒忘台==

  - 观：==观察者==模式
  - 摩：==模版方法==模式
  - 对：==迭代器==模式
  - 策：==策略==模式
  - 责：==责任链==模式
  - 令：==命令==模式
  - 解：==解释器==模式
  - 放：==访问者==模式
  - 戒：==中介者==模式
  - 忘：==备忘录==模式
  - 台：==状态==模式

  ![行为型设计模式.png](https://github.com/hjxool/static-resource-save/blob/main/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png?raw=true)