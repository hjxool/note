## 考点及解题技巧

- 软件架构、软件工程（其中面向对象部分）属于必考内容
  - 软件架构：23年以后主要是八大架构，如大数据架构等，23年以前是考传统架构
  - 软件工程：UML图、设计模式识别
- 解题技巧
  1. 第一题是必选题，先做完第一题再看后面
     - 注：如果实在不会，也要从题目中拼凑句子填进去
  2. 接下来的题是**四选二**，**快速浏览**所有题目**问题**，如果问题都看不懂，就跳过该题
     - 注：因为题目少说几百字，通篇看浪费时间，而问题简单直接
  3. 新技术的问题，一般答案隐藏在题目描述中，从题目描述中总结答案
  4. 通过分析问题，有把握拿到10分以上就可以作为备选题
  5. **不要水字数**，一般有最大字数限制
  6. 遇到新技术不要慌，如果有其他备选题，选其他题，如果备选题中有新技术，就**看名知意**，通过描述，分析新技术适合什么场景，从而胡诌，**不要空着试卷**
  7. 回答要列条目，把认为对的都写上，多写不扣分，少写一定扣分
  8. 如果题目中给了多个方案，并说某某方案更好，就要顺着题目回答，分析该方案为什么好，不要选其他方案，也不要写该方案的缺点

## 传统架构

### 必须掌握知识点

- 软件**架构风格**
  - 对应第十四章 软件架构设计
- 架构**风险**
- 风险点与非风险点
- **质量属性**和**效用树**
  - 对应第十五章-系统质量属性和架构评估

- **敏感点**和权衡点
  - 对应第十五章-系统质量属性和架构评估

- **典型的架构**
  - 对应第十五章-系统质量属性和架构评估
  - 要了解一下J2EE架构
    - 除了跟三层C/S架构一样有==客户端==层、==业务逻辑==层和==数据==访问层，还更细化出==Web层==、==集成层==
      - Web层：处理HTTP请求
        - 如在浏览器中提交一个表单，Web层会接收这个请求并处理
      - 集成层：用于与其他系统或服务的交互
        - 如使用Web服务（SOAP/REST）与第三方支付系统进行交互


### 质量属性（8个前5个最重要）

- **性能**
  - 指系统要经过==多长时间==才能对某个事件==做出响应==，或者某段==时间内==系统能==处理==的==事件个数==
    - 如：响应时间、吞吐量
  - **设计策略**：优先级队列、增加计算资源、减少计算开销、引入并发机制、采用资源调度等
- **可靠性**
  - 系统==不发生故障的能力==
    - 如：MTTF（平均**无故障**时间）、MTBF（平均故障**间隔**时间）、MTTR（平均故障**修复**时间）
  - **设计策略**：心跳、Ping/Echo、冗余、选举
- **可用性**
  - 系统处于==可操作==状态的==时间比例==
  - **设计策略**：心跳、Ping/Echo、冗余、选举
- **安全性**
  - **关键字**：==合法==、==授权==、==拒绝==、==入侵==、==认证==、==审计==
  - **设计策略**：入侵检测、用户认证、用户授权、追踪审计
- **可修改性**
  - 以较高==性价比==能对系统==修改==的能力
  - **设计策略**：接口-实现分类、抽象、信息隐藏
- **功能性**
  - 系统具备某些具体的功能
- **可变性**（**可拓展**）
  - 原架构==变为新架构==的能力（注意与可修改性区别）
- **互操作性**
  - 用户方不方便使用

### 架构风格

- **数据流**风格
  - **关键字**
    - ==以整体为单位==：属于数据流-==批处理==风格
    - ==前一个的输出是后一个的输入==：属于数据流-普通-==过滤器==风格
- **调用/返回**风格
  - **关键字**
    - ==主程序调用子程序==：属于调用/返回-==主程序/子程序==风格
    - ==通过对象调用==：属于调用/返回-==面向对象==风格
    - ==层==：属于调用/返回-==层次结构==风格
      - C/S架构
      - 富客户端应用RIA
      - MVC、MVP、MVVM架构
- **独立构件**风格
  - **关键字**
    - ==同步==、==异步==：属于独立构件-==进程通信==风格
    - ==事件==：属于独立构件-==事件驱动==风格
- **虚拟机**风格
  - **关键字**：虚拟机的两个风格不好区分，得根据特点规则系统名词
    - ==DSS==、==人工智能==、==专家系统==：属于虚拟机-==规则系统==风格
    - ==自定义规则==：属于虚拟机-==解释器==风格
- **仓库**风格
  - **关键字**
    - ==中央数据源==：属于仓库==数据库==风格
    - ==互联网==、==网状==：属于仓库==超文本==风格
    - ==语音识别==、==图像识别==：属于仓库==黑板==风格
- **闭环过程控制**风格（非重点）
  - **关键字**：==循环往复==
- **C2**风格（非重点）
  - **关键字**：==连接件==

## 软件工程

- 考点
  - **结构化**、面向对象、项目管理
    - 面向对象：在第十二章-面向对象设计中用例图、类图部分
  - **三大模型**：功能模型（数据流图）、行为模型（状态转换图）、数据模型（E-R图）
    - 数据流图：在第十一章-软件工程中需求分析部分
    - E-R图：在第九章-数据库设计
  - **数据字典**

## 数据库系统

- 考点
  - 关系型数据库和非关系型数据库的区别
  - 非关系型数据库分类
    - 尤其==键值对存储数据库==是重点
  - 如何根据范式和约束拆分表，以及如何使用反规范化技术提升性能

#### 分布式数据库

- 分布式数据库在逻辑上相联，物理上不相连，通过网络连接，每个分布式节点具有独立处理的能力，可以执行局部操作，也可以网络通信执行全局的操作
- 分布式 和 集群 的区别
  - **分布式** 通过**网络**相联
  - **集群** 通过**物理**方法相联
- **特点**
  - 数据==独立==性
    - 分为
      - **逻辑**数据独立性
        - 客户端不需要关心数据的逻辑结构变化
      - **物理**数据独立性
        - 客户端不需要关心数据的物理存储位置
  - ==集中==与自治==共享==结合的控制结构
    - 可以集中起来完成某个任务
  - 适当增加数据==冗余==度
    - 在不同数据库服务器上存储多个副本，从而提高系统可靠性、可用性、性能
  - ==全局一致==性
    - 尽管数据分布在多个节点上，但系统要保证所有节点上的数据是一致的。也就是说，无论你在哪个节点上进行数据操作，其他节点的数据状态也要保持同步
  - 可==串行==性
    - 就是多个事务在分布式环境中执行的结果，要和它们按某种顺序串行执行的结果一致
  - 可==恢复==性
    - 分布式数据库要在发生故障时，能够恢复到一致的状态
- **优点**
  - 解决部门分散而==数据==需要==相联==的问题
  - ==便于扩展==
  - 满足==负载均衡==的需要
  - 可以==复用==已有的数据库系统，当需要执行全局任务时，可以自下而上构成分布式数据库系统
  - 分布式系统分散的特性，使得局部故障不会影响全局，所以==可靠性高==

#### 数据仓库

- 对应 第十四章-软件架构设计
- 数据仓库的**结构**
  - **数据源**
  - 数据**存储**与**管理**
    - 数据仓库系统的核心
  - **OLAP**（联机分析处理）服务器
    - 对数据进行集成，从多角度对数据进行聚类分析，得到数据趋势
  - **前端**工具
    - 各种可视工具，报表、查询、数据分析工具

#### 对象关系映射 ORM

- 是一种技术，用来把数据库中的数据表映射成编程语言中的对象，从而让开发者可以用面向对象的方式来操作数据库，==表对应类==、==记录对应对象==、==字段对应对象属性==
  - Mongoose就是NodeJS中的一个ORM库
- **优点**
  - 降低学习成本
  - 减少代码量
  - 降低SQL代码质量差带来的影响
- **缺点**
  - 不容易处理复杂查询语句
  - 性能比直接用SQL语句查询差

## 嵌入式

- 嵌入式系统 是为**特定应用**构件的**计算机系统**
- 典型**架构**可分为两种
  - **层次**化模式架构
    - 子系统具有**特定功能**，相互独立
    - **优点**：易拓展
    - **适合**：大型系统
  - **递归**模式架构
    - 子系统**功能相似**
    - **优点**：将问题分解为更小的子问题来逐步解决，因此**代码简洁**
    - **适合**：解决复杂问题
- 嵌入式操作系统（EOS）**特点**：可裁剪、可移植、**弱交互**、可确定、可预测等
  - 可确定：同一问题始终能拿到同一结果
  - 可预测：能够预期完成的时间
- 嵌入式数据库系统 内容见 第六章-嵌入式技术应用

## WEB应用开发

- 涉及的技术

  ![WEB应用涉及的技术.png](https://github.com/hjxool/static-resource-save/blob/main/WEB%E5%BA%94%E7%94%A8%E6%B6%89%E5%8F%8A%E7%9A%84%E6%8A%80%E6%9C%AF.png?raw=true)

  - **Docker**：开源的**容器**化平台
    - 允许开发者将应用程序及其所有依赖项打包到一个标准化的单元中，这个单元就是“容器”。容器可以在任何支持Docker的平台上运行，确保应用程序在不同环境下的行为一致
    - 如本地开发环境中，用Docker打包了一个Web应用，这个应用在你的电脑上跑得好好的，你把这个容器放到云服务器上，它也能一样跑得好好的，不会因为环境不同而出问题
  - **Apache**：开源的HTTP**服务器**软件
    - **主要功能**是提供Web服务，也就是说它可以把你的Web应用发布到互联网上，让别人通过浏览器访问
      - 也支持其他功能：**负载均衡**、虚拟主机等
    - 如写了一个网站，用Apache部署到服务器上，别人就可以通过网址访问你的网站了
  - **MyBatis**
    - 半自动的ORM框架，它需要开发者手动编写SQL语句，但提供了映射配置来简化结果集到Java对象的转换
  - **Hadoop**：开源的分布式计算框架
    - 主要用来处理大规模数据集
    - 如有一个超大的日志文件，想要统计其中某个特定关键词的出现次数，用Hadoop就能高效地完成这个任务

- **MQTT**协议

  - **应用**：物联网设备之间的通信
  - **目标**：低带宽、高延迟和不稳定网络环境下的可靠消息传输
  - **工作原理**
    - **发布/订阅模式**
      - MQTT采用了发布/订阅的通信模式。设备可以发布消息到某个主题（Topic），其他设备可以订阅这个主题，从而接收到消息
      - 如智能家居系统中，温度传感器可以发布当前温度到“home/temperature”主题，空调设备订阅这个主题后，就能接收到温度数据并进行调节
    - **轻量级协议**
      - MQTT的协议头非常小，适合在资源受限的设备上运行
      - 如电池供电的传感器，它的计算能力和网络带宽都很有限，使用MQTT可以减少通信开销，延长电池寿命
    - **质量保证**：MQTT提供了三种消息传输质量保证（QoS）级别
      - **QoS 0**：**最多**一次传输，消息可能会丢失
      - **QoS 1**：**至少**一次传输，消息可能会重复
      - **QoS 2**：**只有**一次传输，确保消息不会丢失或重复
    - **持久连接**：MQTT支持持久连接，设备可以保持长时间的连接，减少频繁的连接建立和断开带来的开销
    - **断线重连**：断线重连机制，设备在网络中断后可以自动重连并恢复通信

## 信息系统架构

- 案例备考攻略书P~36~

## 层次架构设计

- 案例备考攻略书P~47~
- XML文件在后端主要用来
  - 写配置文件
  - 数据交换
    - 如设备端和后端数据进行整合，两边数据库数据格式、类型不一样，所以要用XML这一统一的数据模板，将数据导出，然后合二为一，完成数据交换

## 通信系统架构设计

- 案例备考攻略书P~60~

## 面向服务架构设计

- 案例备考攻略书P~70~
- **REST**
  - 用于**微服务**之间**通信**的**架构风格**，核心思想是通过一组简单的操作（主要是HTTP协议中的GET、POST、PUT、DELETE等）来操作资源
  - 如在线书店的系统，每本书可以看作一个资源，你可以通过URL来访问这些资源，比如`http://example.com/books/123`表示ID为123的那本书。然后你可以通过不同的HTTP方法来操作这个资源
  - **特性**
    - **无状态性**
      - 每个请求都是独立的，服务器不会保存客户端的状态
      - 如，每次请求都要包含认证信息
    - **统一接口**
      - 使用标准的HTTP方法和状态码，使得API简单易懂
    - **资源的表述**
      - 资源可以有多种表述形式
      - 如JSON、XML等，客户端通过这些表述来理解和操作资源

## 云原生架构设计

- 案例备考攻略书P~83~

  ![云原生架构图.png](https://github.com/hjxool/static-resource-save/blob/main/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true)

## 大数据架构设计（重点）

### 基本概念

- 三大挑战
  - 如何处理**非结构化**数据和**半结构化**数据
    - **非结构化数据**：文本文件、图片、视频等
    - **半结构化数据**：XML、JSON等
    - 解决办法：使用图像识别、自然语言处理等方法
  - 大数据的复杂性和不确定性以及大数据建模
    - 大数据的数据源庞杂，有很多缺失字段，噪音（不相干的数据），以及不确定的数据
  - 异构数据、决策视角不同对大数据挖掘的影响
    - 数据源的格式，数据格式往往不同，决策者想要挖掘的信息也不同
- 大数据应具有的**特征**
  - 可靠性和容错性
    - 使用冗余数据备份机制
  - 低延迟读取和更新能力
    - 使用高读取速度的硬件、缓存（如Redis）、索引技术
  - 横向扩容
    - 比如增加计算资源或存储资源
  - 延展性
    - 架构可拓展性，能够方便拓展新功能
  - 通用性
    - 能够支持各种数据类型和格式
  - 及时查询能力
  - 最少维护能力
    - 设计架构时尽可能少的维护
  - 可调式性
    - 使用日志跟踪

### Lambda架构

![Lambda架构.png](https://github.com/hjxool/static-resource-save/blob/main/Lambda%E6%9E%B6%E6%9E%84.png?raw=true)

- **特点**：有两层处理数据

  - **批处理**层（Batch Layer）：处理**大量**堆积的**历史**数据
    - **Map Reduce**：由两个阶段组成
      - **Map阶段**
        - 将输入数据分割成多个片段，并对每个片段进行处理
        - 如有一堆日志文件，想统计每个单词出现的次数。在Map阶段，每个日志文件会被分割成多个小片段，每个片段中的单词会被映射成键值对，键是单词，值是出现次数
      - **Reduce阶段**
        - 将Map阶段生成的键值对进行合并和汇总
        - 如接上一步，相同的单词会被汇总起来，计算总出现次数，如所有片段中出现的单词“hello”会被汇总成一个键值对，键是“hello”，值是总出现次数
  - **加速**层（Speed Layer）：以**流**的形式处理**实时**数据
    - 处理速度**快**、**不**准确

- 技术选型

  ![Lambda架构技术选型2.png](https://github.com/hjxool/static-resource-save/blob/main/Lambda%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B2.png?raw=true)

  - **Kafka**：一种分布式流处理平台，主要用于构建实时数据管道和流应用。它的核心包括
    - 主题（Topic）：以理解为频道，所有相关的数据都会发布到这个主题上
    - 生产者（Producer）
    - 消费者（Consumer）
    - 代理（Broker）
  - **Spark**：分布式计算框架，主要用于大规模数据处理。核心包括
    - **RDD（弹性分布式数据集）**：RDD是Spark的核心数据结构，表示一个分布式的数据集。它支持两种操作
      - 转换：生成新的RDD，比如`map`、`filter`等
      - 行动：触发实际计算，比如`count`、`collect`等
    - **集群管理器**：Spark可以运行在多种集群管理器上，比如Standalone、YARN、Mesos等。集群管理器负责资源分配和任务调度
    - **任务调度**：任务调度器将计算任务分配到集群中的各个节点上。任务调度器会根据数据的分布和节点的负载情况，优化任务的执行顺序和资源使用
  - **Hadoop**：分布式计算框架，主要用于存储和处理大规模数据。核心包括
    - **HDFS（Hadoop分布式文件系统）**：HDFS是Hadoop的存储系统，负责将大规模数据分布式存储在集群中的多个节点上。它将数据分成多个块，每个块存储在不同的节点上，以实现高可用性和容错性。比如，你有一个1TB的大文件，HDFS会将这个文件分成多个64MB的块，并将这些块分布存储在不同的节点上
      - 注：**HDFS** 不提供查询，只能存
    - **MapReduce编程模型**：MapReduce是Hadoop的计算模型，用于处理大规模数据集。它将计算任务分成两个阶段：Map阶段和Reduce阶段
    - **YARN**：Hadoop的资源管理框架，功能包括
      - **资源管理**：动态分配集群中的计算资源（如CPU、内存）给不同的应用程序
      - **任务调度**：调度和监控任务的执行情况，确保任务能够顺利完成。如某个节点出现故障，YARN会重新调度任务到其他节点上执行
  - **Hive**：数据仓库**工具**，它建立在Hadoop之上，使用类似SQL语句的**HQL**查询，从而进行数据分析
  - **HBase**：分布式、按列存储的**NoSQL**数据库，建立在**HDFS**上，用于实时数据存储和访问
    - **HDFS**只能存堆积的历史数据，因此**Hive**用于查询和分析，而**HBase**则用来快速读写更新的**实时数据**

- **缺点**：全场景覆盖，即历史数据、实时数据的查询都能覆盖，因此**开销很大**

### Kappa架构

![Kappa架构2.png](https://github.com/hjxool/static-resource-save/blob/main/Kappa%E6%9E%B6%E6%9E%842.png?raw=true)

- 基于==Lambda架构==进行优化，**删除**了==批处理层==，使用==消息队列==作为代替，因此只能处理==时间不长==、==数据量不大==的历史数据，所以==Kappa架构主要处理实时数据==，但不是说就完全舍弃了历史数据，沉淀的历史数据会放在==数据湖==，当需要离线进行历史数据计算时，则将数据湖中的数据==重新过一遍消息队列==，这也意味着处理历史数据非常消耗性能
- 与 Lambda架构 **区别**
  - Kappa架构 不是 Lambda架构 的替代架构，而是**简化版本**，Kappa架构 ==放弃了对批处理的支持==，==更擅长对实时数据进行处理==
  - Lambda架构 ==更适用于历史数据分析查询场景==
  - Lambda架构 维护双系统成本高
  - Kappa架构 抛弃了离线计算更稳定可靠的特点
  - Kappa架构 在处理历史数据时，走的是消息通道，并且同时还要处理新的实时数据，因此历史数据回溯时性能消耗很大

## 安全架构设计

### 安全架构概述

- 威胁来自于：物理环境、通信链路、操作系统等
- 安全架构 包含
  - 产品安全
  - 安全技术体系：构件通用安全**基础设施**
  - 安全审计：日志审计

### 安全模型

![安全模型.png](https://github.com/hjxool/static-resource-save/blob/main/%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.png?raw=true)

### 系统安全系统架构规划框架（重点）

- 根据风险威胁划分出5个实体对象：**应用**、**存储**、**主机**、**网络**、**物理**
- 信息系统安全技术体系有以下几个构成
  - **技术体系**（技术）：由物理安全、系统安全两大类构成
  - **组织体系**（人）：机构、人事
  - **管理体系**（制度）：培训、制度
- ![安全架构规划.png](https://github.com/hjxool/static-resource-save/blob/main/%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84%E8%A7%84%E5%88%92.png?raw=true)

### 信息安全整体架构设计

- 6个环节：预警、保护、检测、响应、恢复、反击
- 3大要素：人员、策略、技术

### 网络安全体系架构设计

- OSI七层网络模型有==5类安全服务==：**鉴别**、**访问控制**、**数据机密性**、**数据完整性**、**抗抵赖性**
- OSI定义==分层多点安全技术体系架构==，通过以下三种方式将防御能力分布至整个信息系统中
  - **多点**技术防御：从多个角度防御
  - **分层**技术防御：对手和目标之间设置多个防御机制
  - **支撑**性基础设施

### 数据库系统的安全设计

- 数据库主要考虑的是完整性，完整性设计就是完整性**约束**的设计
- 约束的作用
  - 防止合法用户使用数据库时向数据库添加不合法数据

### 系统架构的脆弱性分析（重点）

- 漏洞的来源主要有以下几个方面：软件**设计时的瑕疵**、软件**实现**中的弱点、软件**本身**的瑕疵、**系统**和**网络**的错误**配置**
- 脆弱性分析考虑的三个方面
  - 软件故障现象：总结本质
  - 软件开发：发现技术薄弱环节
  - 软件使用
- （考点）典型软件架构脆弱性分析
  - **分层架构**
    - **层间**的脆弱性：一旦某个底层发生错误，整个程序无法正常运行
    - 层间**通信**的脆弱性：系统被分为多个独立的层，原本“直来直去”的操作现在要层层传递，必然会**性能下降**
  - **C/S架构**
    - 客户端**软件**脆弱性：软件被分析、数据被截取的可能性
    - **网络开放**性的脆弱性：对于二层C/S架构，客户端可以直接读取服务器数据
    - **网络协议**的脆弱性
  - **B/S架构**
    - 因为是浏览器，更容易被病毒入侵
  - **事件驱动架构**（隐式调用）
    - **组件**的脆弱性：组件触发事件，并不能确定该事件的其他组件**执行顺序**
    - 组件间**交换数据**的脆弱性：一个组件可能需要将参数传递给另一个组件，当数据量很大时，传递的脆弱性会凸显
    - 组件间**逻辑关系**的脆弱性：事件驱动使得组件间逻辑关系变得复杂
    - 事件驱动容易进入**死循环**
    - **固定流程**的脆弱性：因为事件驱动流程基本是固定的，如果操作不当，容易引发问题
  - **MVC架构**
    - **复杂性**带来的脆弱：降低运行效率
    - **视图与控制器间紧密连接**的脆弱性：视图和控制器相互分离，但紧密连接，妨碍了独立复用
    - 视图对模型数据的**低效率访问**的脆弱性
  - **微内核架构**（嵌入式）
    - 难以进行良好的**整体优化**：微内核只实现了最基本的系统操作，内核与外部程序之间独立运行
    - 进程间**通信开销**也较单一内核系统大得多
    - **通信损失率**高：微内核把系统分为各个小的功能块
  - **微服务架构**
    - 微服务导致功能分的太细，导致管理起来更加复杂