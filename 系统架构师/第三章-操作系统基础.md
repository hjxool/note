## 操作系统概述

- 何谓操作系统？
  - ==硬件==环境上==构建==得==软件==环境，这个软件可以使用硬件功能
    - 如手机操作系统、电脑操作系统、嵌入式操作系统
- 操作系统作用
  - 提高计算机使用效率
  - 提供人机界面
- 操作系统特性
  - 并发
    - 如：同时启动多个软件
  - 共享
    - 所有文件资源对程序都是共享的
  - 虚拟性
    - 类似 虚拟机，不是直接操作调动硬件，而是隔了一层
  - 不确定性
    - 如：并发引起的资源竞争，硬件故障等因素
- 操作系统功能
  - ※==进程==管理
  - ※==存储==管理
  - ※==文件==管理
  - ※==设备==管理
  - 作业管理
- 操作系统分类
  - 批处理 操作系统
  - 分时 操作系统
    - ==轮流==使用CPU
  - 实时 操作系统
    - 快速响应
  - 网络 操作系统
  - 分布式 操作系统
    - 物理意义上 ==分散== 的计算机 ==互联== 系统
  - 微机 操作系统
    - 如：Windows
  - 嵌入式 操作系统

- 计算机 启动 流程
  - `BIOS -> 主引导记录 -> 操作系统`
    - BIOS
      - 开机时会进入自检页面，只是厂家会用logo盖住，也可以用F12等进入BIOS
      - ==直接== 对 ==硬件== 进行设置
    - 主引导记录
      - 如：装了 双系统 时，选择进入哪个操作系统

## 进程的组成和状态

- 什么是 进程 ？
  - 程序 是一堆 `bit`序列，当运行时，CPU会在 内存 中为其开辟一块区域即 进程，因此 进程 就是 程序 的意思
  - 而 线程 是 进程 中 最小执行单元
  - ==进程==（程序）是计算机中 正在运行 的 ==程序的实例==
    - 是系统进行 资源分配 和 管理 的 ==基本单位==
    - 包括 **代码**、**数据**、执行**状态**
- 进程的 组成
  - 进程控制块（PCB）
    - 简单记，即 ==唯一标识==，进程管理界面中的 ID号
  - 程序
    - 描述进程 ==做什么==
  - 数据
    - 存储进程 ==执行时== 所需 ==数据==

- ==进程状态==分为
  - 非人为 干涉的三态图
    - 见书P50
    - 概念介绍
      - 运行
        - 进程正在执行，注意CPU中有 ==时间片段== 的概念，也就是 切换 执行程序，但是因为很快，所以宏观上看是 并行
        - 如果是 多核，每个核都可以设置一条 时间片段，轮换 执行任务
        - 注：运行 属于 三态图，所以具体程序执行多长时间让出CPU控制权，取决于计算机底层，分配给每个进程的 执行时间
      - 就绪
        - 运行 时间片段 到期后，进入==下一个状态== 即 ==就绪==状态
        - 等待下一次 受 CPU调度，拿到CPU使用权，再次进入 ==运行==状态
      - 等待（阻塞）
        - 当 进程 ==等待== 外部事件的结果时，会 挂起
        - 当 等待 的事件给出结果了，就会进入 ==就绪== 状态**排队**
        - 注：等待 **不能** 直接回到 运行状态
  - 人为 干涉的五态图
    - 多了 ==静止就绪== 和 ==静止阻塞== ，需要 人为 操作才会进入
    - 活跃就绪 即 就绪
    - 活跃阻塞 即 等待

## 前趋图和进程资源图

- ==前趋图==
  - 表示哪些 ==进程== 可以 ==并行== 执行，哪些 进程 之间有 ==顺序== 关系
- 进程 资源 图
  - 表示 ==进程== 和 ==资源== 之间的 ==请求== 和 ==分配== 关系
  - ==资源== 指向 进程的线，表示资源 ==分配== 给对应进程
  - ==进程== 指向 资源的线，表示进程 ==请求(申请)== 资源
  - ==阻塞== 节点
    - 进程 向 资源 请求，但是==资源已经分配完==，该 进程 就被阻塞，只能 等待 资源被释放 
    - 注：**无论** 进程 是否已经**被** 其他 资源池**分配了资源**，**只要**它所==请求的资源==池==没有空余==资源，就会==阻塞==！
    - 当图中所有 进程 ==都是阻塞节点== 时，即陷入 ==死锁== 状态
      - ==死锁== 状态==不可化简==
        - 化简 思路：让 非阻塞节点 先运行
          - 因此化简 ==顺序== 中 非阻塞节点 在前
    - 例：存在资源池R1和进程P1，R1将资源分配给P1，P1向R1请求，此时P1是 阻塞 节点
      - 因为R1分配后已经没有资源，而P1又请求资源，尽管此时P1已经被R1分配了资源，但是请求的是额外的资源，还是阻塞
  - ==非阻塞== 节点
    - **只要** 没有被阻塞，就是 非阻塞节点

## 同步与互斥

### 互斥

- 指 ==同一时间== **只允许一个**进程访问某个资源，其他进程必须==等待==
  - 互斥是为了防止多进程同时访问一个资源，造成数据损坏和程序崩溃
    - 如：打印机
    - 其实是一种 防卫场景
  - ==0== 表示有进程==占用==，==1== 表示 ==没有进程使用==
- ==临界资源==
  - 被==互斥方式==的进程访问的资源
- ==互斥信号量==
  - 访问 ==临界资源== 时的 控制==标识==，用0、1作为标识，使用 互斥信号量 后其他进程无法访问
    - 如：像厕所隔间的门锁，门锁打开时表示空闲，可以进入。门锁关闭时，其他人需要等待，要==获取== 门锁（==互斥信号量==）==才能使用==资源

### 同步

- 多进程互相协调，按 ==顺序== 执行
  - 同步 可以防止进程之间出现竞争和冲突，从而提高程序的正确性和效率
- ==同步信号量==
  - 是一个 ==共享==变量，表示资源的==数量==
    - 如：餐厅桌子有限，如果有餐桌空闲，可以直接使用，当餐桌都满了，顾客需要等待，餐桌就是 ==同步信号量== ，表示餐桌的==数量==

### PV操作

- P操作

  - ==申请==资源，`S = S - 1`
    - S：表示资源数
    - 申请了一个资源走，S就要减1
  - `S >= 0`时，S表示 ==资源数量==
    - 则 执行**P操作** 的进程 ==继续执行==

  - `S < 0`时，S表示 ==阻塞== 的进程数量
    - 则 进程变为 阻塞状态 ，并将其插入 ==阻塞队列==
- V操作

  - ==释放==资源，`S = S + 1`
  - `S > 0`时，表示 资源 有==空余==，没有 阻塞 的进程，该进程继续执行
  - `S <= 0`时，表示需要从 ==阻塞队列== 中 ==唤醒== 一个被P操作阻塞的进程，将其==插入就绪队列== ，然后==执行V操作==的进程继续
    - 注意！是`<= 0`时 唤醒 ，说明释放一个资源就 立马 分给排队的进程
    - 在计算时，注意是 ==先加再判断== 信号值
      - 如果`S > 0`==不会改变==当前正在执行的代码！

### 生产者和消费者 类型问题

- 三个信号量
  - 互斥 信号量S~0~
    - 即仓库 独立 使用权
  - 同步 信号量S~1~
    - 即仓库 空闲位置
  - 同步 信号量S~2~
    - 即仓库 现有 商品个数
- ==生产者== 流程
  1. ==生产== 商品：占用 互斥 信号量S~0~
  2. P(S~0~)：==占用== 仓库 ==使用权==，S~0~ - 1 = 0
     - S~0~ 是 互斥信号量 ，空闲 时，值为1
  3. P(S~1~)：==申请== 仓库 ==空位== ，设S~1~初始值为100个，S~1~ - 1 = 99
  4. 将商品 ==放入== 仓库中
  5. V(S~2~)：仓库 商品个数+1，S~2~初始值为0个，S~2~ + 1 = 1
  6. V(S~0~)：已完成操作，==释放== 互斥信号量
- ==消费者== 流程
  1. P(S~0~)：==占用== 仓库 ==使用权==，S~0~ - 1 = 0
  2. P(S~2~)：==消耗== 仓库商品，S~2~ - 1 = 0
  3. 取出一个商品
  4. V(S~1~)：==释放== 一个仓库 ==空位==，S~1~ + 1 = 100
  5. V(S~0~)：==释放== 仓库 ==使用权==

### 相关题目

#### PV操作

- 进程P1到P5的前趋图

  ![题目前趋图1.png](https://github.com/hjxool/static-resource-save/blob/main/%E9%A2%98%E7%9B%AE%E5%89%8D%E8%B6%8B%E5%9B%BE1.png?raw=true)

  <center>图1</center>


- 若用PV操作控制进程P1到P5并发执行的过程，则需要设置5个信号S1到S5，且信号量S1到S5的初值都等于0.下图a、b处应分别填写( )；c、d处应分别填写( )；e、f处应分别填写( )

  ![题目图2.png](https://github.com/hjxool/static-resource-save/blob/main/%E9%A2%98%E7%9B%AE%E5%9B%BE2.png?raw=true)
  <center>图2</center>

- 分析技巧
  - ==第一个== 进程 ==只有V操作==，==最后一个== 进程 ==只有P操作==
    - 同 生产者 和 消费者 之间的关系。进程 每生产一个数据包，就执行一次V操作，通知系统有一个新的数据包可供消费。进程 每处理一个数据包**前**，就执行一次P操作，**检查**是否有数据包可供处理，如果没有数据包（信号量值小于0），就会被阻塞
    - 第一个进程是==生产者进程==，在生产资源后通过==V操作**增加**信号量的值==，表示有新的资源可用
    - 最后一个进程则是==消费者进程==，在消费资源前，通过==P操作**减少**信号量的值==，表示资源被消耗
    - 所以==第一个==进程==没有P操作==，而==最后一个==进程==没有V操作==
  - 进程 的 ==PV操作== **都是** ==先P后V==
    - ※所以 图2 ==上==面部分都是 ==P操作== ，而==下==面都是 ==V操作==
    - 根据这个技巧缩小答案范围
  - 标记信号S
    - 有几根线连 ==到== 进程，则有几个 ==P操作==
    - 进程有几根连 ==出去== 的线，则有几个 ==V操作==
    - 根据这个技巧标记信号S~n~

#### 生产者和消费者

- 两个同优先级的进程P1和P2，并发执行后a、b、c结果为？

  ![题目图3.png](https://github.com/hjxool/static-resource-save/blob/main/%E9%A2%98%E7%9B%AE%E5%9B%BE3.png?raw=true)

- 技巧及陷阱
  - 技巧
    - PV操作的信号量S，都是 ==先运算==再判断！
    - P1、P2中的V操作就是生产操作，P操作就是消费者操作，互为生产者消费者关系
  - 陷阱
    - 当 V操作 唤醒阻塞 的进程后，==先执行完==当前进程！再执行唤醒的进程

## 死锁和线程

### 死锁

- 当进程在等待 **永不可能** 发生的事件时，就会产生 死锁 ，若系统中多个进程处于 死锁 状态，就会造成 ==系统死锁==
- 死锁 产生 的 四个 ==必要条件==

  - 资源互斥
    - 即资源只允许一个进程取用
    - ==临界资源==
  - **每个**进程占有资源，并等待其他资源
    - 例：一个人有苹果，另一个人有刀子，但是互相都不给对方
  - 系统不能剥夺进程资源
  - 进程资源是个环路
- 死锁产生后的 ==解决措施==

  - 死锁==预防==
    - 使用策略==限制==对资源的==请求==，只要不满足四个必要条件，避免死锁
  - ※死锁==避免==
    - 一般用 ==银行家算法== 来避免
      - 银行家算法：提前 计算出一条不会死锁的资源分配方法。好比借贷，考虑对方还得起才借钱
  - 死锁检测
    - **允许**死锁**产生**，但系统定时检测死锁，将其解除
  - 死锁解除
    - 如：强制剥夺资源、撤销进程等
- 死锁 ==计算公式==

  - 系统内有N个进程，每个进程都需要R个资源

<center>发生死锁 最大资源数 = N * (R - 1)</center>

<center>不发生死锁 最小资源数 = N * (R - 1) + 1</center>

- 发生死锁最大资源数
  - 指能发生死锁的资源数，超过这个数就不会发生死锁
- 不发生死锁最小资源数
  - 与发生死锁最大资源数相对，超过发生死锁最大资源数就可以保证不会发生死锁

### 相关题目

#### 银行家算法

![题目图4.png](https://github.com/hjxool/static-resource-save/blob/main/%E9%A2%98%E7%9B%AE%E5%9B%BE4.png?raw=true)

- 分析过程
  - 剩余的可用资源数
    - 指 原有资源数 - 已经被分配资源数
    - R1原有10个，从图中已分配数可看出R1已用掉8个，R1剩余可用资源数为2
    - 同理，R2剩余0个，R3剩余1个
  - 按什么顺序执行，系统才是安全的
    - 选项A
      - P1分得1个R1资源，最大需求数5，则仍需4个R1资源，此时R1只剩2个，因此A错误
    - 选项C
      - P4分得1个R1资源，最大需求数3，仍需2个R1，此时R1剩2个，满足
      - P4分得1个R2，最大需求数3，仍需2个R2，此时R2剩0个，不满足，选项C错
    - 选项B 和 选项D
      - 都是P5开头，P5分得1个R1，最大需求数2，仍需1个R1，此时R1剩2个，满足
      - P5分得1个R2，最大需求数1，仍需0个R2，满足
      - P5分得0个R3，最大需求数1，仍需1个R3，此时R3剩1个，满足
      - 对比选项B和D得P2和P1
        - 此时P5执行完毕，==释放资源==
          - R1 当前可用资源数 = 原剩余2 + P5原分配1 = 3
          - R2 当前可用资源数 = 原剩余0 + P5原分配1 = 1
          - R3 当前可用资源数 = 原剩余1 + P5原分配0 = 1
        - P1分得1个R1，最大需求数5，仍需4个R1，此时R1剩3个，不满足，选项D错
      - 答案B

### 线程

- 线程 与 进程
  - ==线程== 是==可调度==的 ==最小==单位
  - ==进程== 是==拥有资源==的==最小==单位
- 线程 特性
  - ==共享== 进程的公共数据、**全局**变量、代码、文件等资源
  - ==不共享== 线程==独有==资源
    - 如：线程的 ==栈==、==指针==等数据
