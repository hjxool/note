## 操作系统概述

- 何谓操作系统？
  - ==硬件==环境上==构建==得==软件==环境，这个软件可以使用硬件功能
    - 如手机操作系统、电脑操作系统、嵌入式操作系统
- 操作系统作用
  - 提高计算机使用效率
  - 提供人机界面
- 操作系统特性
  - 并发
    - 如：同时启动多个软件
  - 共享
    - 所有文件资源对程序都是共享的
  - 虚拟性
    - 类似 虚拟机，不是直接操作调动硬件，而是隔了一层
  - 不确定性
    - 如：并发引起的资源竞争，硬件故障等因素
- 操作系统功能
  - ※==进程==管理
  - ※==存储==管理
  - ※==文件==管理
  - ※==设备==管理
  - 作业管理
- 操作系统分类
  - 批处理 操作系统
  - 分时 操作系统
    - ==轮流==使用CPU
  - 实时 操作系统
    - 快速响应
  - 网络 操作系统
  - 分布式 操作系统
    - 物理意义上 ==分散== 的计算机 ==互联== 系统
  - 微机 操作系统
    - 如：Windows
  - 嵌入式 操作系统

- 计算机 启动 流程
  - `BIOS -> 主引导记录 -> 操作系统`
    - BIOS
      - 开机时会进入自检页面，只是厂家会用logo盖住，也可以用F12等进入BIOS
      - ==直接== 对 ==硬件== 进行设置
    - 主引导记录
      - 如：装了 双系统 时，选择进入哪个操作系统

## 进程的组成和状态

- 什么是 进程 ？
  - 程序 是一堆 `bit`序列，当运行时，CPU会在 内存 中为其开辟一块区域即 进程，因此 进程 就是 程序 的意思
  - 而 线程 是 进程 中 最小执行单元
  - ==进程==（程序）是计算机中 正在运行 的 ==程序的实例==
    - 是系统进行 资源分配 和 管理 的 ==基本单位==
    - 包括 **代码**、**数据**、执行**状态**
- 进程的 组成
  - 进程控制块（PCB）
    - 简单记，即 ==唯一标识==，进程管理界面中的 ID号
  - 程序
    - 描述进程 ==做什么==
  - 数据
    - 存储进程 ==执行时== 所需 ==数据==

- ==进程状态==分为
  - 非人为 干涉的三态图
    - 见书P50
    - 概念介绍
      - 运行
        - 进程正在执行，注意CPU中有 ==时间片段== 的概念，也就是 切换 执行程序，但是因为很快，所以宏观上看是 并行
        - 如果是 多核，每个核都可以设置一条 时间片段，轮换 执行任务
        - 注：运行 属于 三态图，所以具体程序执行多长时间让出CPU控制权，取决于计算机底层，分配给每个进程的 执行时间
      - 就绪
        - 运行 时间片段 到期后，进入==下一个状态== 即 ==就绪==状态
        - 等待下一次 受 CPU调度，拿到CPU使用权，再次进入 ==运行==状态
      - 等待（阻塞）
        - 当 进程 ==等待== 外部事件的结果时，会 挂起
        - 当 等待 的事件给出结果了，就会进入 ==就绪== 状态**排队**
        - 注：等待 **不能** 直接回到 运行状态
  - 人为 干涉的五态图
    - 多了 ==静止就绪== 和 ==静止阻塞== ，需要 人为 操作才会进入
    - 活跃就绪 即 就绪
    - 活跃阻塞 即 等待

## 前趋图和进程资源图

- ==前趋图==
  - 表示哪些 ==进程== 可以 ==并行== 执行，哪些 进程 之间有 ==顺序== 关系
- 进程 资源 图
  - 表示 ==进程== 和 ==资源== 之间的 ==请求== 和 ==分配== 关系
  - ==资源== 指向 进程的线，表示资源 ==分配== 给对应进程
  - ==进程== 指向 资源的线，表示进程 ==请求(申请)== 资源
  - ==阻塞== 节点
    - 进程 向 资源 请求，但是==资源已经分配完==，该 进程 就被阻塞，只能 等待 资源被释放 
    - 注：**无论** 进程 是否已经**被** 其他 资源池**分配了资源**，**只要**它所==请求的资源==池==没有空余==资源，就会==阻塞==！
    - 当图中所有 进程 ==都是阻塞节点== 时，即陷入 ==死锁== 状态
      - ==死锁== 状态==不可化简==
        - 化简 思路：让 非阻塞节点 先运行
          - 因此化简 ==顺序== 中 非阻塞节点 在前
    - 例：存在资源池R1和进程P1，R1将资源分配给P1，P1向R1请求，此时P1是 阻塞 节点
      - 因为R1分配后已经没有资源，而P1又请求资源，尽管此时P1已经被R1分配了资源，但是请求的是额外的资源，还是阻塞
  - ==非阻塞== 节点
    - **只要** 没有被阻塞，就是 非阻塞节点

## 同步与互斥

### 互斥

- 指 ==同一时间== **只允许一个**进程访问某个资源，其他进程必须==等待==
  - 互斥是为了防止多进程同时访问一个资源，造成数据损坏和程序崩溃
    - 如：打印机
    - 其实是一种 防卫场景
  - ==0== 表示有进程==占用==，==1== 表示 ==没有进程使用==
- ==临界资源==
  - 被==互斥方式==的进程访问的资源
- ==互斥信号量==
  - 访问 ==临界资源== 时的 控制==标识==，用0、1作为标识，使用 互斥信号量 后其他进程无法访问
    - 如：像厕所隔间的门锁，门锁打开时表示空闲，可以进入。门锁关闭时，其他人需要等待，要==获取== 门锁（==互斥信号量==）==才能使用==资源

### 同步

- 多进程互相协调，按 ==顺序== 执行
  - 同步 可以防止进程之间出现竞争和冲突，从而提高程序的正确性和效率
- ==同步信号量==
  - 是一个 ==共享==变量，表示资源的==数量==
    - 如：餐厅桌子有限，如果有餐桌空闲，可以直接使用，当餐桌都满了，顾客需要等待，餐桌就是 ==同步信号量== ，表示餐桌的==数量==

### PV操作

- P操作

  - ==申请==资源，`S = S - 1`
    - S：表示资源数
    - 申请了一个资源走，S就要减1
  - `S >= 0`时，S表示 ==资源数量==
    - 则 执行**P操作** 的进程 ==继续执行==

  - `S < 0`时，S表示 ==阻塞== 的进程数量
    - 则 进程变为 阻塞状态 ，并将其插入 ==阻塞队列==
- V操作

  - ==释放==资源，`S = S + 1`
  - `S > 0`时，表示 资源 有==空余==，没有 阻塞 的进程，该进程继续执行
  - `S <= 0`时，表示需要从 ==阻塞队列== 中 ==唤醒== 一个被P操作阻塞的进程，将其==插入就绪队列== ，然后==执行V操作==的进程继续
    - 注意！是`<= 0`时 唤醒 ，说明释放一个资源就 立马 分给排队的进程
    - 在计算时，注意是 ==先加再判断== 信号值
      - 如果`S > 0`==不会改变==当前正在执行的代码！

### 生产者和消费者 类型问题

- 三个信号量
  - 互斥 信号量S~0~
    - 即仓库 独立 使用权
  - 同步 信号量S~1~
    - 即仓库 空闲位置
  - 同步 信号量S~2~
    - 即仓库 现有 商品个数
- ==生产者== 流程
  1. ==生产== 商品：占用 互斥 信号量S~0~
  2. P(S~0~)：==占用== 仓库 ==使用权==，S~0~ - 1 = 0
     - S~0~ 是 互斥信号量 ，空闲 时，值为1
  3. P(S~1~)：==申请== 仓库 ==空位== ，设S~1~初始值为100个，S~1~ - 1 = 99
  4. 将商品 ==放入== 仓库中
  5. V(S~2~)：仓库 商品个数+1，S~2~初始值为0个，S~2~ + 1 = 1
  6. V(S~0~)：已完成操作，==释放== 互斥信号量
- ==消费者== 流程
  1. P(S~0~)：==占用== 仓库 ==使用权==，S~0~ - 1 = 0
  2. P(S~2~)：==消耗== 仓库商品，S~2~ - 1 = 0
  3. 取出一个商品
  4. V(S~1~)：==释放== 一个仓库 ==空位==，S~1~ + 1 = 100
  5. V(S~0~)：==释放== 仓库 ==使用权==

### 相关题目

#### PV操作

- 进程P1到P5的前趋图

  ![题目前趋图1.png](https://github.com/hjxool/static-resource-save/blob/main/%E9%A2%98%E7%9B%AE%E5%89%8D%E8%B6%8B%E5%9B%BE1.png?raw=true)

  <center>图1</center>


- 若用PV操作控制进程P1到P5并发执行的过程，则需要设置5个信号S1到S5，且信号量S1到S5的初值都等于0.下图a、b处应分别填写( )；c、d处应分别填写( )；e、f处应分别填写( )

  ![题目图2.png](https://github.com/hjxool/static-resource-save/blob/main/%E9%A2%98%E7%9B%AE%E5%9B%BE2.png?raw=true)
  <center>图2</center>

- 分析技巧
  - ==第一个== 进程 ==只有V操作==，==最后一个== 进程 ==只有P操作==
    - 同 生产者 和 消费者 之间的关系。进程 每生产一个数据包，就执行一次V操作，通知系统有一个新的数据包可供消费。进程 每处理一个数据包**前**，就执行一次P操作，**检查**是否有数据包可供处理，如果没有数据包（信号量值小于0），就会被阻塞
    - 第一个进程是==生产者进程==，在生产资源后通过==V操作**增加**信号量的值==，表示有新的资源可用
    - 最后一个进程则是==消费者进程==，在消费资源前，通过==P操作**减少**信号量的值==，表示资源被消耗
    - 所以==第一个==进程==没有P操作==，而==最后一个==进程==没有V操作==
  - 进程 的 ==PV操作== **都是** ==先P后V==
    - ※所以 图2 ==上==面部分都是 ==P操作== ，而==下==面都是 ==V操作==
    - 根据这个技巧缩小答案范围
  - 标记信号S
    - 有几根线连 ==到== 进程，则有几个 ==P操作==
    - 进程有几根连 ==出去== 的线，则有几个 ==V操作==
    - 根据这个技巧标记信号S~n~

#### 生产者和消费者

- 两个同优先级的进程P1和P2，并发执行后a、b、c结果为？

  ![题目图3.png](https://github.com/hjxool/static-resource-save/blob/main/%E9%A2%98%E7%9B%AE%E5%9B%BE3.png?raw=true)

- 技巧及陷阱
  - 技巧
    - PV操作的信号量S，都是 ==先运算==再判断！
    - P1、P2中的V操作就是生产操作，P操作就是消费者操作，互为生产者消费者关系
  - 陷阱
    - 当 V操作 唤醒阻塞 的进程后，==先执行完==当前进程！再执行唤醒的进程

## 死锁和线程

### 死锁

- 当进程在等待 **永不可能** 发生的事件时，就会产生 死锁 ，若系统中多个进程处于 死锁 状态，就会造成 ==系统死锁==
- 死锁 产生 的 四个 ==必要条件==

  - 资源互斥
    - 即资源只允许一个进程取用
    - ==临界资源==
  - **每个**进程占有资源，并等待其他资源
    - 例：一个人有苹果，另一个人有刀子，但是互相都不给对方
  - 系统不能剥夺进程资源
  - 进程资源是个环路
- 死锁产生后的 ==解决措施==

  - 死锁==预防==
    - 使用策略==限制==对资源的==请求==，只要不满足四个必要条件，避免死锁
  - ※死锁==避免==
    - 一般用 ==银行家算法== 来避免
      - 银行家算法：提前 计算出一条不会死锁的资源分配方法。好比借贷，考虑对方还得起才借钱
  - 死锁检测
    - **允许**死锁**产生**，但系统定时检测死锁，将其解除
  - 死锁解除
    - 如：强制剥夺资源、撤销进程等
- 死锁 ==计算公式==

  - 系统内有N个进程，每个进程都需要R个资源

<center>发生死锁 最大资源数 = N * (R - 1)</center>

<center>不发生死锁 最小资源数 = N * (R - 1) + 1</center>

- 发生死锁最大资源数
  - 指能发生死锁的资源数，超过这个数就不会发生死锁
- 不发生死锁最小资源数
  - 与发生死锁最大资源数相对，超过发生死锁最大资源数就可以保证不会发生死锁

### 相关题目

#### 银行家算法

![题目图4.png](https://github.com/hjxool/static-resource-save/blob/main/%E9%A2%98%E7%9B%AE%E5%9B%BE4.png?raw=true)

- 分析过程
  - 剩余的可用资源数
    - 指 原有资源数 - 已经被分配资源数
    - R1原有10个，从图中已分配数可看出R1已用掉8个，R1剩余可用资源数为2
    - 同理，R2剩余0个，R3剩余1个
  - 按什么顺序执行，系统才是安全的
    - 选项A
      - P1分得1个R1资源，最大需求数5，则仍需4个R1资源，此时R1只剩2个，因此A错误
    - 选项C
      - P4分得1个R1资源，最大需求数3，仍需2个R1，此时R1剩2个，满足
      - P4分得1个R2，最大需求数3，仍需2个R2，此时R2剩0个，不满足，选项C错
    - 选项B 和 选项D
      - 都是P5开头，P5分得1个R1，最大需求数2，仍需1个R1，此时R1剩2个，满足
      - P5分得1个R2，最大需求数1，仍需0个R2，满足
      - P5分得0个R3，最大需求数1，仍需1个R3，此时R3剩1个，满足
      - 对比选项B和D得P2和P1
        - 此时P5执行完毕，==释放资源==
          - R1 当前可用资源数 = 原剩余2 + P5原分配1 = 3
          - R2 当前可用资源数 = 原剩余0 + P5原分配1 = 1
          - R3 当前可用资源数 = 原剩余1 + P5原分配0 = 1
        - P1分得1个R1，最大需求数5，仍需4个R1，此时R1剩3个，不满足，选项D错
      - 答案B

### 线程

- 线程 与 进程
  - ==线程== 是==可调度==的 ==最小==单位
  - ==进程== 是==拥有资源==的==最小==单位
- 线程 特性
  - ==共享== 进程的公共数据、**全局**变量、代码、文件等资源
  - ==不共享== 线程==独有==资源
    - 如：线程的 ==栈==、==指针==等数据

## 存储管理

- 指的是管理如何运行程序，如10G的游戏，如何在4G内存中运行

### 页式存储

- 程序往往是比内存大的，程序在执行时，是不会一次性把所有内容装入内存，页式存储就是将 ==程序== 分为若干 ==页==，每个页固定大小，一般是4Kb，把这些页==离散==（依靠算法）的存到内存中，而内存是按==块==来划分的，所以通过 ==页表== 来**映射**==程序中 **页** 在内存中 **块** 的存储==
  - 注：==页表==存在==内存==当中
- 逻辑地址
  - 与 ==页== 关联
  - 是有CPU生成的==虚拟地址==，所以==逻辑地址==**并不一定**对应==物理内存中实际位置==，而是由操作系统进行地址==转换后才能访问物理内存==
    - 虚拟地址：因为还没加载到内存中，只是生成的假地址
- 物理地址
  - 与 ==块== 关联
  - 是==物理内存中实际位置==，是计算机硬件**直接寻址**地址
- 优点
  - 利用率高、分配管理简单
    - 因为每一 页 很小，所以分割出的每一部分很小，因此最后一页中，残留的碎片不到4K
- 缺点
  - 增加了系统开销，可能产生==抖动==现象

### 页面置换算法

- 内存比硬盘小很多，在程序运行时，肯定会有一部分内存数据出来，硬盘中一部分数据换进去，这就是页面置换
- 有以下几种算法
  - 最优算法（OPT）
    - 是一种理想结果，==无法实现==，一般作为衡量指标，对比算法差距
  - 先进先出算法（FIFO）
    - 就是 队列
    - 先进入内存的 页 先被置换淘汰，会产生==抖动==，分配的 页 越多，效率越低
      - 抖动：某些数据使用频率很高，根据先进先出算法，它已经被替换出去，频繁把 页 换进换出，会导致效率低下。好比家里找东西，老是把东西拿出来又放回去，没找到东西还把家里弄得一团糟
  - 最近最少使用（LRU）
    - 老熟客了，就是将最长时间没用到的 页 置换淘汰，保留最近常使用的
      - 这应用到了局部性原理，效率高，且不会产生抖动
- 缺页
  - 表示==需要执行的== 页 ==不在==**内存**物理 **块** 中，需要从外部调入内存，会增加进程执行时间，因此，缺页 ==越多系统效率越低==

## 快表及文件结构

### 快表

- 类似页表，是为了解决页表存在内存中这一桎梏，进一步提升效率，所以将==快表==存在==Cache==中、
  - 注：在计算机硬件基础章节中有解释，Cache运行速度快于主存(内存)，慢于寄存器
  - 相对的概念，慢表，就是 页表 存在内存当中
- 快表是一块小容量的相联存储器，是个硬件设备
- 一般用于存放当前访问==最频繁==的==少数==活动页面的页号
- 可以看作 页表 频繁访问的数据的==副本==，也远==小于==慢表
- 慢表 要访问两次内存才能取出数据(第一次查页表，第二次取数据)，而 快表 访问一次==Cache==一次==内存==，快一点

### 段式存储

- 相比于 页式存储 每一 页 大小是4K，段式存储 的每一 段 ==大小不固定==
- 将进程空间分为多个段，每段有 段号 和 段内地址(同页式存储的页号和页内地址)，根据==逻辑整体==分段(逻辑性强)
  - 按逻辑分段：即不会因为4K这类大小限制，强制把完整的程序逻辑分开
- 优点
  - 程序逻辑完整，修改互不影响
- 缺点
  - 内存利用率低，碎片大
- 地址表示
  - 使用`(段号, 段内偏移)`表示，如`(1, 1000)`表示该段号对应的数据长度不能超过1000，否则出现==越界错误==
- ==真实内存地址==
  - 段号对应的 ==基地址== + ==段长==
    - 基地址：内存空间中起始位置，如，40K表示在 内存 中从40KB字节长度**后**开始存数据
    - 段长：这 段 中数据最大存储长度
  - 有时候，后一段的基地址比前一段的基地址 + 段长还长，因此中间会留下阴影，也就是空白区域
  - 缺点：空间利用率不行，可以看到有很多空白内存区域

### 段页存储

- 对进程空间==先分段再分页==
- 优点
  - 空间浪费小
  - 存储共享容易
    - 如两个程序放到一个共享的段中，两个程序都可以访问这个段，而不需要各自再加载一遍
  - 能动态连接
    - 即逻辑连贯性强
- 缺点
  - 复杂度和开销增加，运行速度低

### 文件管理

- 为了扩充存储，索引中还可以存索引，也就是索引存的是外部物理盘块的地址，类似对象下属性是另一个对象
  - 索引：即存放的数据内容
- 计算
  - 系统索引假设有13个，0-9为直接索引，大小为4KB
    - 则可存数据为 4KB * 10 = 40KB
  - 索引10为一级索引，大小为4KB，一级索引内每个索引假设大小为4B
    - 则可放 4KB / 4B = 1K，即1024个地址
    - 每个地址对应一个物理盘，则可存 1024 * 4KB = 4098KB 数据
  - 索引11~12为二级索引
    - 以此类推，一级为1024个地址，二级地址数为 1024 * 1024
    - 则二级索引可存数据 1024 * 1024 * 4KB

### 树形文件

- 相互路径
  - 从当前路径开始，即不用显示当前目录，直接从下级开始写
  - ==不写文件名==
- 绝对路径
  - 从根目录开始写，因此要加盘符
  - ==不写文件名==
- 全文件名
  - 绝对路径 + ==文件名==

### 空间存储

- 位示图法
  - 每个物理空间用一个标识，0表示空闲，1表示使用
  - 存储规则：==先列后行==
    - 先把一行摆满，再往第二行排

### 微内核操作系统

- 微内核
  - 即内核很小，所以功能很少，只实现基本功能
  - 优点
    - 便于裁剪和移植
    - 系统稳定性和安全性较高，多用于分布式系统
  - 缺点
    - 一部分功能放在了用户进程，因此需要频繁切换，导致效率不如单体内核
- 单体内核
  - 文件系统等功能全在内核中实现
  - 优点
    - 减少进程通信和状态切换开销，运行效率高
  - 缺点
    - 内核庞大臃肿，不易裁剪，稳定性和安全性略差

### 嵌入式操作系统

- 嵌入到小型板块上的操作系统，可调用资源匮乏，因此要求代码质量高
- 同样有内核共通的功能：异常和中断、计时器、I/O管理
- 启动嵌入式操作系统时
  1. 会先将板子上的芯片初始化加载
     - 芯片：即处理器
  2. 再进行板卡的初始化
     - 板卡：硬件拓展模块
  3. 最后进行系统初始化

### 虚设备和SPOOLING技术

- SPOOLING技术其实就是缓存，来多少设备输入都先存下，按顺序一个个发给外设处理
