## Tips：

- **ES6**中对对象中的函数形式进行了简化，对象中本来应该使用`函数名(键)：function(){ }值`的形式，简化为了`函数名(){ }`

- ES5：for(let i,i<length,i++) → ES6：for(let item of items) 用法类似于v-for 

- for await of：在遍历循环异步方法时，会暂停等前一步循环的代码块执行完才继续执行

- 为什么需要数据代理？就是因为底层的的逻辑不会暴露出你增删改查时的动作，所以只能通过外部自己定义的操作来关联原来的操作，让他执行增删改查时先过一道自己写的程序，从而捕获到这个动作

- ES6新增let和const。var是全局变量，即使是在区块内声明也是作用全局


## string扩展

- padStart和padEnd，有两个参数，第一个是要保持的长度，第二个是长度不够的补白字符

## 模块数据语法：

- 在一个**js文件**中想`**暴露**`和`**引入**`一些方法和属性，有几种对应形式：
  1. 通用形式：`import * as 别名 from "文件路径"``
  2. ``export 对象；export function`或者`export{ 对象，函数名 }`——`import {暴露的对象和方法名} from 路径`
  3. 引入默认暴露时不能直接用default表示引入的对象，必须用`as 别名``
  4. ``export default { 写入属性和方法 }`——`import {default as xxx} from 路径`或者`import xxx from 路径`
  5. 动态引入：在需要用到的地方调用`**import('地址').then(传入的模块 =>{模块.里面暴露的方法})**`，import函数，其返回值是promise对象

- 要引入**css文件**，直接使用`**import 路径**`

## 扩展运算符和rest参数：

  “**rest参数**”：`function (**...params)**`传入**不定数量**的参数，使用时是当`**数组**`使用，它是一个参数组成的数组。(**注！rest参数必须要放到最后**)

  “**扩展运算符**”：·**...**·三个点符号。跟·rest参数·很像，但是·rest参数·只能放在·函数**形参**·的位置

​		Tips：

​			1、 **...数组**·，只能用在·**传实参**·时，将数组转换成·**参数序列**·，即取出每一个数组元素，然后用逗号分隔，传入函数，函数收到的是等同数组长度数量的参数（**注！**只有一个**变量**用来接收传入的参数时，**只能**使用·**arguments**·关键词）

​			2、·**参数序列**·这点很重要！，这意味着使用·扩展运算符·转化的变量，会·**失去引用地址**·，作为单纯的·**基本**·数据类型依次排列·**放入**·对应的·**位置**·，因为是·参数序列·，因此只能依托容器包裹

​			3、 传**实参**时，不能用·function (...object)·，因为·object··**不可迭代**·，但可以写成这种形式·**function ({ ...object})**·，即传入一个对象进去

## 解构赋值：

  简单来说就是——用同等结构或数量的参数直接接收要复制的变量

  **数组**解构赋值：let **[** a，b，c **]** = 数组，注意此处左边是·**[ ]**·

  **对象**解构赋值：let **{** key1，key2 **}** = 对象，无需调用对象属性就可以取出

​    Tips：

​      1、key1/2是对象中·**同名属性**·

​      2、对于函数中默认参数·**function (params...)**·，也可以使用解构赋值。使用方式·**function ( {解构参数} )**·，甚至还可以·**function (解构参数：{ parms1,parms2 })**·

  **字符串**解构赋值：let **[** str1，str2 **]** = 字符串，字符串也可以视作数组，可以获取到每一个字母

## 数据代理：

  在ES6之前使用·defineProperty(要代理的对象，自命名属性，{ get()，set() })·，很笨拙，需要知道代理对象的属性名才能检测数据变化，且需要一个一个设置get和set

  在ES6之后提出了·**proxy**·，它不用笨拙的对属性一个个进行代理，而是对整个目标对象代理

​    使用方法：

​      1、·**proxy(target，{ get(target，name)，set(target，name，value) }，deleteProperty(target，name))**·

​      2、get函数中有两个默认参数：`**target**`是·**要代理的对象**·、·**name**·是·**检测到读取的属性名**·，·**string类型**·。所以get中的return要这么写·return **target[name]**·

​      3、set函数有三个默认参数：前两个target和name和get函数的相同、第三个·**value**·是·修改传入的值·

​        Tips：原版·defineProperty·监测不到劫持对象的·**增删**·，而·**proxy**·的set加入了监测·**增**·的能力，当使用·**obj.新属性时**·，也可以监测的到

​      4、deleteProperty函数有两个默认参数，同get函数，**必须**要有返回值，返回·return **delete target[name]**·

​        Tips：

​          1、当·**没使用**·deleteProperty函数时，对象数据是可以直接删除操作的，当写了以后，**必须**要在·**return时**·执行删除，不然会删除失败，其实就是当你删除操作时，js帮你把删除放到了·**deleteProperty**·函数中执行，**同时**帮你**监测**删除动作

​          2、没有使用脚手架时，用·**<script/>**·标签引入等同于·**import**·导入，同样都可以用vue的·**mixins**·等导入外部对象配置项

​          3、对数据代理本质的理解：对原始数据的操作是无法监测的，而数据代理就像一道筛网，通过另一个对象来映射原始数据，同时在映射对象身上添加了对应各种操作的拦截方法，从而达到修改映射对象时，既可以修改原始数据，同时还能拦截到操作

## Reflect：

  最大的作用是——不需要·**try{}catch(error){}**·，最典型的一个例子就是·defineProperty·出错时，整个单线程程序都会挂掉，所以封装的框架中通常都要用·try catch·来捕获错误，同时保证程序正常运行。**而**·**reflect**·则不用，它在使用·defineProperty·时，会返回·**执行成功或失败**·，而不会使整个代码都挂掉，**同时**·**reflect**·身上还有全套的object对象操作方法