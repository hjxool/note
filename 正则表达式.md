![](https://upload-images.jianshu.io/upload_images/6322775-3a41f9749ebb13f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
***
 使用`或|`表达式时，必须用`()`包起来
`()`的作用是使括号中的作为一个整体，进行判断

***
RegExp和双斜杠的区别：双斜杠内只能写字符串，不能传入变量

***
- `()`是为了提取匹配的字符串，有几个`()`就有几个对应的匹配结果
- `[]`是匹配的字符范围，比如`[a-zA-Z0-9]`表示相应位置的字符要匹配英文字符和数字。
- `()`同时也是分组，可以用`$x`取到`第几组`匹配的项，但是`(?:abc)`表示匹配但是不记录到`$`变量中
- `a(?=bbb)`顺序环视 表示a后面必须紧跟3个连续的b
***
1. 不管是方括号还是圆括号，每一个括号对应一个字符，`( )[]`对应的就是只有两个字符，字符串长度小于2或者超过2都匹配不到，能叠加的规则只有`?  *  +  {}`，这四个修饰符
2. 如果想匹配除了2-5**以外**的所有**数字**可以这样`[0-16-9]`，因为`^`是个危险的规则，它会匹配除了排除字符以外的**任何字符**，无法限定种类是数字还是什么
3. “子模式()”不能**再嵌套**子模式，不然会出错，不论有没有输入都会通过验证
4. 没有==开头^和结尾$==符号，就会出现==一个字符串==内有的匹配有的不匹配

---

- 语法：`let a = /正则表达式/匹配模式`，匹配模式：==i==忽略大小写，==g==全局搜索

- [test(字符串)]()：`RegExp()`对象的验证方法，返回true/false

- [exec(字符串)]()：执行方法，==返回==匹配到==符合条件的字段==，没有符合条件的返回null

  - `/g`全局匹配的话，需要多次执行，才能取到后面同样符合条件的值

  - ==ES8新特性==：用`(?<名称>)`来为括号内的分组命名，并存储在执行方法里的**groups**字段，以键值对的形式存储

    ```js
    		tong
    let t = '<a href="www.baidu.com">123213</a>'
    let reg = /<a href="(?<命名1>.*)">(?<命名2>.*)<\/a>/
    console.log(reg.exec(t)) => groups:{
        						命名1: www.baidu.com,
                                   命名2: 123213
    						  }

- [[abc]]()：`[]`表示==或==的关系、`[^ ]`表示除了...都可以、`|`表示==或==，通常情况下可以用`[]`代替

- [{m，n}]()：量词，m-n次。指前面的内容出现几次，且必须==连续==出现

  Tips：

  - 只对前边==一个==内容起作用
  - 想作用于多个内容整体用[(aabb){3}]()括号包裹
  - m次以上：`{m , }`

- `^`表示开头，`[^ ]`表示非，`$`表示结尾

- [\w]()等于`[A-z0-9_]`

  - [\W]()：除了`[A-z0-9_]`

- [\b内容\b]()：`\b`包裹的内容，在匹配时必须是==独立==的，比如`asas as`就只有空格后的`as`能被检测到

## 小技巧

- ==去除开头和结尾空格==：`str = str.replace(/^\s*|\s*$/g,"")`，如果不加`g`，则只会匹配开头==或者==结尾的空格，加了`g`，则在匹配到开头的空格后还会==再==全局匹配==或==后面的条件
- `let reg = /\b内容\b/`的形式虽然好用，但是里面的内容是写死的，如果想==动态检索==独立内容，就要使用`let reg = new RegExp('\b'+变量+'\b')`

## 正/反向查

- 正向：xxx==之前的内容==，用`(?=xxx)`的形式。==只能放内容后面==
  - 例：`'1122中间2233结尾'`，正则`/\d+(?=结)/`匹配的结果就是`2233`
- 反向：小于xxx的内容，用`(?<=xxx)`的形式。只能放前面
  - 例：`'1122中间2233结尾'`，正则`/(?<=中间)\d+/`匹配的结果就是`2233`

## dotAll模式

- `.`在正则中是==除了换行符==以外的所有字符，在匹配时如果夹杂着换行符会非常麻烦，要一段一段的加\s。ES新特性出了`/xxx/s`修饰符==s==，使`.`可以匹配所有字符

- 下例即可获取电影名称和时间。

  - `.*?`是禁止贪婪搜索，因为`.*`会匹配第一个`<a>`到最后一个`</a>`

    ```js
    let str = `
    <li>
    	<a>阿甘正传</a>
    	<p>2022-10-1</p>
    </li>
    <li>
    	<a>阿甘正传2</a>
    	<p>2011-10-1</p>
    </li>
    `
    let reg = /<a>(.*?)<\/a>.*?<p>(.*?)<\/p>.*?<a>(.*?)<\/a>.*?<p>(.*?)<\/p>/s